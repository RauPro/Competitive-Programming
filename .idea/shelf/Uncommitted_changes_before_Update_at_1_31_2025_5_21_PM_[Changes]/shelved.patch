Index: ICPC Preparation/Problem Solving Paradigms/Dynamic Programming/0-1 Knapsack (Subset Sum)/562 - Dividing coins.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import os\r\nimport sys\r\nfrom collections import *\r\nfrom heapq import *\r\nfrom math import gcd, floor, ceil, sqrt\r\nfrom copy import deepcopy\r\nfrom itertools import permutations, combinations, product\r\nfrom bisect import bisect_left, bisect_right\r\nfrom functools import lru_cache, reduce\r\nimport operator\r\n\r\n# Para mejorar el rendimiento de la entrada/salida\r\ninput = lambda: sys.stdin.readline().strip()\r\nflush = lambda: sys.stdout.flush()\r\nprint = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get(\"end\", \"\\n\")) and flush()\r\n\r\n# Optimización de la recursión para Python\r\nsys.setrecursionlimit(100000)\r\n\r\n\r\n# Funciones para lectura de múltiples tipos de datos\r\ndef ints(): return map(int, input().split())\r\ndef strs(): return input().split()\r\ndef chars(): return list(input().strip())\r\ndef mat(n): return [list(ints()) for _ in range(n)]  # Matriz de n x m donde m es el número de enteros en una línea\r\n\r\n\r\n# Constantes útiles\r\nINF = float('inf')\r\nMOD = 1000000007  # Modulo por defecto, cambiar si se necesita otro\r\n\r\n\r\n# Algunas funciones útiles\r\ndef add(x, y, mod=MOD): return (x + y) % mod\r\ndef sub(x, y, mod=MOD): return (x - y) % mod\r\ndef mul(x, y, mod=MOD): return (x * y) % mod\r\n\r\n\r\n# Fast power - a^b % mod\r\ndef powmod(a, b, mod=MOD):\r\n    res = 1\r\n    a = a % mod\r\n    while b > 0:\r\n        if b % 2:\r\n            res = mul(res, a, mod)\r\n        a = mul(a, a, mod)\r\n        b //= 2\r\n    return res\r\n\r\n\r\n# Inverso multiplicativo de a modulo m (cuando m es primo)\r\ndef invmod(a, mod=MOD): return powmod(a, mod - 2, mod)\r\n\r\n\r\n# GCD y LCM\r\ndef lcm(a, b): return a * b // gcd(a, b)\r\n\r\n\r\n# Factorial con memoización\r\n@lru_cache(maxsize=None)\r\ndef factorial(n): return n * factorial(n - 1) if n else 1\r\n\r\n\r\n# Combinaciones con memoización (nCr)\r\n@lru_cache(maxsize=None)\r\ndef comb(n, r):\r\n    if r == 0 or r == n: return 1\r\n    return comb(n - 1, r - 1) + comb(n - 1, r)\r\n\r\n\r\ndef main():\r\n    t = int(input())\r\n    for _ in range(t):\r\n        n = int(input())\r\n        a = list(ints())\r\n        print(solve(n, a))\r\n\r\n\r\ndef solve(n ,a ):\r\n    goal = sum(a) // 2\r\n    rem = sum(a) - goal\r\n    #print(goal, \"GOAL\")\r\n    ans = 0\r\n\r\n    @lru_cache(maxsize=None)\r\n    def kns(index, remW):\r\n        if index == n or remW == 0:\r\n            return 0\r\n        if a[index] > remW:\r\n            return kns(index + 1, remW)\r\n        return max(kns(index + 1, remW), a[index] + kns(index + 1, remW - a[index]))\r\n\r\n    ans = kns(0, goal)\r\n    #print(ans, \"ANS\")\r\n    return sum(a) - ans*2\r\n\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    main()\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ICPC Preparation/Problem Solving Paradigms/Dynamic Programming/0-1 Knapsack (Subset Sum)/562 - Dividing coins.py b/ICPC Preparation/Problem Solving Paradigms/Dynamic Programming/0-1 Knapsack (Subset Sum)/562 - Dividing coins.py
--- a/ICPC Preparation/Problem Solving Paradigms/Dynamic Programming/0-1 Knapsack (Subset Sum)/562 - Dividing coins.py	(revision bc7ab91df3db33c143ee3ebd32c794cf710fdacb)
+++ b/ICPC Preparation/Problem Solving Paradigms/Dynamic Programming/0-1 Knapsack (Subset Sum)/562 - Dividing coins.py	(date 1733175987244)
@@ -70,27 +70,27 @@
 
 def main():
     t = int(input())
+    res = []
     for _ in range(t):
         n = int(input())
         a = list(ints())
-        print(solve(n, a))
-
+        res.append(solve(n, a))
+    print("\n".join(map(str, res)))
 
 def solve(n ,a ):
     goal = sum(a) // 2
     rem = sum(a) - goal
     #print(goal, "GOAL")
     ans = 0
-
-    @lru_cache(maxsize=None)
-    def kns(index, remW):
-        if index == n or remW == 0:
-            return 0
-        if a[index] > remW:
-            return kns(index + 1, remW)
-        return max(kns(index + 1, remW), a[index] + kns(index + 1, remW - a[index]))
-
-    ans = kns(0, goal)
+    w = goal
+    dp = [[0 for i in range(w + 1)] for i in range(n + 1)]
+    for i in range(n - 1, -1, -1):
+        for remW in range(w, -1, -1):
+            if remW - a[i] < 0:
+                dp[i][remW] = dp[i + 1][remW]
+            else:
+                dp[i][remW] = max(dp[i + 1][remW], a[i] + dp[i + 1][remW - a[i]])
+    ans = dp[0][w]
     #print(ans, "ANS")
     return sum(a) - ans*2
 
Index: Template.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import os\r\nimport sys\r\nfrom collections import *\r\nfrom heapq import *\r\nfrom math import gcd, floor, ceil, sqrt\r\nfrom copy import deepcopy\r\nfrom itertools import permutations, combinations, product\r\nfrom bisect import bisect_left, bisect_right\r\nfrom functools import lru_cache, reduce\r\nimport operator\r\nfrom random import getrandbits\r\nfrom itertools import accumulate\r\n\r\ninput = lambda: sys.stdin.readline().strip()\r\nflush = lambda: sys.stdout.flush()\r\nprint = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get(\"end\", \"\\n\")) and flush()\r\n\r\nsys.setrecursionlimit(100000)\r\n\r\n\r\ndef ints(): return map(int, input().split())\r\ndef strs(): return input().split()\r\ndef chars(): return list(input().strip())\r\ndef mat(n): return [list(ints()) for _ in range(n)]\r\n\r\nINF = float('inf')\r\nMOD = 1000000007\r\nabcd = \"abcdefghijklmnopqrstuvwxyz\"\r\n\r\ndef add(x, y, mod=MOD): return (x + y) % mod\r\ndef sub(x, y, mod=MOD): return (x - y) % mod\r\ndef mul(x, y, mod=MOD): return (x * y) % mod\r\n\r\ndef invmod(a, mod=MOD): return powmod(a, mod - 2, mod)\r\n\r\ndef lcm(a, b): return a * b // gcd(a, b)\r\n\r\nRANDOM = getrandbits(32)\r\n\r\nclass Wrapper(int):\r\n    def __init__(self, x):\r\n        int.__init__(x)\r\n    def __hash__(self):\r\n        return super(Wrapper, self).__hash__() ^ RANDOM\r\n\r\n# wx = Wrapper(x)\r\n# cnt[wx] = cnt.get(wx, 0) + 1\r\n\r\ndef main():\r\n    t = int(input())\r\n    for _ in range(t):\r\n        n = int(input())\r\n        a = list(ints())\r\n        print(solve(n, a))\r\n\r\n\r\ndef solve(n ,a ):\r\n    pass\r\n\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    main()\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Template.py b/Template.py
--- a/Template.py	(revision bc7ab91df3db33c143ee3ebd32c794cf710fdacb)
+++ b/Template.py	(date 1734884424145)
@@ -10,13 +10,33 @@
 import operator
 from random import getrandbits
 from itertools import accumulate
+from io import BytesIO, IOBase
+from types import GeneratorType
 
-input = lambda: sys.stdin.readline().strip()
+input = lambda: sys.stdin.readline().rstrip("\r\n")
 flush = lambda: sys.stdout.flush()
 print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
 
 sys.setrecursionlimit(100000)
 
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
 
 def ints(): return map(int, input().split())
 def strs(): return input().split()
@@ -46,6 +66,64 @@
 # wx = Wrapper(x)
 # cnt[wx] = cnt.get(wx, 0) + 1
 
+
+
+# region fastio
+
+BUFSIZE = 8192
+
+
+class FastIO(IOBase):
+    newlines = 0
+
+    def __init__(self, file):
+        self._file = file
+        self._fd = file.fileno()
+        self.buffer = BytesIO()
+        self.writable = "x" in file.mode or "r" not in file.mode
+        self.write = self.buffer.write if self.writable else None
+
+    def read(self):
+        while True:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            if not b:
+                break
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines = 0
+        return self.buffer.read()
+
+    def readline(self):
+        while self.newlines == 0:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            self.newlines = b.count(b"\n") + (not b)
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines -= 1
+        return self.buffer.readline()
+
+    def flush(self):
+        if self.writable:
+            os.write(self._fd, self.buffer.getvalue())
+            self.buffer.truncate(0), self.buffer.seek(0)
+
+
+class IOWrapper(IOBase):
+    def __init__(self, file):
+        self.buffer = FastIO(file)
+        self.flush = self.buffer.flush
+        self.writable = self.buffer.writable
+        self.write = lambda s: self.buffer.write(s.encode("ascii"))
+        self.read = lambda: self.buffer.read().decode("ascii")
+        self.readline = lambda: self.buffer.readline().decode("ascii")
+
+
+sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
+
+
+# endregion
+
+
 def main():
     t = int(input())
     for _ in range(t):
@@ -54,10 +132,8 @@
         print(solve(n, a))
 
 
-def solve(n ,a ):
+def solve(n, a):
     pass
 
-
-
 if __name__ == "__main__":
     main()
Index: Codeforces/Codeforces Round 988 (Div 3)/D.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Codeforces/Codeforces Round 988 (Div 3)/D.py b/Codeforces/Codeforces Round 988 (Div 3)/D.py
new file mode 100644
--- /dev/null	(date 1731905824621)
+++ b/Codeforces/Codeforces Round 988 (Div 3)/D.py	(date 1731905824621)
@@ -0,0 +1,133 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+
+
+
+input = lambda: sys.stdin.readline().strip()
+
+
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
+
+def ints(): return map(int, input().split())
+
+
+def strs(): return input().split()
+
+
+def chars(): return list(input().strip())
+
+
+def mat(n): return [list(ints()) for _ in range(n)]
+
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+
+def add(x, y, mod=MOD): return (x + y) % mod
+
+
+def sub(x, y, mod=MOD): return (x - y) % mod
+
+
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+
+RANDOM = getrandbits(32)
+
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+from bisect import bisect_left as lower_bound
+from bisect import bisect_right as upper_bound
+
+
+def main():
+    t = int(input())
+    res = []
+    for _ in range(t):
+        n, m, l = ints()
+        seg = []
+        for i in range(n):
+            a, b = ints()
+            seg.append((a,b))
+        curr = 0
+        curr_pow = 1
+        ans = 0
+        pq = []
+        powers = []
+        no_ans = False
+        heapify(pq)
+        for i in range(m):
+            index, power = ints()
+            powers.append((index, power))
+        pointer_powers = 0
+        for l, r in seg:
+            to_pass = r-l + 2
+            if pointer_powers < len(powers):
+                #print(pointer_powers)
+                while pointer_powers < len(powers) and powers[pointer_powers][0] < l:
+                    heappush(pq, -powers[pointer_powers][1])
+                    pointer_powers += 1
+            if curr < n:
+                while curr_pow < to_pass:
+                    if len(pq) == 0:
+                        no_ans = True
+                        break
+                    ans += 1
+                    curr_pow += -heappop(pq)
+                curr += 1
+        res.append(ans if not no_ans else -1)
+    print("\n".join(map(str, res)))
+
+if __name__ == "__main__":
+    main()
Index: Meta Hacker Cup 2024/Round 2/C/bunny_hopscotch_validation_input.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Meta Hacker Cup 2024/Round 2/C/bunny_hopscotch_validation_input.txt b/Meta Hacker Cup 2024/Round 2/C/bunny_hopscotch_validation_input.txt
new file mode 100644
--- /dev/null	(date 1738365574781)
+++ b/Meta Hacker Cup 2024/Round 2/C/bunny_hopscotch_validation_input.txt	(date 1738365574781)
@@ -0,0 +1,3 @@
+version https://git-lfs.github.com/spec/v1
+oid sha256:f798ef1bb6bb8a2fdebd95a7ff781264cc41d426045779d19d0d12aa027292e8
+size 245495
Index: Meta Hacker Cup 2024/Round 2/C/c_val.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Meta Hacker Cup 2024/Round 2/C/c_val.txt b/Meta Hacker Cup 2024/Round 2/C/c_val.txt
new file mode 100644
--- /dev/null	(date 1738365574781)
+++ b/Meta Hacker Cup 2024/Round 2/C/c_val.txt	(date 1738365574781)
@@ -0,0 +1,3 @@
+version https://git-lfs.github.com/spec/v1
+oid sha256:0cbdf26c06ab1e2607a43789c125dd0c3e4b72a40a571501b66807c8630946e0
+size 102
Index: Codeforces/Codeforces Round 916 (Div 3)/F.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import os\r\nimport sys\r\nfrom collections import *\r\nfrom heapq import *\r\nfrom math import gcd, floor, ceil, sqrt\r\nfrom copy import deepcopy\r\nfrom itertools import permutations, combinations, product\r\nfrom bisect import bisect_left, bisect_right\r\nfrom functools import lru_cache, reduce\r\nimport operator\r\n\r\n# Para mejorar el rendimiento de la entrada/salida\r\ninput = lambda: sys.stdin.readline().strip()\r\nflush = lambda: sys.stdout.flush()\r\nprint = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get(\"end\", \"\\n\")) and flush()\r\n\r\n# Optimización de la recursión para Python\r\nsys.setrecursionlimit(100000)\r\n\r\n\r\n# Funciones para lectura de múltiples tipos de datos\r\ndef ints(): return map(int, input().split())\r\ndef strs(): return input().split()\r\ndef chars(): return list(input().strip())\r\ndef mat(n): return [list(ints()) for _ in range(n)]  # Matriz de n x m donde m es el número de enteros en una línea\r\n\r\n\r\n# Constantes útiles\r\nINF = float('inf')\r\nMOD = 1000000007  # Modulo por defecto, cambiar si se necesita otro\r\n\r\n\r\n# Algunas funciones útiles\r\ndef add(x, y, mod=MOD): return (x + y) % mod\r\ndef sub(x, y, mod=MOD): return (x - y) % mod\r\ndef mul(x, y, mod=MOD): return (x * y) % mod\r\n\r\n# Inverso multiplicativo de a modulo m (cuando m es primo)\r\ndef invmod(a, mod=MOD): return powmod(a, mod - 2, mod)\r\n# GCD y LCM\r\ndef lcm(a, b): return a * b // gcd(a, b)\r\n\r\n# Factorial con memoización\r\n@lru_cache(maxsize=None)\r\ndef factorial(n): return n * factorial(n - 1) if n else 1\r\n\r\n\r\n# Combinaciones con memoización (nCr)\r\n@lru_cache(maxsize=None)\r\ndef comb(n, r):\r\n    if r == 0 or r == n: return 1\r\n    return comb(n - 1, r - 1) + comb(n - 1, r)\r\n\r\n\r\ndef main():\r\n    t = int(input())\r\n    for _ in range(t):\r\n        n = int(input())\r\n        a = list(ints())\r\n        print(solve(n, a))\r\n\r\nlvl = []\r\nAL = []\r\npadre = []\r\ndef dfs(u, p):\r\n    global lvl,AL, padre\r\n    lvl[u] = p\r\n    for v in AL[u]:\r\n        if v != padre[u]:\r\n            padre[v] = u\r\n            dfs(v, p + 1)\r\n\r\n\r\n\r\ndef solve(n , p ):\r\n    global lvl, AL, padre\r\n    AL = [[] for _ in range(n + 1)]\r\n    lvl = [0] * (n + 1)\r\n    padre = [0] * (n + 1)\r\n    for i in range(2, n + 1):\r\n        AL[p[i - 2]].append(i)\r\n    dfs(1, 1)\r\n    #print(lvl)\r\n    lvl = lvl[1:]\r\n    lvl.sort()\r\n    frec = Counter(lvl)\r\n    unpaired = 0\r\n    ans = 0\r\n    #print(frec)\r\n    frec = dict(sorted(frec.items(), key=lambda item: item[0], reverse=True))\r\n    for lv, it in frec.items():\r\n        if it > 1:\r\n            to_match = min(unpaired, it - 1)\r\n            unpaired -= to_match\r\n            it -= to_match\r\n            ans += to_match\r\n        ans += (it // 2)\r\n        #print(ans, it)\r\n        it %= 2\r\n        unpaired += it\r\n    return (ans)\r\n\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    main()\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Codeforces/Codeforces Round 916 (Div 3)/F.py b/Codeforces/Codeforces Round 916 (Div 3)/F.py
--- a/Codeforces/Codeforces Round 916 (Div 3)/F.py	(revision bc7ab91df3db33c143ee3ebd32c794cf710fdacb)
+++ b/Codeforces/Codeforces Round 916 (Div 3)/F.py	(date 1731887978685)
@@ -8,6 +8,7 @@
 from bisect import bisect_left, bisect_right
 from functools import lru_cache, reduce
 import operator
+from types import GeneratorType
 
 # Para mejorar el rendimiento de la entrada/salida
 input = lambda: sys.stdin.readline().strip()
@@ -44,6 +45,24 @@
 @lru_cache(maxsize=None)
 def factorial(n): return n * factorial(n - 1) if n else 1
 
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
 
 # Combinaciones con memoización (nCr)
 @lru_cache(maxsize=None)
@@ -62,14 +81,16 @@
 lvl = []
 AL = []
 padre = []
+
+@bootstrap
 def dfs(u, p):
     global lvl,AL, padre
     lvl[u] = p
     for v in AL[u]:
         if v != padre[u]:
             padre[v] = u
-            dfs(v, p + 1)
-
+            yield dfs(v, p + 1)
+    yield
 
 
 def solve(n , p ):
Index: Codeforces/Codeforces Round 988 (Div 3)/E.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Codeforces/Codeforces Round 988 (Div 3)/E.py b/Codeforces/Codeforces Round 988 (Div 3)/E.py
new file mode 100644
--- /dev/null	(date 1731974923649)
+++ b/Codeforces/Codeforces Round 988 (Div 3)/E.py	(date 1731974923649)
@@ -0,0 +1,179 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+
+#input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+
+# region fastio
+
+BUFSIZE = 8192
+
+
+class FastIO(IOBase):
+    newlines = 0
+
+    def __init__(self, file):
+        self._file = file
+        self._fd = file.fileno()
+        self.buffer = BytesIO()
+        self.writable = "x" in file.mode or "r" not in file.mode
+        self.write = self.buffer.write if self.writable else None
+
+    def read(self):
+        while True:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            if not b:
+                break
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines = 0
+        return self.buffer.read()
+
+    def readline(self):
+        while self.newlines == 0:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            self.newlines = b.count(b"\n") + (not b)
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines -= 1
+        return self.buffer.readline()
+
+    def flush(self):
+        if self.writable:
+            os.write(self._fd, self.buffer.getvalue())
+            self.buffer.truncate(0), self.buffer.seek(0)
+
+
+class IOWrapper(IOBase):
+    def __init__(self, file):
+        self.buffer = FastIO(file)
+        self.flush = self.buffer.flush
+        self.writable = self.buffer.writable
+        self.write = lambda s: self.buffer.write(s.encode("ascii"))
+        self.read = lambda: self.buffer.read().decode("ascii")
+        self.readline = lambda: self.buffer.readline().decode("ascii")
+
+
+#sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
+
+
+# endregion
+prefix = []
+suffix = []
+
+def main():
+    t = int(input())
+    for _ in range(t):
+        n = int(input())
+        s = ['X'] * n
+        print(f"! {solve(n, s)}")
+
+ans = ""
+N = 0
+W = []
+
+def dp(pid, remW, s, zero_left, ones_rigth):
+    global ans
+    if ans != "":
+        return  1
+    if remW < 0:
+        return 0
+    if pid == len(W) and remW != 0:
+        return 0
+    if len(s) == len(W) and remW == 0:
+        ans = s
+        return 1
+    ignore = dp(pid + 1, remW - (W[pid][1] + zero_left), s + "1", zero_left, ones_rigth + 1)
+    taken = dp(pid + 1, remW - (W[pid][0]), s + "0", zero_left + 1, ones_rigth )
+    if taken | ignore == 1:
+        return 1
+    return taken | ignore
+
+def solve(n ,s ):
+    global prefix, W
+    rest = 0
+    incongruent = True
+    ans = ""
+    for i in range(n-1):
+        print(f"? 1 {i + 2}")
+        x = int(input())
+        if x > rest:
+            rest = x
+            if incongruent:
+                ans = "1"*(i+1-x) + "0" * x + "1"
+                incongruent = False
+            else :
+                ans += "1"
+        else:
+            if not incongruent:
+                ans += "0"
+    if incongruent:
+        return "IMPOSSIBLE"
+
+    return ans
+
+if __name__ == "__main__":
+    main()
Index: Codeforces/Codeforces Round 988 (Div 3)/G.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Codeforces/Codeforces Round 988 (Div 3)/G.py b/Codeforces/Codeforces Round 988 (Div 3)/G.py
new file mode 100644
--- /dev/null	(date 1732070463630)
+++ b/Codeforces/Codeforces Round 988 (Div 3)/G.py	(date 1732070463630)
@@ -0,0 +1,153 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+
+input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+def ints(): return map(int, input().split())
+
+
+def strs(): return input().split()
+
+
+def chars(): return list(input().strip())
+
+
+def mat(n): return [list(ints()) for _ in range(n)]
+
+
+INF = float('inf')
+MOD = 998244353
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+
+def add(x, y, mod=MOD): return (x + y) % mod
+
+
+def sub(x, y, mod=MOD): return (x - y) % mod
+
+
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+
+RANDOM = getrandbits(32)
+
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+def gcd(x, y):
+    """greatest common divisor of x and y"""
+    while y:
+        x, y = y, x % y
+    return x
+
+
+def distinct_factors(n):
+    factors = [1]
+    while n > 1:
+        p = SPF[n]
+        for i in range(len(factors)):
+            factors.append(factors[i] * p)
+        while n % p == 0:
+            n //= p
+    return factors
+
+def all_factors(n):
+    """returns a sorted list of all distinct factors of n"""
+    small, large = [], []
+    for i in range(1, int(n**0.5) + 1, 2 if n & 1 else 1):
+        if not n % i:
+            small.append(i)
+            large.append(n // i)
+    if small[-1] == large[-1]:
+        large.pop()
+    large.reverse()
+    small.extend(large)
+    return small
+
+def mobius_f(n):
+    mobius = [0] * (n + 1)
+    mobius[1] = -1
+    for i in range(1, n + 1):
+        if mobius[i]:
+            mobius[i] = -mobius[i]
+            for j in range(2 * i, n + 1, i):
+                mobius[j] += mobius[i]
+    return mobius
+
+MAX_N = 1000000
+mu  = None
+
+SPF = [0] * (MAX_N + 1)
+for i in range(2, MAX_N + 1):
+    if SPF[i] == 0:
+        SPF[i] = i
+        for j in range(i * 2, MAX_N + 1, i):
+            if SPF[j] == 0:
+                SPF[j] = i
+def main():
+    global primes, mu
+    #sieve(MAX_N)
+
+    n = int(input())
+    a = list(ints())
+    mu = mobius_f(max(a) + 1)
+    print(solve(n, a))
+
+
+debug = False
+def solve(n, a):
+    dp = [0] * (MAX_N)
+
+    if debug:print(distinct_factors(a[-1]))
+    for it in (distinct_factors(a[-1])):
+        if it > 1:
+            dp[it] = 1
+    ans = 0
+    if debug:print(dp[:40])
+    for i in range(n - 2, -1, -1):
+        ans = 0
+        if debug:print(distinct_factors(a[i]))
+        for it in distinct_factors(a[i]):
+            if it > 1:
+                if debug:print(dp[it] * mu[it])
+                ans -= (dp[it] %  MOD * mu[it] % MOD) % MOD
+        for it in distinct_factors(a[i]):
+            if it > 1:
+                dp[it] += ans % MOD
+    if debug: print(mu[:40])
+    return ans % MOD
+
+
+if __name__ == "__main__":
+    main()
\ No newline at end of file
Index: Codeforces/Codeforces Round 986 (Div 2)/B.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Codeforces/Codeforces Round 986 (Div 2)/B.py b/Codeforces/Codeforces Round 986 (Div 2)/B.py
new file mode 100644
--- /dev/null	(date 1732138867690)
+++ b/Codeforces/Codeforces Round 986 (Div 2)/B.py	(date 1732138867690)
@@ -0,0 +1,83 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+
+input = lambda: sys.stdin.readline().strip()
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+
+def ints(): return map(int, input().split())
+
+
+def strs(): return input().split()
+
+
+def chars(): return list(input().strip())
+
+
+def mat(n): return [list(ints()) for _ in range(n)]
+
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+
+def add(x, y, mod=MOD): return (x + y) % mod
+
+
+def sub(x, y, mod=MOD): return (x - y) % mod
+
+
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+
+RANDOM = getrandbits(32)
+
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+def main():
+    t = int(input())
+    ans = []
+    for _ in range(t):
+        n, b, c = ints()
+        if b == 0:
+            ans.append(n if c >= n else n-1 if c >= n-2 else -1)
+        else:
+            right = max(0, (n - c - 1) // b + 1)
+            ans.append(n - right)
+    print("\n".join(map(str, ans)))
+
+
+
+
+if __name__ == "__main__":
+    main()
\ No newline at end of file
Index: Meta Hacker Cup 2024/Round 2/B/four_in_a_burrow_validation_input.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Meta Hacker Cup 2024/Round 2/B/four_in_a_burrow_validation_input.txt b/Meta Hacker Cup 2024/Round 2/B/four_in_a_burrow_validation_input.txt
new file mode 100644
--- /dev/null	(date 1738365574781)
+++ b/Meta Hacker Cup 2024/Round 2/B/four_in_a_burrow_validation_input.txt	(date 1738365574781)
@@ -0,0 +1,3 @@
+version https://git-lfs.github.com/spec/v1
+oid sha256:4f4d80d731925f4eaa856e23382643331000f14326c6aec5c22ee89f8fef6938
+size 394
Index: USACO GUIDE/GOLD/Euler Phi/CF - C. Product 1 Modulo N.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/USACO GUIDE/GOLD/Euler Phi/CF - C. Product 1 Modulo N.py b/USACO GUIDE/GOLD/Euler Phi/CF - C. Product 1 Modulo N.py
new file mode 100644
--- /dev/null	(date 1729393740745)
+++ b/USACO GUIDE/GOLD/Euler Phi/CF - C. Product 1 Modulo N.py	(date 1729393740745)
@@ -0,0 +1,77 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+
+input = lambda: sys.stdin.readline().strip()
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+def phi_1_to_n(n):
+    phi = [0] * (n+1)
+    for i in range(n+1):
+        phi[i] =  i
+    for i in range(2, n+1):
+        if phi[i] == i:
+            for j in range(i, n+1, i):
+                phi[j] -= phi[j] // i
+    return phi
+
+def main():
+    n = int(input())
+    coprimes = [i for i in range(1, n) if gcd(i, n) == 1]
+    ans = 1
+    total = 0
+    for i, coprime in enumerate(coprimes):
+        ans *= coprime
+        ans = ans % n
+        if ans == 1:
+            total = i
+    print(total+1)
+    print(*coprimes[:total+1])
+
+
+
+
+if __name__ == "__main__":
+    main()
Index: USACO GUIDE/GOLD/Euler Phi/10179 - Irreducable Basic Fractions.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/USACO GUIDE/GOLD/Euler Phi/10179 - Irreducable Basic Fractions.py b/USACO GUIDE/GOLD/Euler Phi/10179 - Irreducable Basic Fractions.py
new file mode 100644
--- /dev/null	(date 1729399881706)
+++ b/USACO GUIDE/GOLD/Euler Phi/10179 - Irreducable Basic Fractions.py	(date 1729399881706)
@@ -0,0 +1,207 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+
+input = lambda: sys.stdin.readline().strip()
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+_sieve_size = 0
+bs = []
+primes = []
+
+
+def sieve(upperbound):
+  global _sieve_size, bs, primes
+
+  _sieve_size = upperbound+1
+  bs = [True] * 10000010
+  bs[0] = bs[1] = False
+  for i in range(2, _sieve_size):
+    if bs[i]:
+      for j in range(i*i, _sieve_size, i):
+        bs[j] = False
+      primes.append(i)
+
+
+def isPrime(N):
+  global _sieve_size, primes
+  if N <= _sieve_size:
+    return bs[N]
+  for p in primes:
+    if p * p > N:
+      break
+    if N % p == 0:
+      return False
+  return True
+
+
+def primeFactors(N):
+  global primes
+
+  factors = []
+  for p in primes:
+    if p * p > N:
+      break
+    while N % p == 0:
+      N //= p
+      factors.append(p)
+  if N != 1:
+    factors.append(N)
+
+  return factors
+
+
+def numPF(N):
+  global primes
+
+  ans = 0
+  for p in primes:
+    if p * p > N:
+      break
+    while N % p == 0:
+      N //= p
+      ans += 1
+  if N != 1:
+    ans += 1
+
+  return ans
+
+
+def numDiffPF(N):
+  global primes
+
+  ans = 0
+  for p in primes:
+    if p * p > N:
+      break
+    if N % p == 0:
+      ans += 1
+    while N % p == 0:
+      N //= p
+  if N != 1:
+    ans += 1
+
+  return ans
+
+
+def sumPF(N):
+  global primes
+
+  ans = 0
+  for p in primes:
+    if p * p > N:
+      break
+    while N % p == 0:
+      N //= p
+      ans += p
+  if N != 1:
+    ans += N
+
+  return ans
+
+
+def numDiv(N):
+  global primes
+
+  ans = 1
+  for p in primes:
+    if p * p > N:
+      break
+    power = 0
+    while N % p == 0:
+      N //= p
+      power += 1
+    ans = ans * (power + 1)
+  if N != 1:
+    return 2 * ans
+  else:
+    return ans
+
+
+def sumDiv(N):
+  global primes
+
+  ans = 1
+  for p in primes:
+    if p * p > N:
+      break
+    multiplier = p
+    total = 1
+    while N % p == 0:
+      N //= p
+      total += multiplier
+      multiplier *= p
+    ans *= total
+  if N != 1:
+    ans *= N+1
+
+  return ans
+
+
+def EulerPhi(N):
+  global primes
+
+  ans = N
+  for p in primes:
+    if p * p > N:
+      break
+    if N % p == 0:
+      ans -= ans // p
+    while N % p == 0:
+      N //= p
+  if N != 1:
+    ans -= ans // N
+
+  return ans
+def main():
+    n = int(input())
+    sieve(10000000)
+    ans = []
+    while n!= 0:
+        ans.append(str(EulerPhi(n)))
+        n = int(input())
+    print('\n'.join(ans))
+
+
+if __name__ == "__main__":
+    main()
Index: Meta Hacker Cup 2024/Round 2/B/b_val.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Meta Hacker Cup 2024/Round 2/B/b_val.txt b/Meta Hacker Cup 2024/Round 2/B/b_val.txt
new file mode 100644
--- /dev/null	(date 1738365574780)
+++ b/Meta Hacker Cup 2024/Round 2/B/b_val.txt	(date 1738365574780)
@@ -0,0 +1,3 @@
+version https://git-lfs.github.com/spec/v1
+oid sha256:2a7e93d3296d7890f559e218c2d2d85fa5cb310ce2c707001ed263381b1b52d2
+size 87
Index: USACO GUIDE/GOLD/Modular Arithmetic/CSES - Exponentiation II.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/USACO GUIDE/GOLD/Modular Arithmetic/CSES - Exponentiation II.py b/USACO GUIDE/GOLD/Modular Arithmetic/CSES - Exponentiation II.py
new file mode 100644
--- /dev/null	(date 1728000888497)
+++ b/USACO GUIDE/GOLD/Modular Arithmetic/CSES - Exponentiation II.py	(date 1728000888497)
@@ -0,0 +1,59 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+
+input = lambda: sys.stdin.readline().strip()
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+def main():
+    t = int(input())
+    for _ in range(t):
+        a, b, c = ints()
+        p = pow(b,c,MOD-1)
+        print(pow(a, p, MOD))
+
+
+
+if __name__ == "__main__":
+    main()
Index: USACO GUIDE/BRONZE/Complete Search/SolverBovineGenomics.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import os\r\nimport sys\r\nfrom collections import *\r\nfrom heapq import *\r\nfrom math import gcd, floor, ceil, sqrt\r\nfrom copy import deepcopy\r\nfrom itertools import permutations, combinations, product\r\nfrom bisect import bisect_left, bisect_right\r\nfrom functools import lru_cache, reduce\r\nimport operator\r\nfrom random import getrandbits\r\n\r\n# Para mejorar el rendimiento de la entrada/salida\r\ninput = lambda: sys.stdin.readline().strip()\r\nflush = lambda: sys.stdout.flush()\r\nprint = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get(\"end\", \"\\n\")) and flush()\r\n\r\n# Optimización de la recursión para Python\r\nsys.setrecursionlimit(100000)\r\n\r\n\r\n# Funciones para lectura de múltiples tipos de datos\r\ndef ints(): return map(int, input().split())\r\ndef strs(): return input().split()\r\ndef chars(): return list(input().strip())\r\ndef mat(n): return [list(ints()) for _ in range(n)]  # Matriz de n x m donde m es el número de enteros en una línea\r\n\r\n\r\n# Constantes útiles\r\nINF = float('inf')\r\nMOD = 1000000007  # Modulo por defecto, cambiar si se necesita otro\r\nabcd = \"abcdefghijklmnopqrstuvwxyz\"\r\n\r\n# Algunas funciones útiles\r\ndef add(x, y, mod=MOD): return (x + y) % mod\r\ndef sub(x, y, mod=MOD): return (x - y) % mod\r\ndef mul(x, y, mod=MOD): return (x * y) % mod\r\n\r\n# Inverso multiplicativo de a modulo m (cuando m es primo)\r\ndef invmod(a, mod=MOD): return powmod(a, mod - 2, mod)\r\n\r\ndef lcm(a, b): return a * b // gcd(a, b)\r\n\r\nRANDOM = getrandbits(32)\r\n\r\nclass Wrapper(int):\r\n    def __init__(self, x):\r\n        int.__init__(x)\r\n    def __hash__(self):\r\n        return super(Wrapper, self).__hash__() ^ RANDOM\r\n\r\n\r\n\r\ndef main():\r\n    sys.stdin = open('cownomics.in', 'r')\r\n    sys.stdout = open('cownomics.out', 'w')\r\n    n, m = ints()\r\n    possibilities = []\r\n    for i in range(0, m):\r\n        for j in range(i+1, m):\r\n            for k in range(j+1, m):\r\n                possibilities.append((i,j,k))\r\n    #print(possibilities)\r\n    #print(len(possibilities))\r\n\r\n    spots = []\r\n    plain = []\r\n    for i in range(n):\r\n        spots.append(input())\r\n\r\n    for i in range(n):\r\n        plain.append(input())\r\n\r\n    ans =  0\r\n    for a, b, c in possibilities:\r\n        curr = {}\r\n        for it in spots:\r\n            curr[it[a] + it[b] + it[c]] = True\r\n\r\n        ans += all(it[a] + it[b] + it[c] not in curr for it in plain)\r\n        #print(a,b,c)\r\n    print(ans)\r\n\r\ndef solve(n ,a ):\r\n    pass\r\n\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    main()\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/USACO GUIDE/BRONZE/Complete Search/SolverBovineGenomics.py b/USACO GUIDE/BRONZE/Complete Search/SolverBovineGenomics.py
--- a/USACO GUIDE/BRONZE/Complete Search/SolverBovineGenomics.py	(revision bc7ab91df3db33c143ee3ebd32c794cf710fdacb)
+++ b/USACO GUIDE/BRONZE/Complete Search/SolverBovineGenomics.py	(date 1733957442733)
@@ -76,7 +76,6 @@
         curr = {}
         for it in spots:
             curr[it[a] + it[b] + it[c]] = True
-
         ans += all(it[a] + it[b] + it[c] not in curr for it in plain)
         #print(a,b,c)
     print(ans)
Index: USACO GUIDE/GOLD/Modular Arithmetic/CSES - Exponentiation.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/USACO GUIDE/GOLD/Modular Arithmetic/CSES - Exponentiation.py b/USACO GUIDE/GOLD/Modular Arithmetic/CSES - Exponentiation.py
new file mode 100644
--- /dev/null	(date 1727912085731)
+++ b/USACO GUIDE/GOLD/Modular Arithmetic/CSES - Exponentiation.py	(date 1727912085731)
@@ -0,0 +1,58 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+
+input = lambda: sys.stdin.readline().strip()
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+def main():
+    t = int(input())
+    for _ in range(t):
+        a, b = ints()
+        print(pow(a,b, MOD))
+
+
+
+if __name__ == "__main__":
+    main()
Index: Meta Hacker Cup 2024/Round 2/A2/A2.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Meta Hacker Cup 2024/Round 2/A2/A2.py b/Meta Hacker Cup 2024/Round 2/A2/A2.py
new file mode 100644
--- /dev/null	(date 1735232622445)
+++ b/Meta Hacker Cup 2024/Round 2/A2/A2.py	(date 1735232622445)
@@ -0,0 +1,73 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+
+input = lambda: sys.stdin.readline().strip()
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+def can(s):
+    if len(s) % 2 == 0: return False;
+    mid = (len(s) + 1) // 2
+    s1,s2 = s[:mid], s[mid-1:]
+    return all(s1[i+1] >= s1[i] for i in range(mid - 1)) and all(s2[i+1] <= s2[i] for i in range(mid - 1)) and s.count('0') == 0 and s.count(s[len(s) // 2]) == 1
+
+def main():
+    t = int(input())
+    #print(can('122748322'))
+    for _ in range(t):
+        a,b,m = ints()
+        count = 0
+        for n in range(max(1, a), b+1):
+            if can(str(n)) and n % m == 0:
+                print(n)
+                count += 1
+        print(f'Case #{_+1}: {count}')
+
+def solve(n ,a ):
+    pass
+
+
+
+if __name__ == "__main__":
+    main()
Index: Meta Hacker Cup 2024/Round 2/A2/cottontail_climb_part_2_validation_input.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Meta Hacker Cup 2024/Round 2/A2/cottontail_climb_part_2_validation_input.txt b/Meta Hacker Cup 2024/Round 2/A2/cottontail_climb_part_2_validation_input.txt
new file mode 100644
--- /dev/null	(date 1738365574780)
+++ b/Meta Hacker Cup 2024/Round 2/A2/cottontail_climb_part_2_validation_input.txt	(date 1738365574780)
@@ -0,0 +1,3 @@
+version https://git-lfs.github.com/spec/v1
+oid sha256:6a7af383d2ee4963e2299601e1d4dbfb6268f8e1003315233b066f7c2b81f4b6
+size 139
Index: USACO GUIDE/GOLD/DP/AC - A - Frog 1.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/USACO GUIDE/GOLD/DP/AC - A - Frog 1.py b/USACO GUIDE/GOLD/DP/AC - A - Frog 1.py
new file mode 100644
--- /dev/null	(date 1732662835492)
+++ b/USACO GUIDE/GOLD/DP/AC - A - Frog 1.py	(date 1732662835492)
@@ -0,0 +1,152 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+from types import GeneratorType
+
+#input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+
+# region fastio
+
+BUFSIZE = 8192
+
+
+class FastIO(IOBase):
+    newlines = 0
+
+    def __init__(self, file):
+        self._file = file
+        self._fd = file.fileno()
+        self.buffer = BytesIO()
+        self.writable = "x" in file.mode or "r" not in file.mode
+        self.write = self.buffer.write if self.writable else None
+
+    def read(self):
+        while True:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            if not b:
+                break
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines = 0
+        return self.buffer.read()
+
+    def readline(self):
+        while self.newlines == 0:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            self.newlines = b.count(b"\n") + (not b)
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines -= 1
+        return self.buffer.readline()
+
+    def flush(self):
+        if self.writable:
+            os.write(self._fd, self.buffer.getvalue())
+            self.buffer.truncate(0), self.buffer.seek(0)
+
+
+class IOWrapper(IOBase):
+    def __init__(self, file):
+        self.buffer = FastIO(file)
+        self.flush = self.buffer.flush
+        self.writable = self.buffer.writable
+        self.write = lambda s: self.buffer.write(s.encode("ascii"))
+        self.read = lambda: self.buffer.read().decode("ascii")
+        self.readline = lambda: self.buffer.readline().decode("ascii")
+
+
+#sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
+
+
+# endregion
+
+
+def main():
+    n = int(input())
+    a = list(ints())
+    print(solve(n, a))
+
+
+
+
+
+def solve(n ,a ):
+    @lru_cache(maxsize=None)
+    def dp(i):
+        if i == n - 1:
+            return 0
+        else:
+            ans = INF
+            if i + 2 < n:
+                ans = min(ans, abs(a[i] - a[i + 2]) + (dp(i + 2)))
+            if i + 1 < n:
+                ans = min(ans, abs(a[i] - a[i + 1]) + (dp(i + 1)))
+            return ans
+
+    return dp(0)
+
+if __name__ == "__main__":
+    main()
Index: USACO GUIDE/BRONZE/Complete Search/CowGymnastics.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import os\r\nimport sys\r\nfrom collections import *\r\nfrom heapq import *\r\nfrom math import gcd, floor, ceil, sqrt\r\nfrom copy import deepcopy\r\nfrom itertools import permutations, combinations, product\r\nfrom bisect import bisect_left, bisect_right\r\nfrom functools import lru_cache, reduce\r\nimport operator\r\nfrom random import getrandbits\r\n\r\n# Para mejorar el rendimiento de la entrada/salida\r\ninput = lambda: sys.stdin.readline().strip()\r\nflush = lambda: sys.stdout.flush()\r\nprint = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get(\"end\", \"\\n\")) and flush()\r\n\r\n# Optimización de la recursión para Python\r\nsys.setrecursionlimit(100000)\r\n\r\n\r\n# Funciones para lectura de múltiples tipos de datos\r\ndef ints(): return map(int, input().split())\r\ndef strs(): return input().split()\r\ndef chars(): return list(input().strip())\r\ndef mat(n): return [list(ints()) for _ in range(n)]  # Matriz de n x m donde m es el número de enteros en una línea\r\n\r\n\r\n# Constantes útiles\r\nINF = float('inf')\r\nMOD = 1000000007  # Modulo por defecto, cambiar si se necesita otro\r\nabcd = \"abcdefghijklmnopqrstuvwxyz\"\r\n\r\n# Algunas funciones útiles\r\ndef add(x, y, mod=MOD): return (x + y) % mod\r\ndef sub(x, y, mod=MOD): return (x - y) % mod\r\ndef mul(x, y, mod=MOD): return (x * y) % mod\r\n\r\n# Inverso multiplicativo de a modulo m (cuando m es primo)\r\ndef invmod(a, mod=MOD): return powmod(a, mod - 2, mod)\r\n\r\ndef lcm(a, b): return a * b // gcd(a, b)\r\n\r\nRANDOM = getrandbits(32)\r\n\r\nclass Wrapper(int):\r\n    def __init__(self, x):\r\n        int.__init__(x)\r\n    def __hash__(self):\r\n        return super(Wrapper, self).__hash__() ^ RANDOM\r\n\r\n\r\n\r\ndef main():\r\n    sys.stdin = open('gymnastics.in', 'r')\r\n    sys.stdout = open('gymnastics.out', 'w')\r\n    n, m = ints()\r\n    mapper = defaultdict(int)\r\n    for _ in range(n):\r\n        a = list(ints())\r\n        for i in range(m):\r\n            for j in range(i + 1, m):\r\n                mapper[(a[i], a[j])] += 1\r\n\r\n    print(list(mapper.values()).count(n))\r\n\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    main()\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/USACO GUIDE/BRONZE/Complete Search/CowGymnastics.py b/USACO GUIDE/BRONZE/Complete Search/CowGymnastics.py
--- a/USACO GUIDE/BRONZE/Complete Search/CowGymnastics.py	(revision bc7ab91df3db33c143ee3ebd32c794cf710fdacb)
+++ b/USACO GUIDE/BRONZE/Complete Search/CowGymnastics.py	(date 1733953550189)
@@ -61,7 +61,6 @@
         for i in range(m):
             for j in range(i + 1, m):
                 mapper[(a[i], a[j])] += 1
-
     print(list(mapper.values()).count(n))
 
 
Index: Meta Hacker Cup 2024/Round 2/A2/a_val.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Meta Hacker Cup 2024/Round 2/A2/a_val.txt b/Meta Hacker Cup 2024/Round 2/A2/a_val.txt
new file mode 100644
--- /dev/null	(date 1738365574780)
+++ b/Meta Hacker Cup 2024/Round 2/A2/a_val.txt	(date 1738365574780)
@@ -0,0 +1,3 @@
+version https://git-lfs.github.com/spec/v1
+oid sha256:1d579681c4d30b61a0318cac009e0d2c7cf3acbd2d693afd6a7fbc752bceba4d
+size 133
Index: Meta Hacker Cup 2024/Round 2/A/A.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Meta Hacker Cup 2024/Round 2/A/A.py b/Meta Hacker Cup 2024/Round 2/A/A.py
new file mode 100644
--- /dev/null	(date 1735232625069)
+++ b/Meta Hacker Cup 2024/Round 2/A/A.py	(date 1735232625069)
@@ -0,0 +1,70 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+
+input = lambda: sys.stdin.readline().strip()
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+def main():
+    peaks = [1, 2, 3, 4, 5, 6, 7, 8, 9, 121, 232, 343, 454, 565, 676, 787, 898, 12321, 23432, 34543, 45654, 56765,
+             67876, 78987, 1234321, 2345432, 3456543, 4567654, 5678765, 6789876, 123454321, 234565432, 345676543,
+             456787654, 567898765, 12345654321, 23456765432, 34567876543, 45678987654, 1234567654321, 2345678765432,
+             3456789876543, 123456787654321, 234567898765432, 12345678987654321]
+
+    t = int(input())
+    for _ in range(t):
+        a,b,m = ints()
+        count = 0
+        for n in peaks:
+            if a <= n <= b and n % m == 0:
+                count += 1
+        print(f'Case #{_+1}: {count}')
+
+def solve(n ,a ):
+    pass
+
+
+
+if __name__ == "__main__":
+    main()
Index: USACO GUIDE/GOLD/DP/CF - C. Mortal Kombat Tower.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/USACO GUIDE/GOLD/DP/CF - C. Mortal Kombat Tower.py b/USACO GUIDE/GOLD/DP/CF - C. Mortal Kombat Tower.py
new file mode 100644
--- /dev/null	(date 1732307861782)
+++ b/USACO GUIDE/GOLD/DP/CF - C. Mortal Kombat Tower.py	(date 1732307861782)
@@ -0,0 +1,154 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+
+#input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+#sys.setrecursionlimit(100000)
+
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+
+# region fastio
+
+BUFSIZE = 8192
+
+
+class FastIO(IOBase):
+    newlines = 0
+
+    def __init__(self, file):
+        self._file = file
+        self._fd = file.fileno()
+        self.buffer = BytesIO()
+        self.writable = "x" in file.mode or "r" not in file.mode
+        self.write = self.buffer.write if self.writable else None
+
+    def read(self):
+        while True:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            if not b:
+                break
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines = 0
+        return self.buffer.read()
+
+    def readline(self):
+        while self.newlines == 0:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            self.newlines = b.count(b"\n") + (not b)
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines -= 1
+        return self.buffer.readline()
+
+    def flush(self):
+        if self.writable:
+            os.write(self._fd, self.buffer.getvalue())
+            self.buffer.truncate(0), self.buffer.seek(0)
+
+
+class IOWrapper(IOBase):
+    def __init__(self, file):
+        self.buffer = FastIO(file)
+        self.flush = self.buffer.flush
+        self.writable = self.buffer.writable
+        self.write = lambda s: self.buffer.write(s.encode("ascii"))
+        self.read = lambda: self.buffer.read().decode("ascii")
+        self.readline = lambda: self.buffer.readline().decode("ascii")
+
+
+#sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
+
+
+# endregion
+
+
+def main():
+    t = int(input())
+    for _ in range(t):
+        n = int(input())
+        a = list(ints())
+        print(solve(n, a))
+
+
+def solve(n ,a ):
+    dp = [[INF, INF, INF] for j in range(n+1)]
+    dp[-1][-1] = 0
+    dp[-1][-2] = 0
+    dp[-1][-3] = 0
+    for i in range(n-1, -1, -1):
+        for friend in range(3):
+            if i + 2 < n +1 and friend == 2:
+                dp[i][friend] = min(dp[i][friend], dp[i + 2][friend - 2])
+            if i + 1 < n + 1 and friend == 1:
+                dp[i][friend] = min(dp[i][friend], dp[i + 1][friend - 1])
+                dp[i][friend] = min(dp[i][friend], a[i] + dp[i + 1][friend + 1])
+            if friend == 0:
+                dp[i][friend] = min(dp[i][friend], a[i] + dp[i + 1][friend + 1])
+                dp[i][friend] = min(dp[i][friend], a[i] + dp[i + 1][friend + 2])
+
+    return dp[0][0]
+
+
+if __name__ == "__main__":
+    main()
Index: USACO GUIDE/BRONZE/Complete Search with Recursion/AirCownditioningII.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import os\r\nimport sys\r\nfrom collections import *\r\nfrom heapq import *\r\nfrom math import gcd, floor, ceil, sqrt\r\nfrom copy import deepcopy\r\nfrom itertools import permutations, combinations, product\r\nfrom bisect import bisect_left, bisect_right\r\nfrom functools import lru_cache, reduce\r\nimport operator\r\nfrom random import getrandbits\r\n\r\n# Para mejorar el rendimiento de la entrada/salida\r\ninput = lambda: sys.stdin.readline().strip()\r\nflush = lambda: sys.stdout.flush()\r\nprint = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get(\"end\", \"\\n\")) and flush()\r\n\r\n# Optimización de la recursión para Python\r\nsys.setrecursionlimit(100000)\r\n\r\n\r\n# Funciones para lectura de múltiples tipos de datos\r\ndef ints(): return map(int, input().split())\r\ndef strs(): return input().split()\r\ndef chars(): return list(input().strip())\r\ndef mat(n): return [list(ints()) for _ in range(n)]  # Matriz de n x m donde m es el número de enteros en una línea\r\n\r\n\r\n# Constantes útiles\r\nINF = float('inf')\r\nMOD = 1000000007  # Modulo por defecto, cambiar si se necesita otro\r\nabcd = \"abcdefghijklmnopqrstuvwxyz\"\r\n\r\n# Algunas funciones útiles\r\ndef add(x, y, mod=MOD): return (x + y) % mod\r\ndef sub(x, y, mod=MOD): return (x - y) % mod\r\ndef mul(x, y, mod=MOD): return (x * y) % mod\r\n\r\n# Inverso multiplicativo de a modulo m (cuando m es primo)\r\ndef invmod(a, mod=MOD): return powmod(a, mod - 2, mod)\r\n\r\ndef lcm(a, b): return a * b // gcd(a, b)\r\n\r\nRANDOM = getrandbits(32)\r\n\r\nclass Wrapper(int):\r\n    def __init__(self, x):\r\n        int.__init__(x)\r\n    def __hash__(self):\r\n        return super(Wrapper, self).__hash__() ^ RANDOM\r\n\r\n\r\ndef can_be_covered(subset, barn, airs):\r\n    total_cost = 0\r\n    current = [0] * 100\r\n    ans = INF\r\n    for i in subset:\r\n        ai, bi, pi, mi = airs[i]\r\n        ai -= 1\r\n        bi -= 1\r\n        total_cost += mi\r\n        for j in range(ai, bi+1):\r\n            current[j] += pi\r\n    all_covered = True\r\n    for i in range(100):\r\n        if barn[i] == INF: continue\r\n        if current[i] < barn[i]:\r\n            all_covered = False\r\n            break\r\n    if all_covered:\r\n        ans = min(total_cost, ans)\r\n    return ans\r\ndef main():\r\n    n, m = ints()\r\n    barn = [INF] * 100\r\n    for i in range(n):\r\n        ai, bi, t = ints()\r\n        ai -= 1\r\n        bi -= 1\r\n        for j in range(ai, bi + 1):\r\n            if barn[j] == INF:\r\n                barn[j] = t\r\n            barn[j] = max(barn[j], t)\r\n    airs = []\r\n    ans = INF\r\n    for i in range(m):\r\n        ai, bi, pi, mi = ints()\r\n        airs.append((ai, bi, pi, mi))\r\n    for b in range(1<<m):\r\n        current = []\r\n        for i in range(m):\r\n            if b & (1 << i):\r\n                current.append(i)\r\n        if len(current) == 0: continue\r\n        ans = min(ans, can_be_covered(current, barn, airs))\r\n    print(ans)\r\n\r\n\r\ndef solve(n ,a ):\r\n    pass\r\n\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    main()\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/USACO GUIDE/BRONZE/Complete Search with Recursion/AirCownditioningII.py b/USACO GUIDE/BRONZE/Complete Search with Recursion/AirCownditioningII.py
--- a/USACO GUIDE/BRONZE/Complete Search with Recursion/AirCownditioningII.py	(revision bc7ab91df3db33c143ee3ebd32c794cf710fdacb)
+++ b/USACO GUIDE/BRONZE/Complete Search with Recursion/AirCownditioningII.py	(date 1734035207445)
@@ -81,6 +81,7 @@
             if barn[j] == INF:
                 barn[j] = t
             barn[j] = max(barn[j], t)
+    print(barn)
     airs = []
     ans = INF
     for i in range(m):
@@ -91,6 +92,7 @@
         for i in range(m):
             if b & (1 << i):
                 current.append(i)
+        print(current)
         if len(current) == 0: continue
         ans = min(ans, can_be_covered(current, barn, airs))
     print(ans)
Index: Meta Hacker Cup 2024/Round 2/A/cottontail_climb_part_1_validation_input.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Meta Hacker Cup 2024/Round 2/A/cottontail_climb_part_1_validation_input.txt b/Meta Hacker Cup 2024/Round 2/A/cottontail_climb_part_1_validation_input.txt
new file mode 100644
--- /dev/null	(date 1738365574779)
+++ b/Meta Hacker Cup 2024/Round 2/A/cottontail_climb_part_1_validation_input.txt	(date 1738365574779)
@@ -0,0 +1,3 @@
+version https://git-lfs.github.com/spec/v1
+oid sha256:6a7af383d2ee4963e2299601e1d4dbfb6268f8e1003315233b066f7c2b81f4b6
+size 139
Index: Codeforces/Contest 690(Div.3)/E2.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Codeforces/Contest 690(Div.3)/E2.py b/Codeforces/Contest 690(Div.3)/E2.py
new file mode 100644
--- /dev/null	(date 1732240769247)
+++ b/Codeforces/Contest 690(Div.3)/E2.py	(date 1732240769247)
@@ -0,0 +1,178 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+
+input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
+
+def ints(): return map(int, input().split())
+
+
+def strs(): return input().split()
+
+
+def chars(): return list(input().strip())
+
+
+def mat(n): return [list(ints()) for _ in range(n)]
+
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+
+def add(x, y, mod=MOD): return (x + y) % mod
+
+
+def sub(x, y, mod=MOD): return (x - y) % mod
+
+
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+
+RANDOM = getrandbits(32)
+
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+# region fastio
+
+BUFSIZE = 8192
+
+
+class FastIO(IOBase):
+    newlines = 0
+
+    def __init__(self, file):
+        self._file = file
+        self._fd = file.fileno()
+        self.buffer = BytesIO()
+        self.writable = "x" in file.mode or "r" not in file.mode
+        self.write = self.buffer.write if self.writable else None
+
+    def read(self):
+        while True:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            if not b:
+                break
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines = 0
+        return self.buffer.read()
+
+    def readline(self):
+        while self.newlines == 0:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            self.newlines = b.count(b"\n") + (not b)
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines -= 1
+        return self.buffer.readline()
+
+    def flush(self):
+        if self.writable:
+            os.write(self._fd, self.buffer.getvalue())
+            self.buffer.truncate(0), self.buffer.seek(0)
+
+
+class IOWrapper(IOBase):
+    def __init__(self, file):
+        self.buffer = FastIO(file)
+        self.flush = self.buffer.flush
+        self.writable = self.buffer.writable
+        self.write = lambda s: self.buffer.write(s.encode("ascii"))
+        self.read = lambda: self.buffer.read().decode("ascii")
+        self.readline = lambda: self.buffer.readline().decode("ascii")
+
+
+#sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
+
+
+# endregion
+MAX_N = (2 * 10**5 + 5)
+factors = [0] * MAX_N
+inversions = [0] * MAX_N
+inversions[0] = 1
+inversions[1] = 1
+factors[0] = 1
+factors[1] = 1
+for i in range(2, MAX_N):
+    factors[i] = i * factors[i-1] % MOD
+    inversions[i] = pow(factors[i], MOD-2, MOD)
+
+
+def nCr(n, r):
+    if r > n: return 0
+    if n == r: return 1
+    return (factors[n] * inversions[r] % MOD * inversions[n-r] % MOD) % MOD
+
+def main():
+    t = int(input())
+    for _ in range(t):
+        n ,m,k = ints()
+        a = list(ints())
+        print(solve(n,m,k, a))
+
+
+def solve(n,m,k, a):
+    a.sort()
+    ans = 0
+    for i in range(n):
+        n_ = bisect_right(a, a[i] + k) - (i + 1)
+        ans += nCr(n_, m-1)
+        ans %= MOD
+    return ans % MOD
+
+
+if __name__ == "__main__":
+    main()
Index: Codeforces/Contest 690(Div.3)/E1.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Codeforces/Contest 690(Div.3)/E1.py b/Codeforces/Contest 690(Div.3)/E1.py
new file mode 100644
--- /dev/null	(date 1732241840788)
+++ b/Codeforces/Contest 690(Div.3)/E1.py	(date 1732241840788)
@@ -0,0 +1,183 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+
+input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
+
+def ints(): return map(int, input().split())
+
+
+def strs(): return input().split()
+
+
+def chars(): return list(input().strip())
+
+
+def mat(n): return [list(ints()) for _ in range(n)]
+
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+
+def add(x, y, mod=MOD): return (x + y) % mod
+
+
+def sub(x, y, mod=MOD): return (x - y) % mod
+
+
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+
+RANDOM = getrandbits(32)
+
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+# region fastio
+
+BUFSIZE = 8192
+
+
+class FastIO(IOBase):
+    newlines = 0
+
+    def __init__(self, file):
+        self._file = file
+        self._fd = file.fileno()
+        self.buffer = BytesIO()
+        self.writable = "x" in file.mode or "r" not in file.mode
+        self.write = self.buffer.write if self.writable else None
+
+    def read(self):
+        while True:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            if not b:
+                break
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines = 0
+        return self.buffer.read()
+
+    def readline(self):
+        while self.newlines == 0:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            self.newlines = b.count(b"\n") + (not b)
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines -= 1
+        return self.buffer.readline()
+
+    def flush(self):
+        if self.writable:
+            os.write(self._fd, self.buffer.getvalue())
+            self.buffer.truncate(0), self.buffer.seek(0)
+
+
+class IOWrapper(IOBase):
+    def __init__(self, file):
+        self.buffer = FastIO(file)
+        self.flush = self.buffer.flush
+        self.writable = self.buffer.writable
+        self.write = lambda s: self.buffer.write(s.encode("ascii"))
+        self.read = lambda: self.buffer.read().decode("ascii")
+        self.readline = lambda: self.buffer.readline().decode("ascii")
+
+
+#sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
+
+
+# endregion
+MAX_N = (10)
+factors = [0] * MAX_N
+#inversions = [0] * MAX_N
+#inversions[0] = 1
+#inversions[1] = 1
+factors[0] = 1
+factors[1] = 1
+for i in range(2, MAX_N):
+    factors[i] = i * factors[i-1]
+ #   inversions[i] = pow(factors[i], MOD-2, MOD)
+
+
+def nCr(n, r):
+    if r > n: return 0
+    if n == r: return 1
+    return factors[n] // (factors[r] * factors[n-r])
+
+def nCr2(n):
+    return (n * (n - 1)) // 2 if n >= 2 else 0
+
+
+def main():
+    t = int(input())
+    for _ in range(t):
+        n = int(input())
+        a = list(ints())
+        print(solve(n, a))
+
+
+def solve(n, a):
+    a.sort()
+    ans = 0
+    k = 2
+    m = 3
+    for i in range(n):
+        n_ = bisect_right(a, a[i] + k) - (i + 1)
+        ans += nCr2(n_)
+    return ans
+
+
+if __name__ == "__main__":
+    main()
Index: Meta Hacker Cup 2024/Round 2/A/a_val.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Meta Hacker Cup 2024/Round 2/A/a_val.txt b/Meta Hacker Cup 2024/Round 2/A/a_val.txt
new file mode 100644
--- /dev/null	(date 1738365574779)
+++ b/Meta Hacker Cup 2024/Round 2/A/a_val.txt	(date 1738365574779)
@@ -0,0 +1,3 @@
+version https://git-lfs.github.com/spec/v1
+oid sha256:766cee03a01162e24b30946ad6f2e7b8dd786cbbf6d5093dc2deeace1f440de5
+size 123
Index: Codeforces/Codeforces Round 986 (Div 2)/C.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Codeforces/Codeforces Round 986 (Div 2)/C.py b/Codeforces/Codeforces Round 986 (Div 2)/C.py
new file mode 100644
--- /dev/null	(date 1732224804035)
+++ b/Codeforces/Codeforces Round 986 (Div 2)/C.py	(date 1732224804035)
@@ -0,0 +1,180 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+
+input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+
+# region fastio
+
+BUFSIZE = 8192
+
+
+class FastIO(IOBase):
+    newlines = 0
+
+    def __init__(self, file):
+        self._file = file
+        self._fd = file.fileno()
+        self.buffer = BytesIO()
+        self.writable = "x" in file.mode or "r" not in file.mode
+        self.write = self.buffer.write if self.writable else None
+
+    def read(self):
+        while True:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            if not b:
+                break
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines = 0
+        return self.buffer.read()
+
+    def readline(self):
+        while self.newlines == 0:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            self.newlines = b.count(b"\n") + (not b)
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines -= 1
+        return self.buffer.readline()
+
+    def flush(self):
+        if self.writable:
+            os.write(self._fd, self.buffer.getvalue())
+            self.buffer.truncate(0), self.buffer.seek(0)
+
+
+class IOWrapper(IOBase):
+    def __init__(self, file):
+        self.buffer = FastIO(file)
+        self.flush = self.buffer.flush
+        self.writable = self.buffer.writable
+        self.write = lambda s: self.buffer.write(s.encode("ascii"))
+        self.read = lambda: self.buffer.read().decode("ascii")
+        self.readline = lambda: self.buffer.readline().decode("ascii")
+
+
+sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
+
+
+# endregion
+
+def can(n,m,v, mid, a, prefix, mapper):
+    l, r = None, None
+    for i in range(1, n+1):
+        if prefix[i] - mid in mapper:
+            r = i
+            l = mapper[prefix[i] - mid]
+    if r is None and l is None:
+        return False
+    sum_ = 0
+    ans = 0
+    for i in range(n):
+        if i < l or i > r:
+            sum_ += a[i]
+            if sum_ >= v:
+                ans+=1
+                sum_ = 0
+        else:
+            sum_ = 0
+    return ans >= m
+def main():
+    t = int(input())
+    for _ in range(t):
+        n, m, v = ints()
+        a = list(ints())
+        prefix = [0] * (n+1)
+        cur = 0
+        for i,it in enumerate(a):
+            cur += it
+            prefix[i+1] = prefix[i]
+            if cur >= v:
+                prefix[i + 1] = prefix[i] + 1
+                cur = 0
+        ans = 0
+        prefix_sum = [0] + list(accumulate(a))
+        for i, it in enumerate(prefix):
+            if it == m:
+                ans = max(ans, prefix_sum[n] - prefix_sum[i])
+                break
+        suffix = [0] * (n+1)
+        cur = 0
+        for i,it in enumerate(reversed(a)):
+            cur += it
+            suffix[i+1] = suffix[i]
+            if cur >= v:
+                suffix[i + 1] = suffix[i] + 1
+                cur = 0
+        suffix.reverse()
+        mapper = {it: i for i, it in enumerate(suffix)}
+        for i in range(n+1):
+            x = m - prefix[i]
+            if x in mapper:
+                ans = max(ans, prefix_sum[mapper[x]] - prefix_sum[i])
+        print(ans if suffix[0] >= m else -1)
+
+if __name__ == "__main__":
+    main()
Index: Meta Hacker Cup 2024/Round 2/A/a_out.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Meta Hacker Cup 2024/Round 2/A/a_out.txt b/Meta Hacker Cup 2024/Round 2/A/a_out.txt
new file mode 100644
--- /dev/null	(date 1738365574779)
+++ b/Meta Hacker Cup 2024/Round 2/A/a_out.txt	(date 1738365574779)
@@ -0,0 +1,3 @@
+version https://git-lfs.github.com/spec/v1
+oid sha256:df8972922df5a95d8b347a10fbbbce78b49ce157aeacf41e74f90b8f7a05b994
+size 1195
Index: USACO GUIDE/GOLD/DP/CF - E. Increasing Frequency.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/USACO GUIDE/GOLD/DP/CF - E. Increasing Frequency.py b/USACO GUIDE/GOLD/DP/CF - E. Increasing Frequency.py
new file mode 100644
--- /dev/null	(date 1732327703867)
+++ b/USACO GUIDE/GOLD/DP/CF - E. Increasing Frequency.py	(date 1732327703867)
@@ -0,0 +1,145 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+from types import GeneratorType
+
+input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+
+# region fastio
+
+BUFSIZE = 8192
+
+
+class FastIO(IOBase):
+    newlines = 0
+
+    def __init__(self, file):
+        self._file = file
+        self._fd = file.fileno()
+        self.buffer = BytesIO()
+        self.writable = "x" in file.mode or "r" not in file.mode
+        self.write = self.buffer.write if self.writable else None
+
+    def read(self):
+        while True:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            if not b:
+                break
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines = 0
+        return self.buffer.read()
+
+    def readline(self):
+        while self.newlines == 0:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            self.newlines = b.count(b"\n") + (not b)
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines -= 1
+        return self.buffer.readline()
+
+    def flush(self):
+        if self.writable:
+            os.write(self._fd, self.buffer.getvalue())
+            self.buffer.truncate(0), self.buffer.seek(0)
+
+
+class IOWrapper(IOBase):
+    def __init__(self, file):
+        self.buffer = FastIO(file)
+        self.flush = self.buffer.flush
+        self.writable = self.buffer.writable
+        self.write = lambda s: self.buffer.write(s.encode("ascii"))
+        self.read = lambda: self.buffer.read().decode("ascii")
+        self.readline = lambda: self.buffer.readline().decode("ascii")
+
+
+sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
+
+
+# endregion
+
+
+def main():
+    n, c = ints()
+    a = list(ints())
+    b = [1 if it == c else 0 for it in a]
+    print(solve(n, a, b))
+
+
+def solve(n ,a, b ):
+    dp = [0] * (1000000)
+    pref = [0] + list(accumulate(b))
+    ans = 0
+    for i, it in enumerate(a):
+        dp[it] = max(dp[it] + 1, pref[i] + 1)
+        ans = max(ans, dp[it] + pref[n] - pref[i+1])
+    return ans
+
+
+if __name__ == "__main__":
+    main()
Index: Codeforces/Contest 690(Div.3)/B.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Codeforces/Contest 690(Div.3)/B.py b/Codeforces/Contest 690(Div.3)/B.py
new file mode 100644
--- /dev/null	(date 1732372382764)
+++ b/Codeforces/Contest 690(Div.3)/B.py	(date 1732372382764)
@@ -0,0 +1,148 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+from types import GeneratorType
+
+input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+
+# region fastio
+
+BUFSIZE = 8192
+
+
+class FastIO(IOBase):
+    newlines = 0
+
+    def __init__(self, file):
+        self._file = file
+        self._fd = file.fileno()
+        self.buffer = BytesIO()
+        self.writable = "x" in file.mode or "r" not in file.mode
+        self.write = self.buffer.write if self.writable else None
+
+    def read(self):
+        while True:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            if not b:
+                break
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines = 0
+        return self.buffer.read()
+
+    def readline(self):
+        while self.newlines == 0:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            self.newlines = b.count(b"\n") + (not b)
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines -= 1
+        return self.buffer.readline()
+
+    def flush(self):
+        if self.writable:
+            os.write(self._fd, self.buffer.getvalue())
+            self.buffer.truncate(0), self.buffer.seek(0)
+
+
+class IOWrapper(IOBase):
+    def __init__(self, file):
+        self.buffer = FastIO(file)
+        self.flush = self.buffer.flush
+        self.writable = self.buffer.writable
+        self.write = lambda s: self.buffer.write(s.encode("ascii"))
+        self.read = lambda: self.buffer.read().decode("ascii")
+        self.readline = lambda: self.buffer.readline().decode("ascii")
+
+
+sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
+
+
+# endregion
+
+
+def main():
+    t = int(input())
+    for _ in range(t):
+        n = int(input())
+        s = input()
+        print(solve(n, s))
+
+
+def solve(n ,a ):
+    found = False
+    index = 0
+    found = a[:1] == '2' and "020" in a[-3:]
+    found |= a[:2] == '20' and "20" in a[-2:]
+    found |= a[:3] == '202' and "0" in a[-1:]
+    found |= a[:4] == '2020' or "2020" in a[-4:]
+    #print(a[-4:], a[-3:], a[-2:], a[-1:])
+    return "YES" if found else "NO"
+
+
+
+if __name__ == "__main__":
+    main()
Index: Meta Hacker Cup 2024/Round 2/A/cottontail_climb_part_1_input/cottontail_climb_part_1_input.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Meta Hacker Cup 2024/Round 2/A/cottontail_climb_part_1_input/cottontail_climb_part_1_input.txt b/Meta Hacker Cup 2024/Round 2/A/cottontail_climb_part_1_input/cottontail_climb_part_1_input.txt
new file mode 100644
--- /dev/null	(date 1738365574779)
+++ b/Meta Hacker Cup 2024/Round 2/A/cottontail_climb_part_1_input/cottontail_climb_part_1_input.txt	(date 1738365574779)
@@ -0,0 +1,3 @@
+version https://git-lfs.github.com/spec/v1
+oid sha256:473df4ec5532336048094b553c4ed964853e780889023d2bb60e99e58e579e9f
+size 1433
Index: Codeforces/CodeTON Round 9 (Div 1 + Div 2, Rated, Prizes!)/A.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Codeforces/CodeTON Round 9 (Div 1 + Div 2, Rated, Prizes!)/A.py b/Codeforces/CodeTON Round 9 (Div 1 + Div 2, Rated, Prizes!)/A.py
new file mode 100644
--- /dev/null	(date 1732372652649)
+++ b/Codeforces/CodeTON Round 9 (Div 1 + Div 2, Rated, Prizes!)/A.py	(date 1732372652649)
@@ -0,0 +1,138 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+from types import GeneratorType
+
+input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+
+# region fastio
+
+BUFSIZE = 8192
+
+
+class FastIO(IOBase):
+    newlines = 0
+
+    def __init__(self, file):
+        self._file = file
+        self._fd = file.fileno()
+        self.buffer = BytesIO()
+        self.writable = "x" in file.mode or "r" not in file.mode
+        self.write = self.buffer.write if self.writable else None
+
+    def read(self):
+        while True:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            if not b:
+                break
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines = 0
+        return self.buffer.read()
+
+    def readline(self):
+        while self.newlines == 0:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            self.newlines = b.count(b"\n") + (not b)
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines -= 1
+        return self.buffer.readline()
+
+    def flush(self):
+        if self.writable:
+            os.write(self._fd, self.buffer.getvalue())
+            self.buffer.truncate(0), self.buffer.seek(0)
+
+
+class IOWrapper(IOBase):
+    def __init__(self, file):
+        self.buffer = FastIO(file)
+        self.flush = self.buffer.flush
+        self.writable = self.buffer.writable
+        self.write = lambda s: self.buffer.write(s.encode("ascii"))
+        self.read = lambda: self.buffer.read().decode("ascii")
+        self.readline = lambda: self.buffer.readline().decode("ascii")
+
+
+sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
+
+
+# endregion
+
+
+def main():
+    t = int(input())
+    for _ in range(t):
+        n = int(input())
+        print(*solve(n))
+
+
+def solve(n):
+    return [2*i - 1 for i in range(1, n+1)]
+
+if __name__ == "__main__":
+    main()
Index: Meta Hacker Cup 2024/Round 1/C/C.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Meta Hacker Cup 2024/Round 1/C/C.py b/Meta Hacker Cup 2024/Round 1/C/C.py
new file mode 100644
--- /dev/null	(date 1735232627575)
+++ b/Meta Hacker Cup 2024/Round 1/C/C.py	(date 1735232627575)
@@ -0,0 +1,72 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+
+input = lambda: sys.stdin.readline().strip()
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 998244353
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+def main():
+    t = int(input())
+    for _ in range(t):
+        w,g,l = ints()
+        ans = (w - g) * (2 * l + 1)
+        ans %= MOD
+        print(f"Case #{_+1}: {ans}")
+
+def solve(n ,k, a ):
+    ans = 0
+    a.sort()
+    for i in range(1, n):
+        if i == n-1:
+            ans+=a[0]
+        else:
+            ans += a[0]*2
+
+    ans += a[0] if n == 1 else 0
+    return "YES" if ans <= k else "NO"
+
+
+
+if __name__ == "__main__":
+    main()
Index: temp.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/temp.py b/temp.py
new file mode 100644
--- /dev/null	(date 1732379211814)
+++ b/temp.py	(date 1732379211814)
@@ -0,0 +1,2 @@
+for i in range(1, 30001):
+    print(i, end= " ")
\ No newline at end of file
Index: Codeforces/Random/1374A.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Codeforces/Random/1374A.py b/Codeforces/Random/1374A.py
new file mode 100644
--- /dev/null	(date 1738365560057)
+++ b/Codeforces/Random/1374A.py	(date 1738365560057)
@@ -0,0 +1,144 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+from types import GeneratorType
+
+input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+
+# region fastio
+
+BUFSIZE = 8192
+
+
+class FastIO(IOBase):
+    newlines = 0
+
+    def __init__(self, file):
+        self._file = file
+        self._fd = file.fileno()
+        self.buffer = BytesIO()
+        self.writable = "x" in file.mode or "r" not in file.mode
+        self.write = self.buffer.write if self.writable else None
+
+    def read(self):
+        while True:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            if not b:
+                break
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines = 0
+        return self.buffer.read()
+
+    def readline(self):
+        while self.newlines == 0:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            self.newlines = b.count(b"\n") + (not b)
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines -= 1
+        return self.buffer.readline()
+
+    def flush(self):
+        if self.writable:
+            os.write(self._fd, self.buffer.getvalue())
+            self.buffer.truncate(0), self.buffer.seek(0)
+
+
+class IOWrapper(IOBase):
+    def __init__(self, file):
+        self.buffer = FastIO(file)
+        self.flush = self.buffer.flush
+        self.writable = self.buffer.writable
+        self.write = lambda s: self.buffer.write(s.encode("ascii"))
+        self.read = lambda: self.buffer.read().decode("ascii")
+        self.readline = lambda: self.buffer.readline().decode("ascii")
+
+
+sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
+
+
+# endregion
+
+
+def main():
+    t = int(input())
+    for _ in range(t):
+        x, y , n = ints()
+        print(solve(x, y , n))
+
+
+def solve(x, y , n):
+    res = n % x
+    if res < y:
+        n += (y - res)
+        n -= x
+    if res > y:
+        n -=  (res - y)
+    return n
+
+if __name__ == "__main__":
+    main()
Index: Codeforces/CodeTON Round 9 (Div 1 + Div 2, Rated, Prizes!)/C2.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Codeforces/CodeTON Round 9 (Div 1 + Div 2, Rated, Prizes!)/C2.py b/Codeforces/CodeTON Round 9 (Div 1 + Div 2, Rated, Prizes!)/C2.py
new file mode 100644
--- /dev/null	(date 1738365560050)
+++ b/Codeforces/CodeTON Round 9 (Div 1 + Div 2, Rated, Prizes!)/C2.py	(date 1738365560050)
@@ -0,0 +1,159 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+from types import GeneratorType
+
+input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+
+# region fastio
+
+BUFSIZE = 8192
+
+
+class FastIO(IOBase):
+    newlines = 0
+
+    def __init__(self, file):
+        self._file = file
+        self._fd = file.fileno()
+        self.buffer = BytesIO()
+        self.writable = "x" in file.mode or "r" not in file.mode
+        self.write = self.buffer.write if self.writable else None
+
+    def read(self):
+        while True:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            if not b:
+                break
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines = 0
+        return self.buffer.read()
+
+    def readline(self):
+        while self.newlines == 0:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            self.newlines = b.ans(b"\n") + (not b)
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines -= 1
+        return self.buffer.readline()
+
+    def flush(self):
+        if self.writable:
+            os.write(self._fd, self.buffer.getvalue())
+            self.buffer.truncate(0), self.buffer.seek(0)
+
+
+class IOWrapper(IOBase):
+    def __init__(self, file):
+        self.buffer = FastIO(file)
+        self.flush = self.buffer.flush
+        self.writable = self.buffer.writable
+        self.write = lambda s: self.buffer.write(s.encode("ascii"))
+        self.read = lambda: self.buffer.read().decode("ascii")
+        self.readline = lambda: self.buffer.readline().decode("ascii")
+
+
+#sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
+
+
+# endregion
+
+
+def all_factors(n):
+    """Pyrival: returns a sorted list of all distinct factors of n"""
+    small, large = [], []
+    for i in range(1, int(n**0.5) + 1, 2 if n & 1 else 1):
+        if not n % i:
+            small.append(i)
+            large.append(n // i)
+    if small[-1] == large[-1]:
+        large.pop()
+    large.reverse()
+    small.extend(large)
+    return small
+
+def main():
+    t = int(input())
+    res = []
+    for _ in range(t):
+        x, m = ints()
+        res.append(solve(x, m))
+    print("\n".join(map(str, res)))
+
+
+debug = False
+def solve(x, m):
+    p = m - m % x
+    ans = p / x - (x < p)
+    ans += (1 <= (x ^ p) <= m) + (1 <= (x ^ (p + x)) <= m)
+    ans += sum(1 for y in range(1, min(x, m) + 1) if (x ^ y) % y == 0)
+    ans -= x <= m
+    return int(ans)
+
+if __name__ == "__main__":
+    main()
\ No newline at end of file
Index: Codeforces/Random/A1372.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Codeforces/Random/A1372.py b/Codeforces/Random/A1372.py
new file mode 100644
--- /dev/null	(date 1738365560061)
+++ b/Codeforces/Random/A1372.py	(date 1738365560061)
@@ -0,0 +1,138 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+from types import GeneratorType
+
+input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+
+# region fastio
+
+BUFSIZE = 8192
+
+
+class FastIO(IOBase):
+    newlines = 0
+
+    def __init__(self, file):
+        self._file = file
+        self._fd = file.fileno()
+        self.buffer = BytesIO()
+        self.writable = "x" in file.mode or "r" not in file.mode
+        self.write = self.buffer.write if self.writable else None
+
+    def read(self):
+        while True:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            if not b:
+                break
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines = 0
+        return self.buffer.read()
+
+    def readline(self):
+        while self.newlines == 0:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            self.newlines = b.count(b"\n") + (not b)
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines -= 1
+        return self.buffer.readline()
+
+    def flush(self):
+        if self.writable:
+            os.write(self._fd, self.buffer.getvalue())
+            self.buffer.truncate(0), self.buffer.seek(0)
+
+
+class IOWrapper(IOBase):
+    def __init__(self, file):
+        self.buffer = FastIO(file)
+        self.flush = self.buffer.flush
+        self.writable = self.buffer.writable
+        self.write = lambda s: self.buffer.write(s.encode("ascii"))
+        self.read = lambda: self.buffer.read().decode("ascii")
+        self.readline = lambda: self.buffer.readline().decode("ascii")
+
+
+sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
+
+
+# endregion
+
+
+def main():
+    t = int(input())
+    for _ in range(t):
+        n = int(input())
+        print(solve(n))
+
+
+def solve(n):
+    return " ".join(map(str, [1 for i in range(n)]))
+
+if __name__ == "__main__":
+    main()
Index: Codeforces/Random/633A.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Codeforces/Random/633A.py b/Codeforces/Random/633A.py
new file mode 100644
--- /dev/null	(date 1738365560060)
+++ b/Codeforces/Random/633A.py	(date 1738365560060)
@@ -0,0 +1,144 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+from types import GeneratorType
+
+input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+
+# region fastio
+
+BUFSIZE = 8192
+
+
+class FastIO(IOBase):
+    newlines = 0
+
+    def __init__(self, file):
+        self._file = file
+        self._fd = file.fileno()
+        self.buffer = BytesIO()
+        self.writable = "x" in file.mode or "r" not in file.mode
+        self.write = self.buffer.write if self.writable else None
+
+    def read(self):
+        while True:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            if not b:
+                break
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines = 0
+        return self.buffer.read()
+
+    def readline(self):
+        while self.newlines == 0:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            self.newlines = b.count(b"\n") + (not b)
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines -= 1
+        return self.buffer.readline()
+
+    def flush(self):
+        if self.writable:
+            os.write(self._fd, self.buffer.getvalue())
+            self.buffer.truncate(0), self.buffer.seek(0)
+
+
+class IOWrapper(IOBase):
+    def __init__(self, file):
+        self.buffer = FastIO(file)
+        self.flush = self.buffer.flush
+        self.writable = self.buffer.writable
+        self.write = lambda s: self.buffer.write(s.encode("ascii"))
+        self.read = lambda: self.buffer.read().decode("ascii")
+        self.readline = lambda: self.buffer.readline().decode("ascii")
+
+
+sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
+
+
+# endregion
+
+
+def main():
+    a, b, c = ints()
+    print(solve(a, b, c))
+
+
+
+def solve(a, b, c):
+    dp = [INF] * (c + 1)
+    dp[0] = 0
+    for remW in range(c + 1):
+        if remW - a >= 0:
+            dp[remW] = min(dp[remW], dp[remW - a])
+        if remW - b >= 0:
+            dp[remW] = min(dp[remW], dp[remW - b])
+    return "Yes" if dp[c] == 0 else "No"
+
+if __name__ == "__main__":
+    main()
Index: USACO GUIDE/GOLD/Combinatory/CF - D. Sum of XOR Functions.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/USACO GUIDE/GOLD/Combinatory/CF - D. Sum of XOR Functions.py b/USACO GUIDE/GOLD/Combinatory/CF - D. Sum of XOR Functions.py
new file mode 100644
--- /dev/null	(date 1731550714025)
+++ b/USACO GUIDE/GOLD/Combinatory/CF - D. Sum of XOR Functions.py	(date 1731550714025)
@@ -0,0 +1,73 @@
+# Contribution Technique
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+
+input = lambda: sys.stdin.readline().strip()
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 998244353
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+def main():
+    n = int(input())
+    a = list(ints())
+    s = [0] * (n+1)
+    for i in range(n):
+        s[i+1] = s[i] ^ a[i]
+    ans = 0
+    s1 = [[0, 0] for i in range(30)]
+    s2 = [[0, 0] for i in range(30)]
+
+    #print(s1, s2)
+
+    for i in range(n+1):
+        for j in range(30):
+            x = s[i] >> j & 1
+            ans += (i * s1[j][not x] - s2[j][not x]) * (1 << j)
+            #print(ans)
+            s1[j][x] +=1
+            s2[j][x] += i
+            # print(s1, s2)
+    print(ans % MOD)
+
+if __name__ == "__main__":
+    main()
Index: USACO GUIDE/GOLD/Combinatory/CF - E. Two Arrays and Sum of Functions.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/USACO GUIDE/GOLD/Combinatory/CF - E. Two Arrays and Sum of Functions.py b/USACO GUIDE/GOLD/Combinatory/CF - E. Two Arrays and Sum of Functions.py
new file mode 100644
--- /dev/null	(date 1731548844971)
+++ b/USACO GUIDE/GOLD/Combinatory/CF - E. Two Arrays and Sum of Functions.py	(date 1731548844971)
@@ -0,0 +1,72 @@
+# Contribution Technique
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+
+input = lambda: sys.stdin.readline().strip()
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 998244353
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+def main():
+    n = int(input())
+    a = list(ints())
+    b = list(ints())
+    a_ans = []
+    for i in range(n):
+        a_ans.append(((a[i] * ((n-i) * (i +1))), i))
+    a_ans.sort()
+    b.sort(reverse=True)
+    b_ans = [0] * n
+
+    for i in range(n):
+        #print(a_ans[i][1])
+        b_ans[a_ans[i][1]] = b[i]
+    #print(a, b_ans)
+    ans = 0
+    for i in range(n):
+        ans += a[i] * b_ans[i] * ((n-i) * (i +1))
+        #print(a[i], b_ans[i])
+    print(ans % MOD)
+
+if __name__ == "__main__":
+    main()
Index: USACO GUIDE/GOLD/Combinatory/CF - D. Almost Identity Permutations.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/USACO GUIDE/GOLD/Combinatory/CF - D. Almost Identity Permutations.py b/USACO GUIDE/GOLD/Combinatory/CF - D. Almost Identity Permutations.py
new file mode 100644
--- /dev/null	(date 1731377735807)
+++ b/USACO GUIDE/GOLD/Combinatory/CF - D. Almost Identity Permutations.py	(date 1731377735807)
@@ -0,0 +1,80 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+
+input = lambda: sys.stdin.readline().strip()
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+factorial = []
+def factorials(n):
+    global factorial
+    factorial[0] = 0
+    factorial[1] = 1
+    for i in range(2, n+1):
+        factorial[i] = i * factorial[i-1]
+
+def nCr(n, k):
+    if n == k: return 1
+    return factorial[n] // (factorial[k] * (factorial[n-k]))
+def main():
+    global factorial
+    n, k = ints()
+    factorial = [0] * (n+1)
+    ans = 0
+    factorials(n)
+    #print(factorial)
+    for i in range(1, k+1):
+        ans += nCr(n, i) * solve(i)
+    print(ans + 1)
+
+
+@lru_cache(maxsize=None)
+def solve(n):
+    if n == 1: return 0
+    if n == 2: return 1
+    return (n-1) * (solve(n-1) + solve(n-2))
+
+
+
+if __name__ == "__main__":
+    main()
Index: Codeforces/Random/1537A.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Codeforces/Random/1537A.py b/Codeforces/Random/1537A.py
new file mode 100644
--- /dev/null	(date 1738365560058)
+++ b/Codeforces/Random/1537A.py	(date 1738365560058)
@@ -0,0 +1,144 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+from types import GeneratorType
+
+input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+
+# region fastio
+
+BUFSIZE = 8192
+
+
+class FastIO(IOBase):
+    newlines = 0
+
+    def __init__(self, file):
+        self._file = file
+        self._fd = file.fileno()
+        self.buffer = BytesIO()
+        self.writable = "x" in file.mode or "r" not in file.mode
+        self.write = self.buffer.write if self.writable else None
+
+    def read(self):
+        while True:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            if not b:
+                break
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines = 0
+        return self.buffer.read()
+
+    def readline(self):
+        while self.newlines == 0:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            self.newlines = b.count(b"\n") + (not b)
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines -= 1
+        return self.buffer.readline()
+
+    def flush(self):
+        if self.writable:
+            os.write(self._fd, self.buffer.getvalue())
+            self.buffer.truncate(0), self.buffer.seek(0)
+
+
+class IOWrapper(IOBase):
+    def __init__(self, file):
+        self.buffer = FastIO(file)
+        self.flush = self.buffer.flush
+        self.writable = self.buffer.writable
+        self.write = lambda s: self.buffer.write(s.encode("ascii"))
+        self.read = lambda: self.buffer.read().decode("ascii")
+        self.readline = lambda: self.buffer.readline().decode("ascii")
+
+
+sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
+
+
+# endregion
+
+
+def main():
+    t = int(input())
+    for _ in range(t):
+        n = int(input())
+        a = list(ints())
+        print(solve(n, a))
+
+
+def solve(n, a):
+    if sum(a) < 0:
+        return 1
+    if sum(a) - n >= 0:
+        return sum(a) - n
+    else:
+        return 1
+
+if __name__ == "__main__":
+    main()
Index: Codeforces/Random/1656A.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Codeforces/Random/1656A.py b/Codeforces/Random/1656A.py
new file mode 100644
--- /dev/null	(date 1738365560059)
+++ b/Codeforces/Random/1656A.py	(date 1738365560059)
@@ -0,0 +1,139 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+from types import GeneratorType
+
+input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+
+# region fastio
+
+BUFSIZE = 8192
+
+
+class FastIO(IOBase):
+    newlines = 0
+
+    def __init__(self, file):
+        self._file = file
+        self._fd = file.fileno()
+        self.buffer = BytesIO()
+        self.writable = "x" in file.mode or "r" not in file.mode
+        self.write = self.buffer.write if self.writable else None
+
+    def read(self):
+        while True:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            if not b:
+                break
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines = 0
+        return self.buffer.read()
+
+    def readline(self):
+        while self.newlines == 0:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            self.newlines = b.count(b"\n") + (not b)
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines -= 1
+        return self.buffer.readline()
+
+    def flush(self):
+        if self.writable:
+            os.write(self._fd, self.buffer.getvalue())
+            self.buffer.truncate(0), self.buffer.seek(0)
+
+
+class IOWrapper(IOBase):
+    def __init__(self, file):
+        self.buffer = FastIO(file)
+        self.flush = self.buffer.flush
+        self.writable = self.buffer.writable
+        self.write = lambda s: self.buffer.write(s.encode("ascii"))
+        self.read = lambda: self.buffer.read().decode("ascii")
+        self.readline = lambda: self.buffer.readline().decode("ascii")
+
+
+sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
+
+
+# endregion
+
+
+def main():
+    t = int(input())
+    for _ in range(t):
+        n = int(input())
+        a = list(ints())
+        print(*solve(n, a))
+
+
+def solve(n, a):
+    return a.index(min(a)) + 1, a.index(max(a)) + 1
+
+if __name__ == "__main__":
+    main()
Index: USACO GUIDE/GOLD/Combinatory/CF - E1. Close Tuples (hard version).py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/USACO GUIDE/GOLD/Combinatory/CF - E1. Close Tuples (hard version).py b/USACO GUIDE/GOLD/Combinatory/CF - E1. Close Tuples (hard version).py
new file mode 100644
--- /dev/null	(date 1732240769247)
+++ b/USACO GUIDE/GOLD/Combinatory/CF - E1. Close Tuples (hard version).py	(date 1732240769247)
@@ -0,0 +1,178 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+
+input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
+
+def ints(): return map(int, input().split())
+
+
+def strs(): return input().split()
+
+
+def chars(): return list(input().strip())
+
+
+def mat(n): return [list(ints()) for _ in range(n)]
+
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+
+def add(x, y, mod=MOD): return (x + y) % mod
+
+
+def sub(x, y, mod=MOD): return (x - y) % mod
+
+
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+
+RANDOM = getrandbits(32)
+
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+# region fastio
+
+BUFSIZE = 8192
+
+
+class FastIO(IOBase):
+    newlines = 0
+
+    def __init__(self, file):
+        self._file = file
+        self._fd = file.fileno()
+        self.buffer = BytesIO()
+        self.writable = "x" in file.mode or "r" not in file.mode
+        self.write = self.buffer.write if self.writable else None
+
+    def read(self):
+        while True:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            if not b:
+                break
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines = 0
+        return self.buffer.read()
+
+    def readline(self):
+        while self.newlines == 0:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            self.newlines = b.count(b"\n") + (not b)
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines -= 1
+        return self.buffer.readline()
+
+    def flush(self):
+        if self.writable:
+            os.write(self._fd, self.buffer.getvalue())
+            self.buffer.truncate(0), self.buffer.seek(0)
+
+
+class IOWrapper(IOBase):
+    def __init__(self, file):
+        self.buffer = FastIO(file)
+        self.flush = self.buffer.flush
+        self.writable = self.buffer.writable
+        self.write = lambda s: self.buffer.write(s.encode("ascii"))
+        self.read = lambda: self.buffer.read().decode("ascii")
+        self.readline = lambda: self.buffer.readline().decode("ascii")
+
+
+#sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
+
+
+# endregion
+MAX_N = (2 * 10**5 + 5)
+factors = [0] * MAX_N
+inversions = [0] * MAX_N
+inversions[0] = 1
+inversions[1] = 1
+factors[0] = 1
+factors[1] = 1
+for i in range(2, MAX_N):
+    factors[i] = i * factors[i-1] % MOD
+    inversions[i] = pow(factors[i], MOD-2, MOD)
+
+
+def nCr(n, r):
+    if r > n: return 0
+    if n == r: return 1
+    return (factors[n] * inversions[r] % MOD * inversions[n-r] % MOD) % MOD
+
+def main():
+    t = int(input())
+    for _ in range(t):
+        n ,m,k = ints()
+        a = list(ints())
+        print(solve(n,m,k, a))
+
+
+def solve(n,m,k, a):
+    a.sort()
+    ans = 0
+    for i in range(n):
+        n_ = bisect_right(a, a[i] + k) - (i + 1)
+        ans += nCr(n_, m-1)
+        ans %= MOD
+    return ans % MOD
+
+
+if __name__ == "__main__":
+    main()
Index: Codeforces/Random/1774A.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Codeforces/Random/1774A.py b/Codeforces/Random/1774A.py
new file mode 100644
--- /dev/null	(date 1738365560059)
+++ b/Codeforces/Random/1774A.py	(date 1738365560059)
@@ -0,0 +1,148 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+from types import GeneratorType
+
+input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+
+# region fastio
+
+BUFSIZE = 8192
+
+
+class FastIO(IOBase):
+    newlines = 0
+
+    def __init__(self, file):
+        self._file = file
+        self._fd = file.fileno()
+        self.buffer = BytesIO()
+        self.writable = "x" in file.mode or "r" not in file.mode
+        self.write = self.buffer.write if self.writable else None
+
+    def read(self):
+        while True:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            if not b:
+                break
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines = 0
+        return self.buffer.read()
+
+    def readline(self):
+        while self.newlines == 0:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            self.newlines = b.count(b"\n") + (not b)
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines -= 1
+        return self.buffer.readline()
+
+    def flush(self):
+        if self.writable:
+            os.write(self._fd, self.buffer.getvalue())
+            self.buffer.truncate(0), self.buffer.seek(0)
+
+
+class IOWrapper(IOBase):
+    def __init__(self, file):
+        self.buffer = FastIO(file)
+        self.flush = self.buffer.flush
+        self.writable = self.buffer.writable
+        self.write = lambda s: self.buffer.write(s.encode("ascii"))
+        self.read = lambda: self.buffer.read().decode("ascii")
+        self.readline = lambda: self.buffer.readline().decode("ascii")
+
+
+#sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
+
+
+# endregion
+
+
+def main():
+    t = int(input())
+    for _ in range(t):
+        n = int(input())
+        s = input()
+        print(solve(n, s))
+
+
+def solve(n, s):
+    new_s = ""
+    ans = int(s[0])
+    for i in range(1, n):
+        if ans - int(s[i]) >= 0:
+            ans -= int(s[i])
+            new_s += "-"
+        else:
+            ans += int(s[i])
+            new_s += "+"
+    return new_s
+
+if __name__ == "__main__":
+    main()
Index: USACO GUIDE/GOLD/Combinatory/CF - E2. Close Tuples (hard version).py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/USACO GUIDE/GOLD/Combinatory/CF - E2. Close Tuples (hard version).py b/USACO GUIDE/GOLD/Combinatory/CF - E2. Close Tuples (hard version).py
new file mode 100644
--- /dev/null	(date 1732407546016)
+++ b/USACO GUIDE/GOLD/Combinatory/CF - E2. Close Tuples (hard version).py	(date 1732407546016)
@@ -0,0 +1,184 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+
+input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
+
+def ints(): return map(int, input().split())
+
+
+def strs(): return input().split()
+
+
+def chars(): return list(input().strip())
+
+
+def mat(n): return [list(ints()) for _ in range(n)]
+
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+
+def add(x, y, mod=MOD): return (x + y) % mod
+
+
+def sub(x, y, mod=MOD): return (x - y) % mod
+
+
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+
+RANDOM = getrandbits(32)
+
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+# region fastio
+
+BUFSIZE = 8192
+
+
+class FastIO(IOBase):
+    newlines = 0
+
+    def __init__(self, file):
+        self._file = file
+        self._fd = file.fileno()
+        self.buffer = BytesIO()
+        self.writable = "x" in file.mode or "r" not in file.mode
+        self.write = self.buffer.write if self.writable else None
+
+    def read(self):
+        while True:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            if not b:
+                break
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines = 0
+        return self.buffer.read()
+
+    def readline(self):
+        while self.newlines == 0:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            self.newlines = b.count(b"\n") + (not b)
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines -= 1
+        return self.buffer.readline()
+
+    def flush(self):
+        if self.writable:
+            os.write(self._fd, self.buffer.getvalue())
+            self.buffer.truncate(0), self.buffer.seek(0)
+
+
+class IOWrapper(IOBase):
+    def __init__(self, file):
+        self.buffer = FastIO(file)
+        self.flush = self.buffer.flush
+        self.writable = self.buffer.writable
+        self.write = lambda s: self.buffer.write(s.encode("ascii"))
+        self.read = lambda: self.buffer.read().decode("ascii")
+        self.readline = lambda: self.buffer.readline().decode("ascii")
+
+
+#sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
+
+
+# endregion
+MAX_N = (10)
+factors = [0] * MAX_N
+#inversions = [0] * MAX_N
+#inversions[0] = 1
+#inversions[1] = 1
+factors[0] = 1
+factors[1] = 1
+for i in range(2, MAX_N):
+    factors[i] = i * factors[i-1]
+ #   inversions[i] = pow(factors[i], MOD-2, MOD)
+
+
+def nCr(n, r):
+    if r > n: return 0
+    if n == r: return 1
+    return factors[n] // (factors[r] * factors[n-r])
+
+def nCr2(n):
+    return (n * (n - 1)) // 2 if n >= 2 else 0
+
+
+def main():
+    t = int(input())
+    for _ in range(t):
+        n = int(input())
+        a = list(ints())
+        print(solve(n, a))
+
+
+def solve(n, a):
+    a.sort()
+    ans = 0
+    k = 2
+    m = 3
+    for i in range(n):
+        n_ = bisect_right(a, a[i] + k) - (i + 1)
+        print(n_)
+        ans += nCr2(n_)
+    return ans
+
+
+if __name__ == "__main__":
+    main()
Index: USACO GUIDE/GOLD/Combinatory/CSES - Creating Strings II.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/USACO GUIDE/GOLD/Combinatory/CSES - Creating Strings II.py b/USACO GUIDE/GOLD/Combinatory/CSES - Creating Strings II.py
new file mode 100644
--- /dev/null	(date 1732412795875)
+++ b/USACO GUIDE/GOLD/Combinatory/CSES - Creating Strings II.py	(date 1732412795875)
@@ -0,0 +1,146 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+from types import GeneratorType
+
+input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+
+# region fastio
+
+BUFSIZE = 8192
+
+
+class FastIO(IOBase):
+    newlines = 0
+
+    def __init__(self, file):
+        self._file = file
+        self._fd = file.fileno()
+        self.buffer = BytesIO()
+        self.writable = "x" in file.mode or "r" not in file.mode
+        self.write = self.buffer.write if self.writable else None
+
+    def read(self):
+        while True:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            if not b:
+                break
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines = 0
+        return self.buffer.read()
+
+    def readline(self):
+        while self.newlines == 0:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            self.newlines = b.count(b"\n") + (not b)
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines -= 1
+        return self.buffer.readline()
+
+    def flush(self):
+        if self.writable:
+            os.write(self._fd, self.buffer.getvalue())
+            self.buffer.truncate(0), self.buffer.seek(0)
+
+
+class IOWrapper(IOBase):
+    def __init__(self, file):
+        self.buffer = FastIO(file)
+        self.flush = self.buffer.flush
+        self.writable = self.buffer.writable
+        self.write = lambda s: self.buffer.write(s.encode("ascii"))
+        self.read = lambda: self.buffer.read().decode("ascii")
+        self.readline = lambda: self.buffer.readline().decode("ascii")
+
+
+sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
+
+
+# endregion
+MAX_N = 1000005
+factorial = [0] * MAX_N
+inverse = [0] * MAX_N
+factorial[1] = 1
+inverse[1] = 1
+for i in range(2, MAX_N):
+    factorial[i] = (factorial[i-1] * i) % MOD
+    inverse[i] = pow(factorial[i], MOD-2, MOD)
+
+
+
+def main():
+    s = input()
+    frec = Counter(s)
+    #print(len(s))
+    ans = factorial[len(s)]
+    for it in frec.values():
+        ans*= inverse[it] % MOD
+    print(ans % MOD)
+
+if __name__ == "__main__":
+    main()
Index: Codeforces/Good Bye 2024 2025 is NEAR/A.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Codeforces/Good Bye 2024 2025 is NEAR/A.py b/Codeforces/Good Bye 2024 2025 is NEAR/A.py
new file mode 100644
--- /dev/null	(date 1738365560056)
+++ b/Codeforces/Good Bye 2024 2025 is NEAR/A.py	(date 1738365560056)
@@ -0,0 +1,144 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+from types import GeneratorType
+
+input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+
+# region fastio
+
+BUFSIZE = 8192
+
+
+class FastIO(IOBase):
+    newlines = 0
+
+    def __init__(self, file):
+        self._file = file
+        self._fd = file.fileno()
+        self.buffer = BytesIO()
+        self.writable = "x" in file.mode or "r" not in file.mode
+        self.write = self.buffer.write if self.writable else None
+
+    def read(self):
+        while True:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            if not b:
+                break
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines = 0
+        return self.buffer.read()
+
+    def readline(self):
+        while self.newlines == 0:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            self.newlines = b.count(b"\n") + (not b)
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines -= 1
+        return self.buffer.readline()
+
+    def flush(self):
+        if self.writable:
+            os.write(self._fd, self.buffer.getvalue())
+            self.buffer.truncate(0), self.buffer.seek(0)
+
+
+class IOWrapper(IOBase):
+    def __init__(self, file):
+        self.buffer = FastIO(file)
+        self.flush = self.buffer.flush
+        self.writable = self.buffer.writable
+        self.write = lambda s: self.buffer.write(s.encode("ascii"))
+        self.read = lambda: self.buffer.read().decode("ascii")
+        self.readline = lambda: self.buffer.readline().decode("ascii")
+
+
+sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
+
+
+# endregion
+
+
+def main():
+    t = int(input())
+    for _ in range(t):
+        n = int(input())
+        a = list(ints())
+        print(solve(n, a))
+
+
+def solve(n, a):
+    ans = False
+    for i in range(n - 1):
+        if 2 * min(a[i], a[i + 1]) > max(a[i], a[i + 1]):
+            ans = True
+            break
+    return "YES" if ans else "NO"
+
+if __name__ == "__main__":
+    main()
Index: Codeforces/Good Bye 2024 2025 is NEAR/B.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Codeforces/Good Bye 2024 2025 is NEAR/B.py b/Codeforces/Good Bye 2024 2025 is NEAR/B.py
new file mode 100644
--- /dev/null	(date 1738365560057)
+++ b/Codeforces/Good Bye 2024 2025 is NEAR/B.py	(date 1738365560057)
@@ -0,0 +1,201 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+from types import GeneratorType
+
+input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+
+# region fastio
+
+BUFSIZE = 8192
+
+
+class FastIO(IOBase):
+    newlines = 0
+
+    def __init__(self, file):
+        self._file = file
+        self._fd = file.fileno()
+        self.buffer = BytesIO()
+        self.writable = "x" in file.mode or "r" not in file.mode
+        self.write = self.buffer.write if self.writable else None
+
+    def read(self):
+        while True:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            if not b:
+                break
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines = 0
+        return self.buffer.read()
+
+    def readline(self):
+        while self.newlines == 0:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            self.newlines = b.count(b"\n") + (not b)
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines -= 1
+        return self.buffer.readline()
+
+    def flush(self):
+        if self.writable:
+            os.write(self._fd, self.buffer.getvalue())
+            self.buffer.truncate(0), self.buffer.seek(0)
+
+
+class IOWrapper(IOBase):
+    def __init__(self, file):
+        self.buffer = FastIO(file)
+        self.flush = self.buffer.flush
+        self.writable = self.buffer.writable
+        self.write = lambda s: self.buffer.write(s.encode("ascii"))
+        self.read = lambda: self.buffer.read().decode("ascii")
+        self.readline = lambda: self.buffer.readline().decode("ascii")
+
+
+#sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
+
+
+# endregion
+
+class FTree:
+    def __init__(self, f):
+        self.n = len(f)
+        self.ft = [0] * (self.n + 1)
+
+        for i in range(1, self.n + 1):
+            self.ft[i] += f[i - 1]
+            if i + self.lsone(i) <= self.n:
+                self.ft[i + self.lsone(i)] += self.ft[i]
+
+    def lsone(self, s):
+        return s & (-s)
+
+    def query(self, i, j):
+        if i > 1:
+            return self.query(1, j) - self.query(1, i - 1)
+
+        s = 0
+        while j > 0:
+            s += self.ft[j]
+            j -= self.lsone(j)
+
+        return s
+
+    def update(self, i, v):
+        while i <= self.n:
+            self.ft[i] += v
+            i += self.lsone(i)
+
+    def select(self, k):
+        p = 1
+        while (p * 2) <= self.n: p *= 2
+
+        i = 0
+        while p > 0:
+            if k > self.ft[i + p]:
+                k -= self.ft[i + p]
+                i += p
+            p //= 2
+
+        return i + 1
+
+MAX_N = 2 * (10 ** 5) + 1
+def main():
+    t = int(input())
+    for _ in range(t):
+        n = int(input())
+        a = [tuple(ints()) for i in range(n)]
+        print(solve(n, a))
+
+
+def solve(n, a):
+    max_x = max(r for l, r in a)
+    #print(max_x)
+    frec, curr = [0] * (max_x + 2), [0] * (max_x + 2)
+    for i, (l, r) in enumerate(a, 1):
+        if l == r:
+            frec[l] += 1
+            curr[l] = i if frec[l] == 1 else 0
+    open = [0] * (max_x + 2)
+    prefix = [0] * (max_x + 2)
+    for i in range(1, max_x + 1):
+        open[i] = 1 if frec[i] == 0 else 0
+        prefix[i] = prefix[i - 1] + open[i]
+    x = [[] for _ in range(n + 1)]
+    for i in range(1, max_x + 1):
+        if curr[i] >= 1:
+            x[curr[i]].append(i)
+    ans = []
+    for i, (l, r) in enumerate(a, 1):
+        ans.append('1' if prefix[r] - prefix[l - 1] > 0 or
+                          bisect_left(x[i], l) < len(x[i]) and
+                          x[i][bisect_left(x[i], l)] <= r else '0')
+    return "".join(ans)
+if __name__ == "__main__":
+    main()
Index: Codeforces/Good Bye 2024 2025 is NEAR/C.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Codeforces/Good Bye 2024 2025 is NEAR/C.py b/Codeforces/Good Bye 2024 2025 is NEAR/C.py
new file mode 100644
--- /dev/null	(date 1738365560057)
+++ b/Codeforces/Good Bye 2024 2025 is NEAR/C.py	(date 1738365560057)
@@ -0,0 +1,151 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+from types import GeneratorType
+
+input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+
+# region fastio
+
+BUFSIZE = 8192
+
+
+class FastIO(IOBase):
+    newlines = 0
+
+    def __init__(self, file):
+        self._file = file
+        self._fd = file.fileno()
+        self.buffer = BytesIO()
+        self.writable = "x" in file.mode or "r" not in file.mode
+        self.write = self.buffer.write if self.writable else None
+
+    def read(self):
+        while True:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            if not b:
+                break
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines = 0
+        return self.buffer.read()
+
+    def readline(self):
+        while self.newlines == 0:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            self.newlines = b.count(b"\n") + (not b)
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines -= 1
+        return self.buffer.readline()
+
+    def flush(self):
+        if self.writable:
+            os.write(self._fd, self.buffer.getvalue())
+            self.buffer.truncate(0), self.buffer.seek(0)
+
+
+class IOWrapper(IOBase):
+    def __init__(self, file):
+        self.buffer = FastIO(file)
+        self.flush = self.buffer.flush
+        self.writable = self.buffer.writable
+        self.write = lambda s: self.buffer.write(s.encode("ascii"))
+        self.read = lambda: self.buffer.read().decode("ascii")
+        self.readline = lambda: self.buffer.readline().decode("ascii")
+
+
+sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
+
+
+# endregion
+
+
+def main():
+    t = int(input())
+    for _ in range(t):
+        n, k = ints()
+        print(solve(1, n, k)[0])
+
+
+def solve(l, r, k):
+    if k == 1: return r * (r + 1) // 2, 0
+    if r - l + 1 < k:
+        return 0, 0
+    if r - l + 1 == 1:
+        return l, 0
+    mid = l + (r - l) // 2
+    if (r - l + 1) & 1:
+        new_l = solve(l, mid - 1, k)
+        rest = 2 * new_l[1] + 1
+        return mid + 2 * new_l[0] + mid * new_l[1], rest
+    else:
+        new_l = solve(l, mid, k)
+        rest = 2 * new_l[1]
+        return 2 * new_l[0] + mid * new_l[1], rest
+
+if __name__ == "__main__":
+    main()
Index: Bootcamp/2024 ICPC Belarus/H.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Bootcamp/2024 ICPC Belarus/H.py b/Bootcamp/2024 ICPC Belarus/H.py
new file mode 100644
--- /dev/null	(date 1738365560049)
+++ b/Bootcamp/2024 ICPC Belarus/H.py	(date 1738365560049)
@@ -0,0 +1,8 @@
+s = input()
+print("What is the name of your team?")
+print(f"Our name is {s}.")
+print("My apologies, I did not understand. What is your team name?")
+print(f"We are team {s}.")
+print("I am really sorry. Could you please repeat it once again?")
+print(f"WE ARE TEAM {s.upper()}!!!")
+print("Oh, now I see. Here are your badges. Good luck!")
Index: Bootcamp/2024 ICPC Belarus/E.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Bootcamp/2024 ICPC Belarus/E.py b/Bootcamp/2024 ICPC Belarus/E.py
new file mode 100644
--- /dev/null	(date 1738365560049)
+++ b/Bootcamp/2024 ICPC Belarus/E.py	(date 1738365560049)
@@ -0,0 +1,175 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+from types import GeneratorType
+
+input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+
+# region fastio
+
+BUFSIZE = 8192
+
+
+class FastIO(IOBase):
+    newlines = 0
+
+    def __init__(self, file):
+        self._file = file
+        self._fd = file.fileno()
+        self.buffer = BytesIO()
+        self.writable = "x" in file.mode or "r" not in file.mode
+        self.write = self.buffer.write if self.writable else None
+
+    def read(self):
+        while True:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            if not b:
+                break
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines = 0
+        return self.buffer.read()
+
+    def readline(self):
+        while self.newlines == 0:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            self.newlines = b.count(b"\n") + (not b)
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines -= 1
+        return self.buffer.readline()
+
+    def flush(self):
+        if self.writable:
+            os.write(self._fd, self.buffer.getvalue())
+            self.buffer.truncate(0), self.buffer.seek(0)
+
+
+class IOWrapper(IOBase):
+    def __init__(self, file):
+        self.buffer = FastIO(file)
+        self.flush = self.buffer.flush
+        self.writable = self.buffer.writable
+        self.write = lambda s: self.buffer.write(s.encode("ascii"))
+        self.read = lambda: self.buffer.read().decode("ascii")
+        self.readline = lambda: self.buffer.readline().decode("ascii")
+
+
+#sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
+
+
+# endregion
+
+
+def main():
+    n = int(input())
+    a = list(ints())
+    solve(n, a)
+
+
+
+def solve(n, a): # Build adjacency list
+    AL = [[] for _ in range(n + 1)]
+    for _ in range(n - 1):
+        u, v = ints()
+        AL[u].append(v)
+        AL[v].append(u)
+
+    # DFS to ensure a valid tree transformation
+    def dfs(u, p):
+        for v in AL[u]:
+            if v == p:
+                continue
+            dfs(v, u)
+            a[u - 1] -= a[v - 1]
+            if a[u - 1] < 0:
+                return
+
+    dfs(1, -1)
+    if a[0] != 0:
+        # Not feasible
+        print(0)
+        return
+
+    # Print the path "as you go" to avoid storing a large list
+    sys.stdout.write("1 ")
+
+    def dfs2(u, p):
+        for v in AL[u]:
+            if v == p:
+                continue
+            for _ in range(a[v - 1]):
+                # Go to child
+                sys.stdout.write(str(v) + " ")
+                dfs2(v, u)
+                # Come back to parent
+                sys.stdout.write(str(u) + " ")
+
+    dfs2(1, -1)
+    sys.stdout.write("\n")
+
+if __name__ == "__main__":
+    main()
Index: Codeforces/Codeforces Round 986 (Div 2)/A.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Codeforces/Codeforces Round 986 (Div 2)/A.py b/Codeforces/Codeforces Round 986 (Div 2)/A.py
new file mode 100644
--- /dev/null	(date 1731253380036)
+++ b/Codeforces/Codeforces Round 986 (Div 2)/A.py	(date 1731253380036)
@@ -0,0 +1,73 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+
+input = lambda: sys.stdin.readline().strip()
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+directions = {'N': (0, 1), 'E': (1, 0), 'S': (0, -1), 'W': (-1, 0)}
+def main():
+    t = int(input())
+    ans = []
+    for _ in range(t):
+        n, a, b  = ints()
+        s = input()
+        x, y = 0, 0
+        found = False
+        for _ in range(1000):
+            for move in s:
+                dx, dy = directions[move]
+                x, y = x + dx, y + dy
+                if (x, y) == (a, b):
+                    ans.append('YES')
+                    found = True
+                    break
+            if found:
+                break
+        if not found:
+            ans.append('NO')
+    print("\n".join(ans))
+
+
+if __name__ == "__main__":
+    main()
Index: Bootcamp/2024 ICPC Belarus/K.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Bootcamp/2024 ICPC Belarus/K.py b/Bootcamp/2024 ICPC Belarus/K.py
new file mode 100644
--- /dev/null	(date 1738365560049)
+++ b/Bootcamp/2024 ICPC Belarus/K.py	(date 1738365560049)
@@ -0,0 +1,17 @@
+from itertools import accumulate
+t = int(input())
+for _ in range(t):
+    n, m = map(int, input().split())
+    a = map(int, input().split())
+    prefix = [0] + list(accumulate(a))
+    total = prefix[-1]
+    for i in range(m):
+        sd, sm, ed, em = map(int, input().split())
+        arrival_day = prefix[sm - 1] + sd
+        depart_day = prefix[em - 1] + ed
+        ans = 0
+        if depart_day >= arrival_day:
+            ans = depart_day - arrival_day + 1
+        else:
+            ans = total - arrival_day + depart_day + 1
+        print(ans)
\ No newline at end of file
Index: Bootcamp/2024-2025 ICPC Northwestern European Regional Programming Contest (NWERC 2024)/F. Flowing Fountain.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Bootcamp/2024-2025 ICPC Northwestern European Regional Programming Contest (NWERC 2024)/F. Flowing Fountain.py b/Bootcamp/2024-2025 ICPC Northwestern European Regional Programming Contest (NWERC 2024)/F. Flowing Fountain.py
new file mode 100644
--- /dev/null	(date 1738365560049)
+++ b/Bootcamp/2024-2025 ICPC Northwestern European Regional Programming Contest (NWERC 2024)/F. Flowing Fountain.py	(date 1738365560049)
@@ -0,0 +1,204 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+from types import GeneratorType
+
+input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+
+# region fastio
+
+BUFSIZE = 8192
+
+
+class FastIO(IOBase):
+    newlines = 0
+
+    def __init__(self, file):
+        self._file = file
+        self._fd = file.fileno()
+        self.buffer = BytesIO()
+        self.writable = "x" in file.mode or "r" not in file.mode
+        self.write = self.buffer.write if self.writable else None
+
+    def read(self):
+        while True:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            if not b:
+                break
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines = 0
+        return self.buffer.read()
+
+    def readline(self):
+        while self.newlines == 0:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            self.newlines = b.count(b"\n") + (not b)
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines -= 1
+        return self.buffer.readline()
+
+    def flush(self):
+        if self.writable:
+            os.write(self._fd, self.buffer.getvalue())
+            self.buffer.truncate(0), self.buffer.seek(0)
+
+
+class IOWrapper(IOBase):
+    def __init__(self, file):
+        self.buffer = FastIO(file)
+        self.flush = self.buffer.flush
+        self.writable = self.buffer.writable
+        self.write = lambda s: self.buffer.write(s.encode("ascii"))
+        self.read = lambda: self.buffer.read().decode("ascii")
+        self.readline = lambda: self.buffer.readline().decode("ascii")
+
+
+#sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
+
+
+# endregion
+
+def next_greater_elements(arr):
+    result = [-1] * len(arr)
+    stack = []
+    index = [0] * len(arr)
+    for i, num in enumerate(arr):
+        while stack and arr[stack[-1]] < num:
+            val = stack.pop()
+            result[val] = num
+            index[val] = i
+        stack.append(i)
+    return index
+
+class UnionFind:
+    def __init__(self, n):
+        self.parent = list(range(n))
+        self.size = [1] * n
+        self.num_sets = n
+
+    def find(self, a):
+        acopy = a
+        while a != self.parent[a]:
+            a = self.parent[a]
+        while acopy != a:
+            self.parent[acopy], acopy = a, self.parent[acopy]
+
+        return a
+
+    def union(self, a, b):
+        a, b = self.find(a), self.find(b)
+        if a != b:
+            self.num_sets -= 1
+            self.parent[b] = a
+            self.size[a] += self.size[b]
+
+    def set_size(self, a):
+        return self.size[self.find(a)]
+
+    def __len__(self):
+        return self.num_sets
+
+def main():
+    n,q = ints()
+    a = [INF] + list(ints())
+    conteiners = [0] * ( n + 1 )
+    UF = UnionFind(n + 1)
+    res = []
+    #p = [0] * (n+1)
+    p = next_greater_elements(a)
+    #print(p)
+    for i in range(q):
+        s, *pack = strs()
+        if s == "+":
+            """u, t = map(int, pack)
+            u -= 1
+            while t:
+                node = UF.find(u)
+                conteiners[node] += t
+                t = max(conteiners[node] - a[node], 0)
+                if t != 0:
+                    conteiners[node] = a[node]
+                    UF.union(UF.find(next_max[node]), node)
+                    u = next_max[node]
+                    if u == 0: break"""
+            u, t = map(int, pack)
+            while t + conteiners[u] > a[u]:
+                t -= a[u] - conteiners[u]
+                conteiners[u] = a[u]
+                #print(conteiners[p[u]] == a[p[u]])
+                if conteiners[p[u]] == a[p[u]]:
+                    p[u] = p[p[u]]
+                u = p[u]
+            conteiners[u] += t
+        if s ==  "?":
+            u = int(pack[0])
+            res.append(conteiners[u])
+    print("\n".join(map(str, res)))
+
+if __name__ == "__main__":
+    main()
Index: Codeforces/Random/1816A.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Codeforces/Random/1816A.py b/Codeforces/Random/1816A.py
new file mode 100644
--- /dev/null	(date 1738365560060)
+++ b/Codeforces/Random/1816A.py	(date 1738365560060)
@@ -0,0 +1,136 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+from types import GeneratorType
+
+input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+
+# region fastio
+
+BUFSIZE = 8192
+
+
+class FastIO(IOBase):
+    newlines = 0
+
+    def __init__(self, file):
+        self._file = file
+        self._fd = file.fileno()
+        self.buffer = BytesIO()
+        self.writable = "x" in file.mode or "r" not in file.mode
+        self.write = self.buffer.write if self.writable else None
+
+    def read(self):
+        while True:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            if not b:
+                break
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines = 0
+        return self.buffer.read()
+
+    def readline(self):
+        while self.newlines == 0:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            self.newlines = b.count(b"\n") + (not b)
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines -= 1
+        return self.buffer.readline()
+
+    def flush(self):
+        if self.writable:
+            os.write(self._fd, self.buffer.getvalue())
+            self.buffer.truncate(0), self.buffer.seek(0)
+
+
+class IOWrapper(IOBase):
+    def __init__(self, file):
+        self.buffer = FastIO(file)
+        self.flush = self.buffer.flush
+        self.writable = self.buffer.writable
+        self.write = lambda s: self.buffer.write(s.encode("ascii"))
+        self.read = lambda: self.buffer.read().decode("ascii")
+        self.readline = lambda: self.buffer.readline().decode("ascii")
+
+
+sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
+
+
+# endregion
+
+
+def main():
+    t = int(input())
+    for _ in range(t):
+        a, b = ints()
+        print(2)
+        print(a-1, 1)
+        print(a, b)
+
+if __name__ == "__main__":
+    main()
Index: Codeforces/Random/2038A.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Codeforces/Random/2038A.py b/Codeforces/Random/2038A.py
new file mode 100644
--- /dev/null	(date 1738365560060)
+++ b/Codeforces/Random/2038A.py	(date 1738365560060)
@@ -0,0 +1,143 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+from types import GeneratorType
+
+input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+
+# region fastio
+
+BUFSIZE = 8192
+
+
+class FastIO(IOBase):
+    newlines = 0
+
+    def __init__(self, file):
+        self._file = file
+        self._fd = file.fileno()
+        self.buffer = BytesIO()
+        self.writable = "x" in file.mode or "r" not in file.mode
+        self.write = self.buffer.write if self.writable else None
+
+    def read(self):
+        while True:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            if not b:
+                break
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines = 0
+        return self.buffer.read()
+
+    def readline(self):
+        while self.newlines == 0:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            self.newlines = b.count(b"\n") + (not b)
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines -= 1
+        return self.buffer.readline()
+
+    def flush(self):
+        if self.writable:
+            os.write(self._fd, self.buffer.getvalue())
+            self.buffer.truncate(0), self.buffer.seek(0)
+
+
+class IOWrapper(IOBase):
+    def __init__(self, file):
+        self.buffer = FastIO(file)
+        self.flush = self.buffer.flush
+        self.writable = self.buffer.writable
+        self.write = lambda s: self.buffer.write(s.encode("ascii"))
+        self.read = lambda: self.buffer.read().decode("ascii")
+        self.readline = lambda: self.buffer.readline().decode("ascii")
+
+
+sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
+
+
+# endregion
+
+
+def main():
+    n, k = ints()
+    a = list(ints())
+    b = list(ints())
+    print(*solve(n, k, a, b))
+
+
+
+def solve(n, k, a, b):
+    ans = [0] * (n)
+    for i in range(n-1, -1, -1):
+        ans[i] = min(a[i] // b[i], k)
+        k -= ans[i]
+    return (ans if not k else [0 for i in range(n)])
+
+if __name__ == "__main__":
+    main()
Index: Codeforces/Codeforces Round 981 (Div 3)/B.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Codeforces/Codeforces Round 981 (Div 3)/B.py b/Codeforces/Codeforces Round 981 (Div 3)/B.py
new file mode 100644
--- /dev/null	(date 1730239963224)
+++ b/Codeforces/Codeforces Round 981 (Div 3)/B.py	(date 1730239963224)
@@ -0,0 +1,88 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+
+input = lambda: sys.stdin.readline().strip()
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+def main():
+    t = int(input())
+    for _ in range(t):
+        n = int(input())
+        a = []
+        for i in range(n):
+            a.append(list(ints()))
+        print(solve(n, a))
+
+
+def solve(n ,a ):
+    ans = []
+    for i in range(n):
+        min_ = INF
+        for j in range(n):
+            row = j+i
+            col = j
+            if row >= n:
+                break
+            if a[row][col] < 0:
+                min_ = min(min_, a[row][col])
+        if min_ != INF:
+            ans.append(abs(min_))
+    for i in range(1, n):
+        min_ = INF
+        for j in range(n):
+            col = j + i
+            row = j
+            if col >= n:
+                break
+            if a[row][col] < 0:
+                min_ = min(min_, a[row][col])
+        if min_ != INF:
+            ans.append(abs(min_))
+    return sum(ans)
+
+
+
+if __name__ == "__main__":
+    main()
Index: Codeforces/CF Hello/A.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Codeforces/CF Hello/A.py b/Codeforces/CF Hello/A.py
new file mode 100644
--- /dev/null	(date 1738365560050)
+++ b/Codeforces/CF Hello/A.py	(date 1738365560050)
@@ -0,0 +1,134 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+from types import GeneratorType
+
+input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+
+# region fastio
+
+BUFSIZE = 8192
+
+
+class FastIO(IOBase):
+    newlines = 0
+
+    def __init__(self, file):
+        self._file = file
+        self._fd = file.fileno()
+        self.buffer = BytesIO()
+        self.writable = "x" in file.mode or "r" not in file.mode
+        self.write = self.buffer.write if self.writable else None
+
+    def read(self):
+        while True:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            if not b:
+                break
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines = 0
+        return self.buffer.read()
+
+    def readline(self):
+        while self.newlines == 0:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            self.newlines = b.count(b"\n") + (not b)
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines -= 1
+        return self.buffer.readline()
+
+    def flush(self):
+        if self.writable:
+            os.write(self._fd, self.buffer.getvalue())
+            self.buffer.truncate(0), self.buffer.seek(0)
+
+
+class IOWrapper(IOBase):
+    def __init__(self, file):
+        self.buffer = FastIO(file)
+        self.flush = self.buffer.flush
+        self.writable = self.buffer.writable
+        self.write = lambda s: self.buffer.write(s.encode("ascii"))
+        self.read = lambda: self.buffer.read().decode("ascii")
+        self.readline = lambda: self.buffer.readline().decode("ascii")
+
+
+#sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
+
+
+# endregion
+
+
+def main():
+    t = int(input())
+    for i in range(t):
+        n, m = ints()
+        print(max(n, m) + 1)
+
+if __name__ == "__main__":
+    main()
Index: Codeforces/CF Hello/C.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Codeforces/CF Hello/C.py b/Codeforces/CF Hello/C.py
new file mode 100644
--- /dev/null	(date 1738365560050)
+++ b/Codeforces/CF Hello/C.py	(date 1738365560050)
@@ -0,0 +1,165 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+from types import GeneratorType
+
+input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+
+# region fastio
+
+BUFSIZE = 8192
+
+
+class FastIO(IOBase):
+    newlines = 0
+
+    def __init__(self, file):
+        self._file = file
+        self._fd = file.fileno()
+        self.buffer = BytesIO()
+        self.writable = "x" in file.mode or "r" not in file.mode
+        self.write = self.buffer.write if self.writable else None
+
+    def read(self):
+        while True:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            if not b:
+                break
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines = 0
+        return self.buffer.read()
+
+    def readline(self):
+        while self.newlines == 0:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            self.newlines = b.count(b"\n") + (not b)
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines -= 1
+        return self.buffer.readline()
+
+    def flush(self):
+        if self.writable:
+            os.write(self._fd, self.buffer.getvalue())
+            self.buffer.truncate(0), self.buffer.seek(0)
+
+
+class IOWrapper(IOBase):
+    def __init__(self, file):
+        self.buffer = FastIO(file)
+        self.flush = self.buffer.flush
+        self.writable = self.buffer.writable
+        self.write = lambda s: self.buffer.write(s.encode("ascii"))
+        self.read = lambda: self.buffer.read().decode("ascii")
+        self.readline = lambda: self.buffer.readline().decode("ascii")
+
+
+#sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
+
+
+# endregion
+
+
+def main():
+    t = int(input())
+    for _ in range(t):
+        l ,r = ints()
+        xor = (l ^ r).bit_length() - 1
+        r = bin(r)[2:]
+        pow_2 = 2 ** xor
+        binary = bin(pow_2)[2:]
+        binary = r[:-len(binary)] + binary
+        num = int(binary, 2)
+        r = int(r, 2)
+        #print(num, binary)
+        if num == r:
+            print(num, num -1 , num - 2)
+        else:
+            if num + 2 > r:
+                total_1 = (num + 1) + (num) + (num - 1)
+                total_2 = (num - 2) + (num - 1) + (num)
+                print((num + 1) , (num) , (num - 1) if total_1 > total_2 else (num - 2) + (num - 1) + (num))
+            else:
+                a = num + 1
+                b = num
+                c = num - 1
+                total_1 = (a ^ b) + (b ^ c) + (c ^ a)
+                a = num - 2; b = num - 1; c = num
+                total_2 = (a ^ b) + (b ^ c) + (c ^ a)
+                a = num + 2
+                b = num + 1
+                c = num
+                total_3 = (a ^ b) + (b ^ c) + (c ^ a)
+                if total_1 >= total_2 and total_1 >= total_3:
+                    print((num + 1), (num), (num - 1))
+                elif total_2 >= total_1 and total_2 >= total_3:
+                    print((num - 2) + (num - 1) + (num))
+                else:
+                    print((num + 2) , (num + 1) , (num))
+
+if __name__ == "__main__":
+    main()
Index: Codeforces/Random/1107B.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Codeforces/Random/1107B.py b/Codeforces/Random/1107B.py
new file mode 100644
--- /dev/null	(date 1738365560057)
+++ b/Codeforces/Random/1107B.py	(date 1738365560057)
@@ -0,0 +1,134 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+from types import GeneratorType
+
+input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+
+# region fastio
+
+BUFSIZE = 8192
+
+
+class FastIO(IOBase):
+    newlines = 0
+
+    def __init__(self, file):
+        self._file = file
+        self._fd = file.fileno()
+        self.buffer = BytesIO()
+        self.writable = "x" in file.mode or "r" not in file.mode
+        self.write = self.buffer.write if self.writable else None
+
+    def read(self):
+        while True:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            if not b:
+                break
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines = 0
+        return self.buffer.read()
+
+    def readline(self):
+        while self.newlines == 0:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            self.newlines = b.count(b"\n") + (not b)
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines -= 1
+        return self.buffer.readline()
+
+    def flush(self):
+        if self.writable:
+            os.write(self._fd, self.buffer.getvalue())
+            self.buffer.truncate(0), self.buffer.seek(0)
+
+
+class IOWrapper(IOBase):
+    def __init__(self, file):
+        self.buffer = FastIO(file)
+        self.flush = self.buffer.flush
+        self.writable = self.buffer.writable
+        self.write = lambda s: self.buffer.write(s.encode("ascii"))
+        self.read = lambda: self.buffer.read().decode("ascii")
+        self.readline = lambda: self.buffer.readline().decode("ascii")
+
+
+sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
+
+
+# endregion
+
+
+def main():
+    t = int(input())
+    for _ in range(t):
+        k, n = ints()
+        print(9 * (k-1) + n)
+
+if __name__ == "__main__":
+    main()
Index: Codeforces/Random/1401B.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Codeforces/Random/1401B.py b/Codeforces/Random/1401B.py
new file mode 100644
--- /dev/null	(date 1738365560057)
+++ b/Codeforces/Random/1401B.py	(date 1738365560057)
@@ -0,0 +1,168 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+from types import GeneratorType
+
+input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+
+# region fastio
+
+BUFSIZE = 8192
+
+
+class FastIO(IOBase):
+    newlines = 0
+
+    def __init__(self, file):
+        self._file = file
+        self._fd = file.fileno()
+        self.buffer = BytesIO()
+        self.writable = "x" in file.mode or "r" not in file.mode
+        self.write = self.buffer.write if self.writable else None
+
+    def read(self):
+        while True:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            if not b:
+                break
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines = 0
+        return self.buffer.read()
+
+    def readline(self):
+        while self.newlines == 0:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            self.newlines = b.count(b"\n") + (not b)
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines -= 1
+        return self.buffer.readline()
+
+    def flush(self):
+        if self.writable:
+            os.write(self._fd, self.buffer.getvalue())
+            self.buffer.truncate(0), self.buffer.seek(0)
+
+
+class IOWrapper(IOBase):
+    def __init__(self, file):
+        self.buffer = FastIO(file)
+        self.flush = self.buffer.flush
+        self.writable = self.buffer.writable
+        self.write = lambda s: self.buffer.write(s.encode("ascii"))
+        self.read = lambda: self.buffer.read().decode("ascii")
+        self.readline = lambda: self.buffer.readline().decode("ascii")
+
+
+#sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
+
+
+# endregion
+
+
+def main():
+    t = int(input())
+    for _ in range(t):
+        a = list(ints())
+        b = list(ints())
+        ans = 2 * min(a[2],b[1])
+        aux = min(a[2],b[1])
+        a[2] -= aux
+        b[1] -= aux
+        aux = min(a[2], b[2])
+        a[2] -= aux
+        b[2] -= aux
+        aux = min(a[1], b[1])
+        a[1] -= aux
+        b[1] -= aux
+        aux = min(a[2], b[0])
+        a[2] -= aux
+        b[0] -= aux
+
+        aux = min(a[1], b[0])
+        a[1] -= aux
+        b[0] -= aux
+
+        aux = min(a[0], b[0])
+        a[0] -= aux
+        b[0] -= aux
+        aux = min(a[0], b[1])
+        a[0] -= aux
+        b[1] -= aux
+        aux = min(a[0], b[2])
+        a[0] -= aux
+        b[2] -= aux
+        #print(a, b, ans)
+        ans -= 2 * min(a[1] , b[2])
+        print(ans)
+
+
+def solve(n, a):
+    pass
+
+if __name__ == "__main__":
+    main()
Index: Codeforces/Random/1450B.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Codeforces/Random/1450B.py b/Codeforces/Random/1450B.py
new file mode 100644
--- /dev/null	(date 1738365560058)
+++ b/Codeforces/Random/1450B.py	(date 1738365560058)
@@ -0,0 +1,141 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+from types import GeneratorType
+
+input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+
+# region fastio
+
+BUFSIZE = 8192
+
+
+class FastIO(IOBase):
+    newlines = 0
+
+    def __init__(self, file):
+        self._file = file
+        self._fd = file.fileno()
+        self.buffer = BytesIO()
+        self.writable = "x" in file.mode or "r" not in file.mode
+        self.write = self.buffer.write if self.writable else None
+
+    def read(self):
+        while True:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            if not b:
+                break
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines = 0
+        return self.buffer.read()
+
+    def readline(self):
+        while self.newlines == 0:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            self.newlines = b.count(b"\n") + (not b)
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines -= 1
+        return self.buffer.readline()
+
+    def flush(self):
+        if self.writable:
+            os.write(self._fd, self.buffer.getvalue())
+            self.buffer.truncate(0), self.buffer.seek(0)
+
+
+class IOWrapper(IOBase):
+    def __init__(self, file):
+        self.buffer = FastIO(file)
+        self.flush = self.buffer.flush
+        self.writable = self.buffer.writable
+        self.write = lambda s: self.buffer.write(s.encode("ascii"))
+        self.read = lambda: self.buffer.read().decode("ascii")
+        self.readline = lambda: self.buffer.readline().decode("ascii")
+
+
+sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
+
+
+# endregion
+
+
+def main():
+    t = int(input())
+    for _ in range(t):
+        n, k = ints()
+        points = [list(ints()) for i in range(n)]
+        AL = [[] for i in range(n)]
+        for i in range(k):
+            for j in range(i+1, n):
+                if abs(points[i][0] -  points[j][0]) + abs(points[i][1] -  points[j][1]) <= k:
+                    AL[i].append(j)
+                    AL[j].append(i)
+        print(1 if any(len(AL[i]) == n-1 for i in range(n)) else -1)
+
+if __name__ == "__main__":
+    main()
Index: Codeforces/Educational Codeforces Round 100 (Rated for Div 2)/B.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Codeforces/Educational Codeforces Round 100 (Rated for Div 2)/B.py b/Codeforces/Educational Codeforces Round 100 (Rated for Div 2)/B.py
new file mode 100644
--- /dev/null	(date 1738365560056)
+++ b/Codeforces/Educational Codeforces Round 100 (Rated for Div 2)/B.py	(date 1738365560056)
@@ -0,0 +1,144 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+from types import GeneratorType
+
+input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+
+# region fastio
+
+BUFSIZE = 8192
+
+
+class FastIO(IOBase):
+    newlines = 0
+
+    def __init__(self, file):
+        self._file = file
+        self._fd = file.fileno()
+        self.buffer = BytesIO()
+        self.writable = "x" in file.mode or "r" not in file.mode
+        self.write = self.buffer.write if self.writable else None
+
+    def read(self):
+        while True:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            if not b:
+                break
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines = 0
+        return self.buffer.read()
+
+    def readline(self):
+        while self.newlines == 0:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            self.newlines = b.count(b"\n") + (not b)
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines -= 1
+        return self.buffer.readline()
+
+    def flush(self):
+        if self.writable:
+            os.write(self._fd, self.buffer.getvalue())
+            self.buffer.truncate(0), self.buffer.seek(0)
+
+
+class IOWrapper(IOBase):
+    def __init__(self, file):
+        self.buffer = FastIO(file)
+        self.flush = self.buffer.flush
+        self.writable = self.buffer.writable
+        self.write = lambda s: self.buffer.write(s.encode("ascii"))
+        self.read = lambda: self.buffer.read().decode("ascii")
+        self.readline = lambda: self.buffer.readline().decode("ascii")
+
+
+sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
+
+
+# endregion
+
+
+def main():
+    t = int(input())
+    for _ in range(t):
+        n = int(input())
+        a = list(ints())
+        print(*solve(n, a))
+
+
+def solve(n, a):
+    opt1 = [1 if i & 1 else a[i] for i in range(n)]
+    opt2 = [1 if not i & 1 else a[i] for i in range(n)]
+    #print(opt1, opt2)
+    if 2 * sum([abs(opt2[i] - a[i]) for i in range(n)]) < 2* sum([abs(opt1[i] - a[i]) for i in range(n)]):
+        return opt2
+    return opt1
+
+if __name__ == "__main__":
+    main()
Index: Codeforces/Random/1512B.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Codeforces/Random/1512B.py b/Codeforces/Random/1512B.py
new file mode 100644
--- /dev/null	(date 1738365560058)
+++ b/Codeforces/Random/1512B.py	(date 1738365560058)
@@ -0,0 +1,166 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from multiprocessing.pool import job_counter
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+from types import GeneratorType
+
+input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+
+# region fastio
+
+BUFSIZE = 8192
+
+
+class FastIO(IOBase):
+    newlines = 0
+
+    def __init__(self, file):
+        self._file = file
+        self._fd = file.fileno()
+        self.buffer = BytesIO()
+        self.writable = "x" in file.mode or "r" not in file.mode
+        self.write = self.buffer.write if self.writable else None
+
+    def read(self):
+        while True:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            if not b:
+                break
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines = 0
+        return self.buffer.read()
+
+    def readline(self):
+        while self.newlines == 0:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            self.newlines = b.count(b"\n") + (not b)
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines -= 1
+        return self.buffer.readline()
+
+    def flush(self):
+        if self.writable:
+            os.write(self._fd, self.buffer.getvalue())
+            self.buffer.truncate(0), self.buffer.seek(0)
+
+
+class IOWrapper(IOBase):
+    def __init__(self, file):
+        self.buffer = FastIO(file)
+        self.flush = self.buffer.flush
+        self.writable = self.buffer.writable
+        self.write = lambda s: self.buffer.write(s.encode("ascii"))
+        self.read = lambda: self.buffer.read().decode("ascii")
+        self.readline = lambda: self.buffer.readline().decode("ascii")
+
+
+#sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
+
+
+# endregion
+
+
+def main():
+    t = int(input())
+    for _ in range(t):
+        n = int(input())
+        a = [list(input()) for i in range(n)]
+        solve(n, a)
+
+
+def solve(n, a):
+    index_a = -1
+    index_b = (0, 0)
+    for i in range(n):
+        for j in range(n):
+            if a[i][j] == '*':
+                if index_a == -1:
+                    index_a = (i, j)
+                else:
+                    index_b = (i, j)
+    if index_b[0] == index_a[0]:
+        if index_a[0] < n - 2:
+            a[index_b[0] + 1][index_b[1]] = '*'
+            a[index_a[0] + 1][index_a[1]] = '*'
+        else:
+            a[index_b[0] - 1][index_b[1]] = '*'
+            a[index_a[0] - 1][index_a[1]] = '*'
+    elif index_b[1] == index_a[1]:
+        if index_a[1] < n - 2:
+            a[index_b[0]][index_b[1] + 1] = '*'
+            a[index_a[0]][index_a[1] + 1] = '*'
+        else:
+            a[index_b[0]][index_b[1] - 1] = '*'
+            a[index_a[0]][index_a[1] - 1] = '*'
+    else:
+        a[index_a[0]][index_b[1]] = '*'
+        a[index_b[0]][index_a[1]] = '*'
+    for i in range(n):
+        print("".join(a[i]))
+if __name__ == "__main__":
+    main()
Index: Codeforces/Random/1537B.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Codeforces/Random/1537B.py b/Codeforces/Random/1537B.py
new file mode 100644
--- /dev/null	(date 1738365560058)
+++ b/Codeforces/Random/1537B.py	(date 1738365560058)
@@ -0,0 +1,138 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+from types import GeneratorType
+
+input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+
+# region fastio
+
+BUFSIZE = 8192
+
+
+class FastIO(IOBase):
+    newlines = 0
+
+    def __init__(self, file):
+        self._file = file
+        self._fd = file.fileno()
+        self.buffer = BytesIO()
+        self.writable = "x" in file.mode or "r" not in file.mode
+        self.write = self.buffer.write if self.writable else None
+
+    def read(self):
+        while True:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            if not b:
+                break
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines = 0
+        return self.buffer.read()
+
+    def readline(self):
+        while self.newlines == 0:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            self.newlines = b.count(b"\n") + (not b)
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines -= 1
+        return self.buffer.readline()
+
+    def flush(self):
+        if self.writable:
+            os.write(self._fd, self.buffer.getvalue())
+            self.buffer.truncate(0), self.buffer.seek(0)
+
+
+class IOWrapper(IOBase):
+    def __init__(self, file):
+        self.buffer = FastIO(file)
+        self.flush = self.buffer.flush
+        self.writable = self.buffer.writable
+        self.write = lambda s: self.buffer.write(s.encode("ascii"))
+        self.read = lambda: self.buffer.read().decode("ascii")
+        self.readline = lambda: self.buffer.readline().decode("ascii")
+
+
+sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
+
+
+# endregion
+
+
+def main():
+    t = int(input())
+    for _ in range(t):
+        n,m,i,j = ints()
+        print(*solve(n,m,i,j))
+
+
+def solve(n,m,i,j):
+    return (1, 1, n, m)
+
+if __name__ == "__main__":
+    main()
Index: Codeforces/Random/1557B.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Codeforces/Random/1557B.py b/Codeforces/Random/1557B.py
new file mode 100644
--- /dev/null	(date 1738365560059)
+++ b/Codeforces/Random/1557B.py	(date 1738365560059)
@@ -0,0 +1,146 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+from types import GeneratorType
+
+input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+
+# region fastio
+
+BUFSIZE = 8192
+
+
+class FastIO(IOBase):
+    newlines = 0
+
+    def __init__(self, file):
+        self._file = file
+        self._fd = file.fileno()
+        self.buffer = BytesIO()
+        self.writable = "x" in file.mode or "r" not in file.mode
+        self.write = self.buffer.write if self.writable else None
+
+    def read(self):
+        while True:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            if not b:
+                break
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines = 0
+        return self.buffer.read()
+
+    def readline(self):
+        while self.newlines == 0:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            self.newlines = b.count(b"\n") + (not b)
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines -= 1
+        return self.buffer.readline()
+
+    def flush(self):
+        if self.writable:
+            os.write(self._fd, self.buffer.getvalue())
+            self.buffer.truncate(0), self.buffer.seek(0)
+
+
+class IOWrapper(IOBase):
+    def __init__(self, file):
+        self.buffer = FastIO(file)
+        self.flush = self.buffer.flush
+        self.writable = self.buffer.writable
+        self.write = lambda s: self.buffer.write(s.encode("ascii"))
+        self.read = lambda: self.buffer.read().decode("ascii")
+        self.readline = lambda: self.buffer.readline().decode("ascii")
+
+
+#sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
+
+
+# endregion
+
+
+def main():
+    t = int(input())
+    for _ in range(t):
+        n, k = ints()
+        a = list(ints())
+        print(solve(n,k, a))
+
+
+def solve(n, k, a):
+    sorted_a = sorted(a)
+    index = {element: idx for idx, element in enumerate(sorted_a)}
+    ans = 1
+    for i in range(1, n):
+        if index[a[i]] != index[a[i - 1]] + 1:
+            ans += 1
+
+    return "YES" if k >= ans else "NO"
+
+if __name__ == "__main__":
+    main()
Index: Bootcamp/RPC 12 Nov/J.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Bootcamp/RPC 12 Nov/J.py b/Bootcamp/RPC 12 Nov/J.py
new file mode 100644
--- /dev/null	(date 1730574852585)
+++ b/Bootcamp/RPC 12 Nov/J.py	(date 1730574852585)
@@ -0,0 +1,11 @@
+n, m = map(int, input().split())
+a = list(map(int, input().split()))
+a.sort()
+if n != 2 * m:
+    a = ([0] * (2 * m - len(a))) + a
+ans = a[0]
+#print(a)
+for i in range(m):
+#    print(i, 2 * m - i-1)
+    ans = max(ans, a[i] + a[2 * m - i-1])
+print(ans)
\ No newline at end of file
Index: Codeforces/Random/1822A.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Codeforces/Random/1822A.py b/Codeforces/Random/1822A.py
new file mode 100644
--- /dev/null	(date 1738365560060)
+++ b/Codeforces/Random/1822A.py	(date 1738365560060)
@@ -0,0 +1,140 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+from types import GeneratorType
+
+input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+
+# region fastio
+
+BUFSIZE = 8192
+
+
+class FastIO(IOBase):
+    newlines = 0
+
+    def __init__(self, file):
+        self._file = file
+        self._fd = file.fileno()
+        self.buffer = BytesIO()
+        self.writable = "x" in file.mode or "r" not in file.mode
+        self.write = self.buffer.write if self.writable else None
+
+    def read(self):
+        while True:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            if not b:
+                break
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines = 0
+        return self.buffer.read()
+
+    def readline(self):
+        while self.newlines == 0:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            self.newlines = b.count(b"\n") + (not b)
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines -= 1
+        return self.buffer.readline()
+
+    def flush(self):
+        if self.writable:
+            os.write(self._fd, self.buffer.getvalue())
+            self.buffer.truncate(0), self.buffer.seek(0)
+
+
+class IOWrapper(IOBase):
+    def __init__(self, file):
+        self.buffer = FastIO(file)
+        self.flush = self.buffer.flush
+        self.writable = self.buffer.writable
+        self.write = lambda s: self.buffer.write(s.encode("ascii"))
+        self.read = lambda: self.buffer.read().decode("ascii")
+        self.readline = lambda: self.buffer.readline().decode("ascii")
+
+
+#sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
+
+
+# endregion
+
+
+def main():
+    t = int(input())
+    for _ in range(t):
+        n = int(input())
+        a = list(ints())
+        print(solve(n, a))
+
+
+def solve(n, a):
+    a.sort(reverse=True)
+    return max(a[0]*a[1], a[-1]*a[-2])
+
+if __name__ == "__main__":
+    main()
Index: Codeforces/Random/1467B.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Codeforces/Random/1467B.py b/Codeforces/Random/1467B.py
new file mode 100644
--- /dev/null	(date 1738365560058)
+++ b/Codeforces/Random/1467B.py	(date 1738365560058)
@@ -0,0 +1,153 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+from types import GeneratorType
+
+input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+
+# region fastio
+
+BUFSIZE = 8192
+
+
+class FastIO(IOBase):
+    newlines = 0
+
+    def __init__(self, file):
+        self._file = file
+        self._fd = file.fileno()
+        self.buffer = BytesIO()
+        self.writable = "x" in file.mode or "r" not in file.mode
+        self.write = self.buffer.write if self.writable else None
+
+    def read(self):
+        while True:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            if not b:
+                break
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines = 0
+        return self.buffer.read()
+
+    def readline(self):
+        while self.newlines == 0:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            self.newlines = b.count(b"\n") + (not b)
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines -= 1
+        return self.buffer.readline()
+
+    def flush(self):
+        if self.writable:
+            os.write(self._fd, self.buffer.getvalue())
+            self.buffer.truncate(0), self.buffer.seek(0)
+
+
+class IOWrapper(IOBase):
+    def __init__(self, file):
+        self.buffer = FastIO(file)
+        self.flush = self.buffer.flush
+        self.writable = self.buffer.writable
+        self.write = lambda s: self.buffer.write(s.encode("ascii"))
+        self.read = lambda: self.buffer.read().decode("ascii")
+        self.readline = lambda: self.buffer.readline().decode("ascii")
+
+
+#sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
+
+
+# endregion
+
+
+def main():
+    t = int(input())
+    for _ in range(t):
+        n = int(input())
+        a = list(ints())
+        print(solve(n, a))
+
+def isHV(a, i):
+    return (a[i-1] < a[i] and a[i] > a[i+1]) or (a[i-1] > a[i] and a[i] < a[i + 1])
+def solve(n, a):
+    ans, total_hv = 0, 0
+    a = [a[0]] + a + [a[n-1]]
+    for i in range(2, n):
+        value = a[i]
+        ans += isHV(a, i)
+        left = right = isHV(a, i-1) + isHV(a, i+1) + isHV(a, i)
+        a[i] = a[i-1]
+        left -= isHV(a, i + 1)
+        a[i] = a[i + 1]
+        right -= isHV(a, i-1)
+        a[i] = value
+        total_hv = max(left, max(right, total_hv))
+    return ans - total_hv
+
+
+if __name__ == "__main__":
+    main()
Index: Codeforces/Random/104736B.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Codeforces/Random/104736B.py b/Codeforces/Random/104736B.py
new file mode 100644
--- /dev/null	(date 1738365560057)
+++ b/Codeforces/Random/104736B.py	(date 1738365560057)
@@ -0,0 +1,141 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+from types import GeneratorType
+
+input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+
+# region fastio
+
+BUFSIZE = 8192
+
+
+class FastIO(IOBase):
+    newlines = 0
+
+    def __init__(self, file):
+        self._file = file
+        self._fd = file.fileno()
+        self.buffer = BytesIO()
+        self.writable = "x" in file.mode or "r" not in file.mode
+        self.write = self.buffer.write if self.writable else None
+
+    def read(self):
+        while True:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            if not b:
+                break
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines = 0
+        return self.buffer.read()
+
+    def readline(self):
+        while self.newlines == 0:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            self.newlines = b.count(b"\n") + (not b)
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines -= 1
+        return self.buffer.readline()
+
+    def flush(self):
+        if self.writable:
+            os.write(self._fd, self.buffer.getvalue())
+            self.buffer.truncate(0), self.buffer.seek(0)
+
+
+class IOWrapper(IOBase):
+    def __init__(self, file):
+        self.buffer = FastIO(file)
+        self.flush = self.buffer.flush
+        self.writable = self.buffer.writable
+        self.write = lambda s: self.buffer.write(s.encode("ascii"))
+        self.read = lambda: self.buffer.read().decode("ascii")
+        self.readline = lambda: self.buffer.readline().decode("ascii")
+
+
+sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
+
+
+# endregion
+
+
+def main():
+    n = int(input())
+    a = list(ints())
+    print(solve(n, a))
+
+
+
+def solve(n, a):
+    frec = Counter(a)
+    if any(it % 3 == 0 for it in frec.values()):
+        return "N"
+    return "Y"
+
+if __name__ == "__main__":
+    main()
Index: IEEE/c.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/IEEE/c.py b/IEEE/c.py
new file mode 100644
--- /dev/null	(date 1729953293253)
+++ b/IEEE/c.py	(date 1729953293253)
@@ -0,0 +1,10 @@
+from math import log
+n = int(input())
+ans = 1
+n_ = n
+while n_ > 1:
+    n_ //= 3
+    ans += 1
+
+ans -=1
+print(ans if 1 == n_ else -1)
\ No newline at end of file
Index: Bootcamp/ACM International Collegiate Programming Contest, JUST Collegiate Programming Contest (2018)/B. New Assignment.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Bootcamp/ACM International Collegiate Programming Contest, JUST Collegiate Programming Contest (2018)/B. New Assignment.py b/Bootcamp/ACM International Collegiate Programming Contest, JUST Collegiate Programming Contest (2018)/B. New Assignment.py
new file mode 100644
--- /dev/null	(date 1738365560049)
+++ b/Bootcamp/ACM International Collegiate Programming Contest, JUST Collegiate Programming Contest (2018)/B. New Assignment.py	(date 1738365560049)
@@ -0,0 +1,150 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+from types import GeneratorType
+
+input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+
+# region fastio
+
+BUFSIZE = 8192
+
+
+class FastIO(IOBase):
+    newlines = 0
+
+    def __init__(self, file):
+        self._file = file
+        self._fd = file.fileno()
+        self.buffer = BytesIO()
+        self.writable = "x" in file.mode or "r" not in file.mode
+        self.write = self.buffer.write if self.writable else None
+
+    def read(self):
+        while True:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            if not b:
+                break
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines = 0
+        return self.buffer.read()
+
+    def readline(self):
+        while self.newlines == 0:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            self.newlines = b.count(b"\n") + (not b)
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines -= 1
+        return self.buffer.readline()
+
+    def flush(self):
+        if self.writable:
+            os.write(self._fd, self.buffer.getvalue())
+            self.buffer.truncate(0), self.buffer.seek(0)
+
+
+class IOWrapper(IOBase):
+    def __init__(self, file):
+        self.buffer = FastIO(file)
+        self.flush = self.buffer.flush
+        self.writable = self.buffer.writable
+        self.write = lambda s: self.buffer.write(s.encode("ascii"))
+        self.read = lambda: self.buffer.read().decode("ascii")
+        self.readline = lambda: self.buffer.readline().decode("ascii")
+
+
+sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
+
+
+# endregion
+
+
+def main():
+    t = int(input())
+    for _ in range(t):
+        n = int(input())
+        a = list(ints())
+        b = list(strs())
+        print(solve(n, a, b))
+
+
+def solve(n, a, b):
+    males = sorted([(it, i) for i,it in enumerate(a) if b[i] == "M"])
+    females = sorted([(it, i) for i,it in enumerate(a) if b[i] == "F"])
+    ans = n
+    visited = [False] * int(n)
+    for m in males:
+        for f in females:
+            if not visited[f[1]] and gcd(m[0], f[0]) > 1:
+                ans-=1
+                visited[f[1]] = True
+                break
+    return ans
+
+if __name__ == "__main__":
+    main()
Index: Bootcamp/2020-2021 ICPC - Gran Premio de Mexico - Repechaje/B.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Bootcamp/2020-2021 ICPC - Gran Premio de Mexico - Repechaje/B.py b/Bootcamp/2020-2021 ICPC - Gran Premio de Mexico - Repechaje/B.py
new file mode 100644
--- /dev/null	(date 1738365560048)
+++ b/Bootcamp/2020-2021 ICPC - Gran Premio de Mexico - Repechaje/B.py	(date 1738365560048)
@@ -0,0 +1,165 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+from types import GeneratorType
+
+input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+
+# region fastio
+
+BUFSIZE = 8192
+
+
+class FastIO(IOBase):
+    newlines = 0
+
+    def __init__(self, file):
+        self._file = file
+        self._fd = file.fileno()
+        self.buffer = BytesIO()
+        self.writable = "x" in file.mode or "r" not in file.mode
+        self.write = self.buffer.write if self.writable else None
+
+    def read(self):
+        while True:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            if not b:
+                break
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines = 0
+        return self.buffer.read()
+
+    def readline(self):
+        while self.newlines == 0:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            self.newlines = b.count(b"\n") + (not b)
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines -= 1
+        return self.buffer.readline()
+
+    def flush(self):
+        if self.writable:
+            os.write(self._fd, self.buffer.getvalue())
+            self.buffer.truncate(0), self.buffer.seek(0)
+
+
+class IOWrapper(IOBase):
+    def __init__(self, file):
+        self.buffer = FastIO(file)
+        self.flush = self.buffer.flush
+        self.writable = self.buffer.writable
+        self.write = lambda s: self.buffer.write(s.encode("ascii"))
+        self.read = lambda: self.buffer.read().decode("ascii")
+        self.readline = lambda: self.buffer.readline().decode("ascii")
+
+
+sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
+
+
+# endregion
+
+
+def main():
+    n = int(input())
+    a = [list(ints()) for i in range(n)]
+    print(solve(n, a))
+
+
+def solve(n, a):
+    def same_line(points):
+        max_m = 0
+        for i in range(len(points)):
+            slopes = defaultdict(int)
+            duplicates = 1
+            (x1, y1) = points[i]
+            for j in range(i + 1, len(points)):
+                (x2, y2) = points[j]
+                dx = x2 - x1
+                dy = y2 - y1
+                if dx == 0 and dy == 0:
+                    duplicates += 1
+                elif dx == 0:
+                    slopes['inf'] += 1
+                elif dy == 0:
+                    slopes['0'] += 1
+                else:
+                    sign = -1 if (dx < 0) ^ (dy < 0) else 1
+                    dx, dy = abs(dx), abs(dy)
+                    g = gcd(dx, dy)
+                    slope = (sign * (dy // g), dx // g)
+                    slopes[slope] += 1
+            current_max = duplicates
+            for count in slopes.values():
+                current_max = max(current_max, count + duplicates)
+            max_m = max(max_m, current_max)
+        return max_m
+    same_line = same_line(a)
+    return min(n//3, n-same_line)
+
+if __name__ == "__main__":
+    main()
Index: Codeforces/Codeforces Round 997 (Div 2)/A.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Codeforces/Codeforces Round 997 (Div 2)/A.py b/Codeforces/Codeforces Round 997 (Div 2)/A.py
new file mode 100644
--- /dev/null	(date 1738365560055)
+++ b/Codeforces/Codeforces Round 997 (Div 2)/A.py	(date 1738365560055)
@@ -0,0 +1,140 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+from types import GeneratorType
+
+input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+
+# region fastio
+
+BUFSIZE = 8192
+
+
+class FastIO(IOBase):
+    newlines = 0
+
+    def __init__(self, file):
+        self._file = file
+        self._fd = file.fileno()
+        self.buffer = BytesIO()
+        self.writable = "x" in file.mode or "r" not in file.mode
+        self.write = self.buffer.write if self.writable else None
+
+    def read(self):
+        while True:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            if not b:
+                break
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines = 0
+        return self.buffer.read()
+
+    def readline(self):
+        while self.newlines == 0:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            self.newlines = b.count(b"\n") + (not b)
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines -= 1
+        return self.buffer.readline()
+
+    def flush(self):
+        if self.writable:
+            os.write(self._fd, self.buffer.getvalue())
+            self.buffer.truncate(0), self.buffer.seek(0)
+
+
+class IOWrapper(IOBase):
+    def __init__(self, file):
+        self.buffer = FastIO(file)
+        self.flush = self.buffer.flush
+        self.writable = self.buffer.writable
+        self.write = lambda s: self.buffer.write(s.encode("ascii"))
+        self.read = lambda: self.buffer.read().decode("ascii")
+        self.readline = lambda: self.buffer.readline().decode("ascii")
+
+
+sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
+
+
+# endregion
+
+
+def main():
+    t = int(input())
+    for _ in range(t):
+        n,m = ints()
+        a = [list(ints()) for i in range(n)]
+        print(solve(n, a, m))
+
+
+def solve(n, a, m):
+    return 4 * m + 2 * sum(sum(x) for x in a[1:])
+
+
+if __name__ == "__main__":
+    main()
Index: Codeforces/Codeforces Round 997 (Div 2)/B.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Codeforces/Codeforces Round 997 (Div 2)/B.py b/Codeforces/Codeforces Round 997 (Div 2)/B.py
new file mode 100644
--- /dev/null	(date 1738365560056)
+++ b/Codeforces/Codeforces Round 997 (Div 2)/B.py	(date 1738365560056)
@@ -0,0 +1,160 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+from types import GeneratorType
+
+input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+
+# region fastio
+
+BUFSIZE = 8192
+
+
+class FastIO(IOBase):
+    newlines = 0
+
+    def __init__(self, file):
+        self._file = file
+        self._fd = file.fileno()
+        self.buffer = BytesIO()
+        self.writable = "x" in file.mode or "r" not in file.mode
+        self.write = self.buffer.write if self.writable else None
+
+    def read(self):
+        while True:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            if not b:
+                break
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines = 0
+        return self.buffer.read()
+
+    def readline(self):
+        while self.newlines == 0:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            self.newlines = b.count(b"\n") + (not b)
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines -= 1
+        return self.buffer.readline()
+
+    def flush(self):
+        if self.writable:
+            os.write(self._fd, self.buffer.getvalue())
+            self.buffer.truncate(0), self.buffer.seek(0)
+
+
+class IOWrapper(IOBase):
+    def __init__(self, file):
+        self.buffer = FastIO(file)
+        self.flush = self.buffer.flush
+        self.writable = self.buffer.writable
+        self.write = lambda s: self.buffer.write(s.encode("ascii"))
+        self.read = lambda: self.buffer.read().decode("ascii")
+        self.readline = lambda: self.buffer.readline().decode("ascii")
+
+
+sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
+
+
+# endregion
+
+
+def main():
+    t = int(input())
+    for _ in range(t):
+        n = int(input())
+        a = [input() for i in range(n)]
+        print(solve(n, a))
+
+
+def solve(n, a):
+    #print(a)
+    AL = [[] for _ in range(n + 1)]
+    in_degree = [0] * (n + 1)
+    for x, row in enumerate(a, 1):
+        for y in range(x + 1, n + 1):
+            if row[y - 1] == '1':
+                AL[x].append(y)
+                in_degree[y] += 1
+            else:
+                AL[y].append(x)
+                in_degree[x] += 1
+    q = deque(x for x in range(1, n + 1) if in_degree[x] == 0)
+    ans = []
+    while q:
+        u = q.popleft()
+        ans.append(u)
+        for v in AL[u]:
+            in_degree[v] -= 1
+            if in_degree[v] == 0:
+                q.append(v)
+
+    return " ".join(map(str, ans))
+
+if __name__ == "__main__":
+    main()
Index: Codeforces/Codeforces Round 997 (Div 2)/C.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Codeforces/Codeforces Round 997 (Div 2)/C.py b/Codeforces/Codeforces Round 997 (Div 2)/C.py
new file mode 100644
--- /dev/null	(date 1738365560056)
+++ b/Codeforces/Codeforces Round 997 (Div 2)/C.py	(date 1738365560056)
@@ -0,0 +1,139 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+from types import GeneratorType
+
+input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+
+# region fastio
+
+BUFSIZE = 8192
+
+
+class FastIO(IOBase):
+    newlines = 0
+
+    def __init__(self, file):
+        self._file = file
+        self._fd = file.fileno()
+        self.buffer = BytesIO()
+        self.writable = "x" in file.mode or "r" not in file.mode
+        self.write = self.buffer.write if self.writable else None
+
+    def read(self):
+        while True:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            if not b:
+                break
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines = 0
+        return self.buffer.read()
+
+    def readline(self):
+        while self.newlines == 0:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            self.newlines = b.count(b"\n") + (not b)
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines -= 1
+        return self.buffer.readline()
+
+    def flush(self):
+        if self.writable:
+            os.write(self._fd, self.buffer.getvalue())
+            self.buffer.truncate(0), self.buffer.seek(0)
+
+
+class IOWrapper(IOBase):
+    def __init__(self, file):
+        self.buffer = FastIO(file)
+        self.flush = self.buffer.flush
+        self.writable = self.buffer.writable
+        self.write = lambda s: self.buffer.write(s.encode("ascii"))
+        self.read = lambda: self.buffer.read().decode("ascii")
+        self.readline = lambda: self.buffer.readline().decode("ascii")
+
+
+sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
+
+
+# endregion
+
+
+def main():
+    t = int(input())
+    for _ in range(t):
+        n = int(input())
+        print(solve(n))
+
+
+def solve(n):
+    ans = [1] + [i-1 for i in range(2 , n-2+1)] + [1, 2]
+    return " ".join(map(str, ans))
+
+if __name__ == "__main__":
+    main()
Index: Codeforces/Codeforces Round 997 (Div 2)/D.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Codeforces/Codeforces Round 997 (Div 2)/D.py b/Codeforces/Codeforces Round 997 (Div 2)/D.py
new file mode 100644
--- /dev/null	(date 1738365560056)
+++ b/Codeforces/Codeforces Round 997 (Div 2)/D.py	(date 1738365560056)
@@ -0,0 +1,171 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+from types import GeneratorType
+
+input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+
+# region fastio
+
+BUFSIZE = 8192
+
+
+class FastIO(IOBase):
+    newlines = 0
+
+    def __init__(self, file):
+        self._file = file
+        self._fd = file.fileno()
+        self.buffer = BytesIO()
+        self.writable = "x" in file.mode or "r" not in file.mode
+        self.write = self.buffer.write if self.writable else None
+
+    def read(self):
+        while True:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            if not b:
+                break
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines = 0
+        return self.buffer.read()
+
+    def readline(self):
+        while self.newlines == 0:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            self.newlines = b.count(b"\n") + (not b)
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines -= 1
+        return self.buffer.readline()
+
+    def flush(self):
+        if self.writable:
+            os.write(self._fd, self.buffer.getvalue())
+            self.buffer.truncate(0), self.buffer.seek(0)
+
+
+class IOWrapper(IOBase):
+    def __init__(self, file):
+        self.buffer = FastIO(file)
+        self.flush = self.buffer.flush
+        self.writable = self.buffer.writable
+        self.write = lambda s: self.buffer.write(s.encode("ascii"))
+        self.read = lambda: self.buffer.read().decode("ascii")
+        self.readline = lambda: self.buffer.readline().decode("ascii")
+
+
+sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
+
+
+# endregion
+
+def ok(total, freq, k):
+    first_med = None
+    second_med = None
+    for x in range(1, 11):
+        if first_med is None and total[x] >= k:
+            first_med = x
+        if second_med is None and total[x] >= k + 1:
+            second_med = x
+        if first_med is not None and second_med is not None:
+            break
+    return first_med == second_med
+
+def main():
+    t = int(input())
+    res = []
+    for _ in range(t):
+        n = int(input())
+        a = list(ints())
+        res.append(solve(n, a))
+    print("\n".join(res))
+
+def solve(n, a):
+    count_odd = sum(n - m + 1 for m in range(1, n + 1, 2))
+    count_even = 0
+    for m in range(2, n + 1, 2):
+        k = m // 2
+        freq = [0] * 11
+        for i in range(m):
+            freq[a[i]] += 1
+        total = [0] * 11
+        for x in range(1, 11):
+            total[x] = total[x - 1] + freq[x]
+        if ok(total, freq, k):
+            count_even += 1
+        for l in range(1, n - m + 1):
+            freq[a[l - 1]] -= 1
+            freq[a[l + m - 1]] += 1
+            total = [0] * 11
+            for x in range(1, 11):
+                total[x] = total[x - 1] + freq[x]
+            if ok(total, freq, k):
+                count_even += 1
+    return str(count_odd + count_even)
+
+if __name__ == "__main__":
+    main()
Index: Codeforces/Random/1454C.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Codeforces/Random/1454C.py b/Codeforces/Random/1454C.py
new file mode 100644
--- /dev/null	(date 1738365560058)
+++ b/Codeforces/Random/1454C.py	(date 1738365560058)
@@ -0,0 +1,145 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+from types import GeneratorType
+
+input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+
+# region fastio
+
+BUFSIZE = 8192
+
+
+class FastIO(IOBase):
+    newlines = 0
+
+    def __init__(self, file):
+        self._file = file
+        self._fd = file.fileno()
+        self.buffer = BytesIO()
+        self.writable = "x" in file.mode or "r" not in file.mode
+        self.write = self.buffer.write if self.writable else None
+
+    def read(self):
+        while True:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            if not b:
+                break
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines = 0
+        return self.buffer.read()
+
+    def readline(self):
+        while self.newlines == 0:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            self.newlines = b.count(b"\n") + (not b)
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines -= 1
+        return self.buffer.readline()
+
+    def flush(self):
+        if self.writable:
+            os.write(self._fd, self.buffer.getvalue())
+            self.buffer.truncate(0), self.buffer.seek(0)
+
+
+class IOWrapper(IOBase):
+    def __init__(self, file):
+        self.buffer = FastIO(file)
+        self.flush = self.buffer.flush
+        self.writable = self.buffer.writable
+        self.write = lambda s: self.buffer.write(s.encode("ascii"))
+        self.read = lambda: self.buffer.read().decode("ascii")
+        self.readline = lambda: self.buffer.readline().decode("ascii")
+
+
+sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
+
+
+# endregion
+
+
+def main():
+    t = int(input())
+    for _ in range(t):
+        n = int(input())
+        a = list(ints())
+        print(solve(n, a))
+
+
+def solve(n, a):
+    a = a + [-INF]
+    a = [a[i] for i in range(n) if a[i] != a[i+1]]
+    frec = Counter(a)
+    frec[a[0]] -= 1
+    frec[a[-1]] -= 1
+    return min([val + 1 for ky, val in frec.items()])
+
+
+if __name__ == "__main__":
+    main()
Index: Codeforces/Random/1811C.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Codeforces/Random/1811C.py b/Codeforces/Random/1811C.py
new file mode 100644
--- /dev/null	(date 1738365560060)
+++ b/Codeforces/Random/1811C.py	(date 1738365560060)
@@ -0,0 +1,144 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+from types import GeneratorType
+
+input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+
+# region fastio
+
+BUFSIZE = 8192
+
+
+class FastIO(IOBase):
+    newlines = 0
+
+    def __init__(self, file):
+        self._file = file
+        self._fd = file.fileno()
+        self.buffer = BytesIO()
+        self.writable = "x" in file.mode or "r" not in file.mode
+        self.write = self.buffer.write if self.writable else None
+
+    def read(self):
+        while True:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            if not b:
+                break
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines = 0
+        return self.buffer.read()
+
+    def readline(self):
+        while self.newlines == 0:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            self.newlines = b.count(b"\n") + (not b)
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines -= 1
+        return self.buffer.readline()
+
+    def flush(self):
+        if self.writable:
+            os.write(self._fd, self.buffer.getvalue())
+            self.buffer.truncate(0), self.buffer.seek(0)
+
+
+class IOWrapper(IOBase):
+    def __init__(self, file):
+        self.buffer = FastIO(file)
+        self.flush = self.buffer.flush
+        self.writable = self.buffer.writable
+        self.write = lambda s: self.buffer.write(s.encode("ascii"))
+        self.read = lambda: self.buffer.read().decode("ascii")
+        self.readline = lambda: self.buffer.readline().decode("ascii")
+
+
+#sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
+
+
+# endregion
+
+
+def main():
+    t = int(input())
+    for _ in range(t):
+        n = int(input())
+        a = list(ints())
+        print(solve(n, a))
+
+
+def solve(n, a):
+    index = -1
+    #print(a)
+    ans = [a[0]]
+    for i in range(1, n-1):
+        ans.append(min(a[i-1], a[i]))
+    ans.append(a[-1])
+    return " ".join(map(str, ans))
+if __name__ == "__main__":
+    main()
Index: Codeforces/Random/1807E.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Codeforces/Random/1807E.py b/Codeforces/Random/1807E.py
new file mode 100644
--- /dev/null	(date 1738365560059)
+++ b/Codeforces/Random/1807E.py	(date 1738365560059)
@@ -0,0 +1,38 @@
+import os
+import sys
+from itertools import accumulate
+from io import BytesIO, IOBase
+from types import GeneratorType
+
+input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+def main():
+    t = int(input())
+    for _ in range(t):
+        n = int(input())
+        a = list(map(int, input().split()))
+        solve(n, a)
+
+def solve(n, a):
+    prefix_sum = [0] + list(accumulate(a))
+    lo = 0
+    hi = n
+    while lo < hi:
+        mid = (lo + hi) // 2
+        piles = [it + 1 for it in range(lo, mid + 1)]
+        k = len(piles)
+        print("?", k, *piles)
+        ans = int(input())
+        expected = prefix_sum[mid + 1] - prefix_sum[lo]
+        if ans == expected:
+            lo = mid + 1
+        else:
+            hi = mid
+    print("!", lo + 1)
+
+if __name__ == "__main__":
+    main()
\ No newline at end of file
Index: Codeforces/Codeforces Round 640 (Div 4)/G.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Codeforces/Codeforces Round 640 (Div 4)/G.py b/Codeforces/Codeforces Round 640 (Div 4)/G.py
new file mode 100644
--- /dev/null	(date 1738365560051)
+++ b/Codeforces/Codeforces Round 640 (Div 4)/G.py	(date 1738365560051)
@@ -0,0 +1,162 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+from types import GeneratorType
+
+input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+
+# region fastio
+
+BUFSIZE = 8192
+
+
+class FastIO(IOBase):
+    newlines = 0
+
+    def __init__(self, file):
+        self._file = file
+        self._fd = file.fileno()
+        self.buffer = BytesIO()
+        self.writable = "x" in file.mode or "r" not in file.mode
+        self.write = self.buffer.write if self.writable else None
+
+    def read(self):
+        while True:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            if not b:
+                break
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines = 0
+        return self.buffer.read()
+
+    def readline(self):
+        while self.newlines == 0:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            self.newlines = b.count(b"\n") + (not b)
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines -= 1
+        return self.buffer.readline()
+
+    def flush(self):
+        if self.writable:
+            os.write(self._fd, self.buffer.getvalue())
+            self.buffer.truncate(0), self.buffer.seek(0)
+
+
+class IOWrapper(IOBase):
+    def __init__(self, file):
+        self.buffer = FastIO(file)
+        self.flush = self.buffer.flush
+        self.writable = self.buffer.writable
+        self.write = lambda s: self.buffer.write(s.encode("ascii"))
+        self.read = lambda: self.buffer.read().decode("ascii")
+        self.readline = lambda: self.buffer.readline().decode("ascii")
+
+
+#sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
+
+
+# endregion
+
+
+def main():
+    t = int(input())
+    for _ in range(t):
+        n = int(input())
+        print(solve(n))
+
+
+def solve(n):
+    if n <= 3: return -1
+    ans = []
+    visited  = set()
+    if n & 1:
+        for i in range(1, n + 1, 2):
+            ans.append(i)
+            visited.add(i)
+        if ans[-1] == n:
+            if n-3 > 0: ans.append(n - 3)
+            ans.append(n - 1)
+            for i in range(n - 4, 1, -1):
+                if i not in visited:
+                    ans.append(i)
+    else:
+        for i in range(2, n + 1, 2):
+            ans.append(i)
+            visited.add(i)
+        if ans[-1] == n:
+            ans.append(n - 3)
+            ans.append(n - 1)
+            for i in range(n - 4, 0, -1):
+                if i not in visited:
+                    ans.append(i)
+
+    return " ".join(map(str, ans))
+
+if __name__ == "__main__":
+    main()
Index: Codeforces/Codeforces Round 776 (Div. 3/G.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Codeforces/Codeforces Round 776 (Div. 3/G.py b/Codeforces/Codeforces Round 776 (Div. 3/G.py
new file mode 100644
--- /dev/null	(date 1738365560051)
+++ b/Codeforces/Codeforces Round 776 (Div. 3/G.py	(date 1738365560051)
@@ -0,0 +1,161 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+from types import GeneratorType
+
+input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+
+# region fastio
+
+BUFSIZE = 8192
+
+
+class FastIO(IOBase):
+    newlines = 0
+
+    def __init__(self, file):
+        self._file = file
+        self._fd = file.fileno()
+        self.buffer = BytesIO()
+        self.writable = "x" in file.mode or "r" not in file.mode
+        self.write = self.buffer.write if self.writable else None
+
+    def read(self):
+        while True:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            if not b:
+                break
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines = 0
+        return self.buffer.read()
+
+    def readline(self):
+        while self.newlines == 0:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            self.newlines = b.count(b"\n") + (not b)
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines -= 1
+        return self.buffer.readline()
+
+    def flush(self):
+        if self.writable:
+            os.write(self._fd, self.buffer.getvalue())
+            self.buffer.truncate(0), self.buffer.seek(0)
+
+
+class IOWrapper(IOBase):
+    def __init__(self, file):
+        self.buffer = FastIO(file)
+        self.flush = self.buffer.flush
+        self.writable = self.buffer.writable
+        self.write = lambda s: self.buffer.write(s.encode("ascii"))
+        self.read = lambda: self.buffer.read().decode("ascii")
+        self.readline = lambda: self.buffer.readline().decode("ascii")
+
+
+sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
+
+
+# endregion
+
+
+def main():
+    t = int(input())
+    for _ in range(t):
+        input()
+        n, m = ints()
+        AL = [[] for i in range(n + 1)]
+        s, t = ints()
+        for i in range(m):
+            u, v = ints()
+            AL[u].append(v)
+            AL[v].append(u)
+        d = [INF] * (n + 1)
+        s_p = [0] * (n+1)
+        s_p1 = [0] * (n+1)
+        q = deque()
+
+        d[s] = 0
+        s_p[s] = 1
+        s_p1[s] = 0
+        q.append(s)
+        while q:
+            u = q.popleft()
+            for v in AL[u]:
+                if d[u] + 1 < d[v]:
+                    s_p[v], s_p1[v] =  0, 0
+                    d[v] = d[u] + 1
+                    q.append(v)
+                if d[u]+1 == d[v]: s_p[v] += s_p[u] % MOD
+                if d[v]+1 == d[u]: s_p1[u] += s_p1[v] % MOD
+                if d[v] + 1== d[u] + 1: s_p1[u] += s_p[v] % MOD
+        #print(d)
+        print((s_p[t] + s_p1[t]) % MOD)
+
+if __name__ == "__main__":
+    main()
Index: Codeforces/Codeforces Round 776 (Div. 3/F.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Codeforces/Codeforces Round 776 (Div. 3/F.py b/Codeforces/Codeforces Round 776 (Div. 3/F.py
new file mode 100644
--- /dev/null	(date 1738365560051)
+++ b/Codeforces/Codeforces Round 776 (Div. 3/F.py	(date 1738365560051)
@@ -0,0 +1,178 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+from types import GeneratorType
+
+input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+
+# region fastio
+
+BUFSIZE = 8192
+
+
+class FastIO(IOBase):
+    newlines = 0
+
+    def __init__(self, file):
+        self._file = file
+        self._fd = file.fileno()
+        self.buffer = BytesIO()
+        self.writable = "x" in file.mode or "r" not in file.mode
+        self.write = self.buffer.write if self.writable else None
+
+    def read(self):
+        while True:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            if not b:
+                break
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines = 0
+        return self.buffer.read()
+
+    def readline(self):
+        while self.newlines == 0:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            self.newlines = b.count(b"\n") + (not b)
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines -= 1
+        return self.buffer.readline()
+
+    def flush(self):
+        if self.writable:
+            os.write(self._fd, self.buffer.getvalue())
+            self.buffer.truncate(0), self.buffer.seek(0)
+
+
+class IOWrapper(IOBase):
+    def __init__(self, file):
+        self.buffer = FastIO(file)
+        self.flush = self.buffer.flush
+        self.writable = self.buffer.writable
+        self.write = lambda s: self.buffer.write(s.encode("ascii"))
+        self.read = lambda: self.buffer.read().decode("ascii")
+        self.readline = lambda: self.buffer.readline().decode("ascii")
+
+
+#sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
+
+
+# endregion
+
+
+def main():
+    t = int(input())
+    for _ in range(t):
+        n, k = ints()
+        a = list(ints())
+        print(solve(n, a, k))
+
+
+def solve(n, a, k):
+    options = [[] for i in range(n+ 1)]
+    for i in range(k):
+        u, t, p = ints()
+        options[u].append((t, p, i))
+    now = 0
+    ans = []
+    #print(options)
+    for idx, option in enumerate(options[1:]):
+        s = len(option)
+        #print(option)
+        @lru_cache(None)
+        def dp(i, ans):
+            if ans >= 100:
+                return (0, [])
+            if s == i:
+                return (INF, [])
+            t, p, opt_id = option[i]
+            new_ans = min(ans + p, 100)
+            time_incl, path_incl = dp(i + 1, new_ans)
+            if time_incl != INF:
+                time_incl += t
+                path_incl = path_incl + [opt_id]
+            else:
+                path_incl = []
+
+            time_excl, path_excl = dp(i+1, ans)
+            if time_incl < time_excl:
+                return (time_incl, path_incl)
+            else:
+                return (time_excl, path_excl)
+        min_time, local_ans = dp(0, 0)
+        #print(min_time)
+        if min_time == INF:
+            return -1
+        now += min_time
+        if now > a[idx]:
+            return -1
+        ans += local_ans
+    print(len(ans))
+    return " ".join(map(str, [it + 1 for it in ans]))
+
+if __name__ == "__main__":
+    main()
Index: USACO GUIDE/GOLD/Shortest Paths with Unweighted Edges/LasersAndMirrors.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/USACO GUIDE/GOLD/Shortest Paths with Unweighted Edges/LasersAndMirrors.py b/USACO GUIDE/GOLD/Shortest Paths with Unweighted Edges/LasersAndMirrors.py
new file mode 100644
--- /dev/null	(date 1726880910680)
+++ b/USACO GUIDE/GOLD/Shortest Paths with Unweighted Edges/LasersAndMirrors.py	(date 1726880910680)
@@ -0,0 +1,80 @@
+import sys
+import math
+import random
+from collections import defaultdict
+
+
+def main():
+    input = sys.stdin.read
+    data = input().split()
+
+    index = 0
+    T = int(data[index])
+    index += 1
+    results = []
+
+    for case_num in range(1, T + 1):
+        N = int(data[index])
+        index += 1
+        points = []
+
+        for _ in range(N):
+            x, y = int(data[index]), int(data[index + 1])
+            points.append((x, y))
+            index += 2
+
+        if N <= 2:
+            answer = 0
+        else:
+            line_counts = defaultdict(int)
+            K = min(5000, N * (N - 1) // 2)  # Number of random pairs
+
+            # Precompute random pairs
+            pairs = set()
+            while len(pairs) < K:
+                i, j = random.sample(range(N), 2)
+                pairs.add((i, j))
+
+            for i, j in pairs:
+                x1, y1 = points[i]
+                x2, y2 = points[j]
+
+                A = y2 - y1
+                B = x1 - x2
+                C = x2 * y1 - x1 * y2
+
+                # Normalize the coefficients
+                gcd = math.gcd(A, math.gcd(B, C))
+                if gcd != 0:
+                    A //= gcd
+                    B //= gcd
+                    C //= gcd
+
+                # Ensure the first non-zero coefficient is positive
+                if A < 0 or (A == 0 and B < 0):
+                    A *= -1
+                    B *= -1
+                    C *= -1
+
+                line_key = (A, B, C)
+                line_counts[line_key] += 1
+
+            # Get the top L lines
+            L = 10
+            top_lines = sorted(line_counts.items(), key=lambda x: -x[1])[:L]
+
+            max_count = 0
+            for line, _ in top_lines:
+                A, B, C = line
+                count = sum(1 for x, y in points if A * x + B * y + C == 0)
+                max_count = max(max_count, count)
+
+            answer = N - max_count
+
+        results.append(f"Case #{case_num}: {answer}")
+
+    sys.stdout.write("\n".join(results) + "\n")
+
+
+if __name__ == "__main__":
+    main()
Index: Codeforces/Codeforces Global Round 27/C.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Codeforces/Codeforces Global Round 27/C.py b/Codeforces/Codeforces Global Round 27/C.py
new file mode 100644
--- /dev/null	(date 1730411323105)
+++ b/Codeforces/Codeforces Global Round 27/C.py	(date 1730411323105)
@@ -0,0 +1,94 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+
+input = lambda: sys.stdin.readline().strip()
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+
+def ints(): return map(int, input().split())
+
+
+def strs(): return input().split()
+
+
+def chars(): return list(input().strip())
+
+
+def mat(n): return [list(ints()) for _ in range(n)]
+
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+
+def add(x, y, mod=MOD): return (x + y) % mod
+
+
+def sub(x, y, mod=MOD): return (x - y) % mod
+
+
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+
+RANDOM = getrandbits(32)
+
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+def main():
+    t = int(input())
+    for _ in range(t):
+        n = int(input())
+        a = [0] * n
+        if n & 1:
+            print(n)
+            a[n - 1], a[n - 2], a[n - 3], a[n - 4] = n, n - (n & (-n)), ((n & (-n)) + (2 if n & (-n) == 1 else 1)), n & (-n)
+        else:
+            pow_ = 2 ** n.bit_length() - 1
+            print(pow_, )
+            if n == 2 ** (n.bit_length() - 1):
+                a[n - 1], a[n - 2], a[n - 3], a[n - 4], a[n - 5] = n, n - 1, n - 2, 3, 1
+            else:
+                a[n - 1], a[n - 2], a[n - 3] = 2 ** (n.bit_length() - 1) - 1, n - 1, n
+
+        mapper = Counter(a)
+        index = 0
+        for i in range(1, n + 1):
+            if i not in mapper:
+                a[index] = i
+                index += 1
+        print(*a)
+
+
+if __name__ == "__main__":
+    main()
Index: Codeforces/Codeforces Round 981 (Div 3)/A.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Codeforces/Codeforces Round 981 (Div 3)/A.py b/Codeforces/Codeforces Round 981 (Div 3)/A.py
new file mode 100644
--- /dev/null	(date 1730238488153)
+++ b/Codeforces/Codeforces Round 981 (Div 3)/A.py	(date 1730238488153)
@@ -0,0 +1,70 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+
+input = lambda: sys.stdin.readline().strip()
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+def main():
+    t = int(input())
+    for _ in range(t):
+        n = int(input())
+        ans = -1
+        negative = False
+        curr = 2
+        for i in range(2, 1000):
+            if abs(ans) > abs(n):
+                break
+            ans += (2 * i-1) * (-1 if negative else 1)
+            negative = not negative
+        print("Sakurako" if ans < 0 else "Kosuke")
+
+
+def solve(n ,a ):
+    pass
+
+
+
+if __name__ == "__main__":
+    main()
Index: Bootcamp/2022-2023 ACM-ICPC Latin American Regional Programming Contest/E. Empty Squares.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Bootcamp/2022-2023 ACM-ICPC Latin American Regional Programming Contest/E. Empty Squares.py b/Bootcamp/2022-2023 ACM-ICPC Latin American Regional Programming Contest/E. Empty Squares.py
new file mode 100644
--- /dev/null	(date 1730942321983)
+++ b/Bootcamp/2022-2023 ACM-ICPC Latin American Regional Programming Contest/E. Empty Squares.py	(date 1730942321983)
@@ -0,0 +1,78 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+
+input = lambda: sys.stdin.readline().strip()
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+def main():
+    n, k, e = ints()
+    mapper = defaultdict(int)
+    for it in range(1, n + 1):
+        mapper[it] = (it) // 2 if it % 2 == 0 else (it + 1) // 2
+    for i in range(k, n + 1):
+        if k + k == i:
+            continue
+        mapper[i] -= 1
+    r = n - (e + k)
+    if mapper[e] == 0 and e != 0:
+        e-=1
+    if e!= 0:
+        for i in range(e, n+1):
+            if e + e == i or e + k == i:
+                continue
+            mapper[i] -= 1
+    ans = r
+    for i in range(r, -1, -1):
+        ans = i
+        if mapper[i] > 0:
+            break
+    assert (n - k - e - ans) <= 3
+    print(n - k - e - ans)
+
+
+
+
+if __name__ == "__main__":
+    main()
Index: Codeforces/Codeforces Round 981 (Div 3)/D.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Codeforces/Codeforces Round 981 (Div 3)/D.py b/Codeforces/Codeforces Round 981 (Div 3)/D.py
new file mode 100644
--- /dev/null	(date 1730245449237)
+++ b/Codeforces/Codeforces Round 981 (Div 3)/D.py	(date 1730245449237)
@@ -0,0 +1,81 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+
+input = lambda: sys.stdin.readline().strip()
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+def main():
+    t = int(input())
+    for _ in range(t):
+        n = int(input())
+        a = list(ints())
+        print(solve(n, a))
+
+
+def solve(n ,a ):
+    sum_map = dict()
+    wx = Wrapper(0)
+    sum_map[wx] = 0
+    sum_so_far = 0
+    max_segments = 0
+    last_segment_end = -1
+    for j in range(n):
+        sum_so_far += a[j]
+
+        if Wrapper(sum_so_far) not in sum_map:
+            wx = Wrapper(sum_so_far)
+            sum_map[wx] = j
+        else:
+            wx = Wrapper(sum_so_far)
+            if sum_map[wx] >= last_segment_end:
+                max_segments += 1
+                last_segment_end = j
+            wx = Wrapper(sum_so_far)
+            sum_map[wx] = max(sum_map[wx], j)
+    return max_segments
+
+
+if __name__ == "__main__":
+    main()
Index: USACO GUIDE/SILVER/Binary Seach/AngryCows.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/USACO GUIDE/SILVER/Binary Seach/AngryCows.py b/USACO GUIDE/SILVER/Binary Seach/AngryCows.py
new file mode 100644
--- /dev/null	(date 1727492191411)
+++ b/USACO GUIDE/SILVER/Binary Seach/AngryCows.py	(date 1727492191411)
@@ -0,0 +1,139 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+
+input = lambda: sys.stdin.readline().strip()
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+def can(a, r, index):
+    if a[index] - a[index - 1] > r * 2:
+        return False
+    n = len(a)
+    # Explosión hacia la derecha
+    radio = r - 1
+    posicion = a[index]
+    i = index
+    while radio > 0:
+        j = i
+        # Avanzar lo más posible dentro del radio actual
+        while j + 1 < n and a[j + 1] - posicion <= radio:
+            j += 1
+        if j == i:
+            print("I BREACK XD", posicion, a[j], radio)
+            break  # No se puede avanzar más hacia la derecha
+        posicion = a[j]
+        radio -= 1
+        i = j
+    if i != n - 1:
+        print("Return 1", i, index, radio)
+        return False  # No se alcanzó el último heno a la derecha
+
+    # Explosión hacia la izquierda
+    radio = r - 1
+    posicion = a[index - 1]
+    i = index - 1
+    while radio > 0:
+        j = i
+        # Avanzar lo más posible dentro del radio actual
+        while j - 1 >= 0 and posicion - a[j - 1] <= radio:
+            j -= 1
+        if j == i:
+            break  # No se puede avanzar más hacia la izquierda
+        posicion = a[j]
+        radio -= 1
+        i = j
+    if i != 0:
+        print("Return 2")
+        return False  # No se alcanzó el primer heno a la izquierda
+
+    return True  # Se alcanzaron todos los henos
+
+def main():
+    #sys.stdin = open('angry.in', 'r')
+    #sys.stdout = open('angry.out', 'w')
+    n = int(input())
+    a = []
+    for i in range(n):
+        a.append(int(input()))
+    a.sort()
+    cur_max = 0
+    x1, x2 = 0, 0
+    index_t = -1
+    for i in range(n-1):
+        if a[i+1] - a[i] >= cur_max:
+            index_t = i + 1
+            cur_max = a[i+1] - a[i]
+            x1 = a[i]
+            x2 = a[i+1]
+    #print(x1,  x2)
+    target = (x2 + x1) / 2
+
+    q = [0] * n
+    for i in range(n):
+        if a[i] > target:
+            q[i] = i - index_t
+        else:
+            q[i] = abs(i - index_t) - 1
+    print(q)
+
+    print(can(a, 24197.0, index_t))
+    print(a[15121:15124])
+    """lo, hi = 0, a[-1] + 1
+    for i in range(1000):
+        delta = (hi - lo) / 3
+        m1 = lo + delta
+        m2 = hi - delta
+        if can(a, m1, index_t):
+            hi = m2
+        else:
+            lo = m1
+
+    print(round(hi, 1), lo)"""
+
+
+
+
+if __name__ == "__main__":
+    main()
Index: USACO GUIDE/GOLD/Euler Phi/Light-OJ - Mathematically Hard.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/USACO GUIDE/GOLD/Euler Phi/Light-OJ - Mathematically Hard.py b/USACO GUIDE/GOLD/Euler Phi/Light-OJ - Mathematically Hard.py
new file mode 100644
--- /dev/null	(date 1729398960070)
+++ b/USACO GUIDE/GOLD/Euler Phi/Light-OJ - Mathematically Hard.py	(date 1729398960070)
@@ -0,0 +1,91 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+
+input = lambda: sys.stdin.readline().strip()
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+def phi_1_to_n(n):
+    phi = list(range(n + 1))
+
+    for i in range(2, n + 1):
+        if phi[i] == i:
+            for j in range(i, n + 1, i):
+                phi[j] -= phi[j] // i
+
+    return phi
+
+
+def compute_totients_and_scores(max_n):
+    phi = list(range(max_n + 1))
+    score_sum = [0] * (max_n + 1)
+
+    for i in range(2, max_n + 1):
+        if phi[i] == i:  # i is a prime
+            for j in range(i, max_n + 1, i):
+                phi[j] *= (i - 1)
+                phi[j] //= i
+
+    for i in range(2, max_n + 1):
+        score = phi[i] * phi[i]
+        score_sum[i] = score_sum[i - 1] + score
+
+    return score_sum
+
+def main():
+    t = int(input())
+    score_sum = compute_totients_and_scores(10000000 + 5)
+    ans = []
+    for _ in range(t):
+        a,b = ints()
+
+        #print(phi[a:b+1])
+        ans.append(f"Case {_+1}: {score_sum[b] - score_sum[a - 1]}")
+    print('\n'.join(ans))
+
+
+
+if __name__ == "__main__":
+    main()
Index: Bootcamp/2022-2023 ACM-ICPC Latin American Regional Programming Contest/I. Italian Calzone & Pasta Corner.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Bootcamp/2022-2023 ACM-ICPC Latin American Regional Programming Contest/I. Italian Calzone & Pasta Corner.py b/Bootcamp/2022-2023 ACM-ICPC Latin American Regional Programming Contest/I. Italian Calzone & Pasta Corner.py
new file mode 100644
--- /dev/null	(date 1730935887510)
+++ b/Bootcamp/2022-2023 ACM-ICPC Latin American Regional Programming Contest/I. Italian Calzone & Pasta Corner.py	(date 1730935887510)
@@ -0,0 +1,121 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+
+input = lambda: sys.stdin.readline().strip()
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+
+def ints(): return map(int, input().split())
+
+
+def strs(): return input().split()
+
+
+def chars(): return list(input().strip())
+
+
+def mat(n): return [list(ints()) for _ in range(n)]
+
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+
+def add(x, y, mod=MOD): return (x + y) % mod
+
+
+def sub(x, y, mod=MOD): return (x - y) % mod
+
+
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+
+RANDOM = getrandbits(32)
+
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+total_cc = 0
+visited = []
+AL = []
+
+class BitArray:
+    """implements bitarray using bytearray"""
+    def __init__(self, size):
+        self.bytes = bytearray((size >> 3) + 1)
+
+    def __getitem__(self, index):
+        return (self.bytes[index >> 3] >> (index & 7)) & 1
+
+    def __setitem__(self, index, value):
+        if value:
+            self.bytes[index >> 3] |= 1 << (index & 7)
+        else:
+            self.bytes[index >> 3] &= ~(1 << (index & 7))
+
+
+def dfs(u):
+    global visited, total_cc, memo
+    visited[u] = 1
+    ans = 1
+    for v in AL[u]:
+        if not visited[v]:
+            ans += dfs(v)
+    return ans
+
+def main():
+    global visited, total_cc, AL
+    n, m = ints()
+    mx = [list(ints()) for i in range(n)]
+    AL = [[] for i in range(n * m + 5)]
+    for i in range(n):
+        for j in range(m):
+            if i < n - 1:
+                if mx[i][j] < mx[i + 1][j]:
+                    AL[mx[i][j]].append(mx[i + 1][j])
+                else:
+                    AL[mx[i + 1][j]].append(mx[i][j])
+            if j < m - 1:
+                if mx[i][j] < mx[i][j + 1]:
+                    AL[mx[i][j]].append(mx[i][j + 1])
+                else:
+                    AL[mx[i][j + 1]].append(mx[i][j])
+    ans = 0
+    visited = BitArray(10000 + 1)
+    for u in range(n*m):
+        ans = max(ans, dfs(u))
+        #total_cc = 0
+        #visited = BitArray(10000 + 1)
+    print(ans)
+
+
+if __name__ == "__main__":
+    main()
Index: ICPC Preparation/ICPC/E.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import os\r\nimport sys\r\nfrom collections import *\r\nfrom heapq import *\r\nfrom math import gcd, floor, ceil, sqrt\r\nfrom copy import deepcopy\r\nfrom itertools import permutations, combinations, product\r\nfrom bisect import bisect_left, bisect_right\r\nfrom functools import lru_cache, reduce\r\nimport operator\r\n\r\n# Para mejorar el rendimiento de la entrada/salida\r\ninput = lambda: sys.stdin.readline().strip()\r\nflush = lambda: sys.stdout.flush()\r\nprint = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get(\"end\", \"\\n\")) and flush()\r\n\r\n# Optimización de la recursión para Python\r\nsys.setrecursionlimit(100000)\r\n\r\n\r\n# Funciones para lectura de múltiples tipos de datos\r\ndef ints(): return map(int, input().split())\r\ndef strs(): return input().split()\r\ndef chars(): return list(input().strip())\r\ndef mat(n): return [list(ints()) for _ in range(n)]  # Matriz de n x m donde m es el número de enteros en una línea\r\n\r\n\r\n# Constantes útiles\r\nINF = float('inf')\r\nMOD = 1000000007  # Modulo por defecto, cambiar si se necesita otro\r\n\r\n\r\n# Algunas funciones útiles\r\ndef add(x, y, mod=MOD): return (x + y) % mod\r\ndef sub(x, y, mod=MOD): return (x - y) % mod\r\ndef mul(x, y, mod=MOD): return (x * y) % mod\r\n\r\n\r\n# Fast power - a^b % mod\r\ndef powmod(a, b, mod=MOD):\r\n    res = 1\r\n    a = a % mod\r\n    while b > 0:\r\n        if b % 2:\r\n            res = mul(res, a, mod)\r\n        a = mul(a, a, mod)\r\n        b //= 2\r\n    return res\r\n\r\n\r\n# Inverso multiplicativo de a modulo m (cuando m es primo)\r\ndef invmod(a, mod=MOD): return powmod(a, mod - 2, mod)\r\n\r\n\r\n# GCD y LCM\r\ndef lcm(a, b): return a * b // gcd(a, b)\r\n\r\n\r\n# Factorial con memoización\r\n@lru_cache(maxsize=None)\r\ndef factorial(n): return n * factorial(n - 1) if n else 1\r\n\r\n\r\n# Combinaciones con memoización (nCr)\r\n@lru_cache(maxsize=None)\r\ndef comb(n, r):\r\n    if r == 0 or r == n: return 1\r\n    return comb(n - 1, r - 1) + comb(n - 1, r)\r\n\r\n\r\ndef main():\r\n    solve()\r\n\r\ndef can_add(prev, sig, ini, fini):\r\n    if ini[sig] < ini[prev]:\r\n        sig, prev = prev, sig\r\n\r\n    # ({)} bad\r\n    if ini[sig] < fini[prev] and fini[prev] < fini[sig]:\r\n        return False\r\n    return True\r\n\r\ndef dfs(u, graph, color, ok):\r\n    for v in graph[u]:\r\n        if color[v] == -1:\r\n            color[v] = 1 - color[u]\r\n            dfs(v, graph, color, ok)\r\n        elif color[v] == color[u]:\r\n            ok[0] = False\r\ndef solve():\r\n    n = int(input())\r\n\r\n    a = [0] * (2 * n + 1)\r\n    ini = [0] * (n + 1)\r\n    fini = [0] * (n + 1)\r\n    in_ = [int(i) for i in list(map(str, input().split()))]\r\n    for i in range(2 * n):\r\n        if in_[i] > 0:\r\n            ini[in_[i]] = i\r\n        else:\r\n            fini[-in_[i]] = i\r\n    graph = [[] for _ in range(n + 1)]\r\n\r\n    for i in range(1, n + 1):\r\n        for j in range(i + 1, n + 1):\r\n            if can_add(i, j, ini, fini):\r\n                continue\r\n            graph[i].append(j)\r\n            graph[j].append(i)\r\n\r\n    color = [-1] * (n + 1)\r\n    ok = [True]\r\n\r\n    for i in range(1, n + 1):\r\n        if color[i] != -1:\r\n            continue\r\n        color[i] = 0\r\n        dfs(i, graph, color, ok)\r\n\r\n    if ok[0]:\r\n        for i in range(1, n + 1):\r\n            print('G' if color[i] == 0 else 'S', end='')\r\n        print()\r\n    else:\r\n        print(\"*\")\r\n\r\nif __name__ == \"__main__\":\r\n    main()\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ICPC Preparation/ICPC/E.py b/ICPC Preparation/ICPC/E.py
--- a/ICPC Preparation/ICPC/E.py	(revision bc7ab91df3db33c143ee3ebd32c794cf710fdacb)
+++ b/ICPC Preparation/ICPC/E.py	(date 1731106283538)
@@ -107,7 +107,7 @@
                 continue
             graph[i].append(j)
             graph[j].append(i)
-
+    print(graph)
     color = [-1] * (n + 1)
     ok = [True]
 
Index: ICPC Preparation/ICPC/D.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ICPC Preparation/ICPC/D.py b/ICPC Preparation/ICPC/D.py
new file mode 100644
--- /dev/null	(date 1731116309291)
+++ b/ICPC Preparation/ICPC/D.py	(date 1731116309291)
@@ -0,0 +1,63 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+
+input = lambda: sys.stdin.readline().strip()
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+def main():
+    t = int(input())
+    for _ in range(t):
+        n = int(input())
+        a = list(ints())
+        print(solve(n, a))
+
+
+def solve(n ,a ):
+    pass
+
+
+
+if __name__ == "__main__":
+    main()
Index: ICPC Preparation/Problem Solving Paradigms/Dynamic Programming/0-1 Knapsack (Subset Sum)/SuperSale.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#include <bits/stdc++.h>\r\n#include <bits/extc++.h> // pbds\r\n\r\nusing namespace std;\r\nusing namespace __gnu_pbds;\r\n\r\n#define LSOne(S) ((S) & -(S)) // Useful bitmask operation\r\n#define Fast ios::sync_with_stdio(0); cin.tie(0);\r\n\r\ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ost;\r\ntypedef long long ll;\r\ntypedef long int li;\r\ntypedef vector<int> vi;\r\ntypedef vector<ll> vl;\r\ntypedef vector<ll> vll;\r\ntypedef pair<int, int> pi;\r\n\r\nclass FastScanner{\r\npublic:\r\n\tint nextInt(){int a;cin>>a;return a;}\r\n    char nextChar(){char a;cin>>a;return a;}\r\n    ll nextLong(){ll a;cin>>a;return a;}\r\n    string next(){string a;cin>>a;return a;}\r\n    vi readArray(int n){\r\n\t\tvi a(n);\r\n\t\tfor (size_t i = 0; i < n; i++)cin>>a[i];\r\n\t\treturn a;}\r\n};\r\n\r\nstruct knapsack{\r\n    int price, weight;\r\n};\r\nint memo[1010][200];\r\nint dp(int id, int remW, int N, vector<knapsack> arr) {\r\n    if ((id == N) || (remW == 0)) return 0;        // two base cases\r\n    int &ans = memo[id][remW];\r\n    if (ans != -1) return ans;                     // computed before\r\n    if (arr[id].weight > remW) return ans = dp(id+1, remW, N, arr); // no choice, skip\r\n    return ans = max(dp(id+1, remW, N, arr),               // has choice, skip\r\n                     arr[id].price+dp(id+1, remW-arr[id].weight, N, arr));  // or take\r\n}\r\nint main(){\r\n\tFast\r\n\tFastScanner fs;\r\n\tint t = fs.nextInt();\r\n    while (t--){\r\n        int n = fs.nextInt();\r\n        memset(memo, -1, sizeof memo);\r\n        vector<knapsack> arr(n);\r\n        for (int i = 0; i < n; ++i) {\r\n            arr[i].price = fs.nextInt();\r\n            arr[i].weight = fs.nextInt();\r\n        }\r\n        int ans = 0;\r\n        int g = fs.nextInt();\r\n        while (g--){\r\n            int w = fs.nextInt();\r\n            ans += dp(0, w, n, arr);\r\n        }\r\n        cout<<ans<<\"\\n\";\r\n    }\r\n\treturn 0;\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ICPC Preparation/Problem Solving Paradigms/Dynamic Programming/0-1 Knapsack (Subset Sum)/SuperSale.cpp b/ICPC Preparation/Problem Solving Paradigms/Dynamic Programming/0-1 Knapsack (Subset Sum)/SuperSale.cpp
--- a/ICPC Preparation/Problem Solving Paradigms/Dynamic Programming/0-1 Knapsack (Subset Sum)/SuperSale.cpp	(revision bc7ab91df3db33c143ee3ebd32c794cf710fdacb)
+++ b/ICPC Preparation/Problem Solving Paradigms/Dynamic Programming/0-1 Knapsack (Subset Sum)/SuperSale.cpp	(date 1733179786061)
@@ -53,6 +53,7 @@
         }
         int ans = 0;
         int g = fs.nextInt();
+
         while (g--){
             int w = fs.nextInt();
             ans += dp(0, w, n, arr);
Index: Codeforces/Random/1955C.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Codeforces/Random/1955C.py b/Codeforces/Random/1955C.py
new file mode 100644
--- /dev/null	(date 1738365560060)
+++ b/Codeforces/Random/1955C.py	(date 1738365560060)
@@ -0,0 +1,171 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+from types import GeneratorType
+
+input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+
+# region fastio
+
+BUFSIZE = 8192
+
+
+class FastIO(IOBase):
+    newlines = 0
+
+    def __init__(self, file):
+        self._file = file
+        self._fd = file.fileno()
+        self.buffer = BytesIO()
+        self.writable = "x" in file.mode or "r" not in file.mode
+        self.write = self.buffer.write if self.writable else None
+
+    def read(self):
+        while True:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            if not b:
+                break
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines = 0
+        return self.buffer.read()
+
+    def readline(self):
+        while self.newlines == 0:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            self.newlines = b.count(b"\n") + (not b)
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines -= 1
+        return self.buffer.readline()
+
+    def flush(self):
+        if self.writable:
+            os.write(self._fd, self.buffer.getvalue())
+            self.buffer.truncate(0), self.buffer.seek(0)
+
+
+class IOWrapper(IOBase):
+    def __init__(self, file):
+        self.buffer = FastIO(file)
+        self.flush = self.buffer.flush
+        self.writable = self.buffer.writable
+        self.write = lambda s: self.buffer.write(s.encode("ascii"))
+        self.read = lambda: self.buffer.read().decode("ascii")
+        self.readline = lambda: self.buffer.readline().decode("ascii")
+
+
+#sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
+
+
+# endregion
+
+
+def main():
+    t = int(input())
+    for _ in range(t):
+        n, k = ints()
+        a = list(ints())
+        print(solve(n, a, k))
+
+
+def solve(n, a, k):
+    if n == 1:
+        return 1 if k >= a[-1] else 0
+    left = 0
+    right = n-1
+    total_right = 0
+    last_left = False
+    while left < right and k > 0:
+        cur = min(a[left], a[right], k // 2)
+        if cur == 0:
+            cur = min(a[left], k)
+            a[left] -= cur
+            k -= cur
+            if a[left] == 0:
+                left += 1
+                break
+            continue
+        a[left] -= cur
+        k -= cur
+        if a[left] == 0:
+            left += 1
+        a[right] -= cur
+        if a[right] == 0:
+            right -= 1
+            total_right += 1
+        k -= cur
+        if right == left:
+            if a[right] <= k and a[right] != 0:
+                a[right] = 0
+                total_right += 1
+
+    return left + total_right
+
+
+
+if __name__ == "__main__":
+    main()
Index: Bootcamp/2024 ICPC Gran Premio de Mexico 2da Fecha/C.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Bootcamp/2024 ICPC Gran Premio de Mexico 2da Fecha/C.py b/Bootcamp/2024 ICPC Gran Premio de Mexico 2da Fecha/C.py
new file mode 100644
--- /dev/null	(date 1738365560049)
+++ b/Bootcamp/2024 ICPC Gran Premio de Mexico 2da Fecha/C.py	(date 1738365560049)
@@ -0,0 +1,216 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+from types import GeneratorType
+
+input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+
+# region fastio
+
+BUFSIZE = 8192
+
+
+class FastIO(IOBase):
+    newlines = 0
+
+    def __init__(self, file):
+        self._file = file
+        self._fd = file.fileno()
+        self.buffer = BytesIO()
+        self.writable = "x" in file.mode or "r" not in file.mode
+        self.write = self.buffer.write if self.writable else None
+
+    def read(self):
+        while True:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            if not b:
+                break
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines = 0
+        return self.buffer.read()
+
+    def readline(self):
+        while self.newlines == 0:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            self.newlines = b.count(b"\n") + (not b)
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines -= 1
+        return self.buffer.readline()
+
+    def flush(self):
+        if self.writable:
+            os.write(self._fd, self.buffer.getvalue())
+            self.buffer.truncate(0), self.buffer.seek(0)
+
+
+class IOWrapper(IOBase):
+    def __init__(self, file):
+        self.buffer = FastIO(file)
+        self.flush = self.buffer.flush
+        self.writable = self.buffer.writable
+        self.write = lambda s: self.buffer.write(s.encode("ascii"))
+        self.read = lambda: self.buffer.read().decode("ascii")
+        self.readline = lambda: self.buffer.readline().decode("ascii")
+
+
+sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
+
+
+# endregion
+
+def gcd(x, y):
+    """greatest common divisor of x and y"""
+    while y:
+        x, y = y, x % y
+    return x
+
+
+def memodict(f):
+    """memoization decorator for a function taking a single argument"""
+    class memodict(dict):
+        def __missing__(self, key):
+            ret = self[key] = f(key)
+            return ret
+
+    return memodict().__getitem__
+
+
+def pollard_rho(n):
+    """returns a random factor of n"""
+    if n & 1 == 0:
+        return 2
+    if n % 3 == 0:
+        return 3
+
+    s = ((n - 1) & (1 - n)).bit_length() - 1
+    d = n >> s
+    for a in [2, 325, 9375, 28178, 450775, 9780504, 1795265022]:
+        p = pow(a, d, n)
+        if p == 1 or p == n - 1 or a % n == 0:
+            continue
+        for _ in range(s):
+            prev = p
+            p = (p * p) % n
+            if p == 1:
+                return gcd(prev - 1, n)
+            if p == n - 1:
+                break
+        else:
+            for i in range(2, n):
+                x, y = i, (i * i + 1) % n
+                f = gcd(abs(x - y), n)
+                while f == 1:
+                    x, y = (x * x + 1) % n, (y * y + 1) % n
+                    y = (y * y + 1) % n
+                    f = gcd(abs(x - y), n)
+                if f != n:
+                    return f
+    return n
+
+
+@memodict
+def prime_factors(n):
+    """returns a Counter of the prime factorization of n"""
+    if n <= 1:
+        return Counter()
+    f = pollard_rho(n)
+    return Counter([n]) if f == n else prime_factors(f) + prime_factors(n // f)
+
+
+def distinct_factors(n):
+    """returns a list of all distinct factors of n"""
+    factors = [1]
+    for p, exp in prime_factors(n).items():
+        factors += [p**i * factor for factor in factors for i in range(1, exp + 1)]
+    return factors
+
+
+def all_factors(n):
+    """returns a sorted list of all distinct factors of n"""
+    small, large = [], []
+    for i in range(1, int(n**0.5) + 1, 2 if n & 1 else 1):
+        if not n % i:
+            small.append(i)
+            large.append(n // i)
+    if small[-1] == large[-1]:
+        large.pop()
+    large.reverse()
+    small.extend(large)
+    return small
+
+def main():
+    t = int(input())
+    for _ in range(t):
+        n, t = ints()
+        if t == 1:
+            print(n)
+        else:
+            print(len([it for it in all_factors(t - 1) if it <= n]))
+
+if __name__ == "__main__":
+    main()
Index: .gitattributes
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.gitattributes b/.gitattributes
new file mode 100644
--- /dev/null	(date 1738365574778)
+++ b/.gitattributes	(date 1738365574778)
@@ -0,0 +1,2 @@
+*.csv filter=lfs diff=lfs merge=lfs -text
+*.txt filter=lfs diff=lfs merge=lfs -text
Index: IEEE/B.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/IEEE/B.py b/IEEE/B.py
new file mode 100644
--- /dev/null	(date 1729985340014)
+++ b/IEEE/B.py	(date 1729985340014)
@@ -0,0 +1,15 @@
+def main():
+    import sys
+    import math
+
+    from math import comb
+
+    N, M = map(int, sys.stdin.readline().split())
+    half = (N -1 ) //2
+    comb_val = comb(N-1, half)
+    pow_val = pow(2, half, M)
+    result = (comb_val * pow_val) % M
+    print(result)
+
+if __name__ == "__main__":
+    main()
\ No newline at end of file
Index: IEEE/I.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/IEEE/I.py b/IEEE/I.py
new file mode 100644
--- /dev/null	(date 1729986876950)
+++ b/IEEE/I.py	(date 1729986876950)
@@ -0,0 +1,27 @@
+import sys
+import threading
+
+def main():
+    import sys
+
+    T = int(sys.stdin.readline())
+    for _ in range(T):
+        N = int(sys.stdin.readline())
+        A = list(map(int, sys.stdin.readline().split()))
+        n = N
+        for k in range(n // 2):
+            p = 2 * k
+            q = 2 * k + 1
+            pair_sum = A[p] + A[q]
+            if pair_sum < 0:
+                A[p] *= -1
+                A[q] *= -1
+        # Apply Kadane's algorithm
+        max_so_far = A[0]
+        current_max = A[0]
+        for i in range(1, N):
+            current_max = max(A[i], current_max + A[i])
+            max_so_far = max(max_so_far, current_max)
+        print(max_so_far)
+
+threading.Thread(target=main).start()
\ No newline at end of file
Index: IEEE/en
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/IEEE/en b/IEEE/en
new file mode 100644
--- /dev/null	(date 1729986521458)
+++ b/IEEE/en	(date 1729986521458)
@@ -0,0 +1,52 @@
+Solve this competitive programming problem, take care, this is not a greedy and kadane problem, this requieries a more elaborated strategy
+---
+
+**Memory limit**: 512 MB
+
+Given an integer array **A** (1-indexed) with even length **n**, you can do the following operation as many times as you want:
+
+- Choose a pair of positions **2k - 1** and **2k** and multiply both **A[2k-1]** and **A[2k]** by **-1**.
+
+After finishing your operations, you must compute the maximum subarray sum of the resulting array. Maximize this value.
+
+**Standard input**
+The first line contains an integer **T**, the number of test cases.
+The following lines describe **T** test cases.
+The first line of each test case contains an even integer **N_i**, the length of the array.
+The second line contains **N_i** integers **A_j**, where the **j**-th integer is the **j**-th element of the array.
+
+**Standard output**
+Print **T** lines, where the **i**-th line must contain the answer to the **i**-th test case.
+
+**Constraints and notes**
+- **1 ≤ T ≤ 10^5**
+- **1 ≤ Σ N_i ≤ 4 * 10^5**
+- **2 ≤ N_i ≤ 2 * 10^5** for every **i = 1, …, T**
+- **N_i** is even for every **i = 1, …, T**
+- **|A_j| ≤ 10^4** for every valid **j**
+
+**Example**
+
+**Input**
+```
+3
+4
+5 -10 7 -2
+2
+7 -8
+2
+5 4
+```
+
+**Output**
+```
+17
+8
+9
+```
+
+**Explanation**
+
+- For the first test case, it’s possible to apply the operation on position 2, which gives the array **[-5, 10, 7, -2]** and its maximum subarray sum is **10 + 7 = 17**.
+- For the second test case, it’s possible to apply the operation on position 2, which gives the array **[-7, 8]** and its maximum subarray sum is **8**.
+- For the third test case, there is no need to apply the operation since all the values are positive, so the maximum subarray sum is **5 + 4 = 9**.
\ No newline at end of file
Index: IEEE/A.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/IEEE/A.py b/IEEE/A.py
new file mode 100644
--- /dev/null	(date 1729956001357)
+++ b/IEEE/A.py	(date 1729956001357)
@@ -0,0 +1,114 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+from enum import Enum
+
+input = lambda: sys.stdin.readline().strip()
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+starts = []
+visited = []
+
+
+AL = []
+dfs_num = []
+ts = []
+DAG = []
+
+class flag(Enum):
+  UNVISITED = -1
+  VISITED = -2
+
+def toposort(u):
+  global AL
+  global dfs_num
+  global ts
+  global DAG
+
+  dfs_num[u] = flag.VISITED.value
+  for v in DAG[u]:
+    if dfs_num[v] == flag.UNVISITED.value:
+      toposort(v)
+  ts.append(u)
+
+depth_list = []
+def main():
+    global starts, AL, visited, dfs_num, DAG, ts
+    n = int(input())
+    starts = list(ints())
+    AL = [[] for i in range(n+1)]
+    for i in range(n-1):
+        u, v = ints()
+        AL[u].append(v)
+        AL[v].append(u)
+    DAG = [[] for i in range(n+1)]
+    for u in range(1, n+1):
+        for v in AL[u]:
+            if starts[u-1] < starts[v-1]:
+                DAG[u].append(v)
+            elif starts[v-1] > starts[u-1]:
+                DAG[v].append(u)
+
+    visited = [False] * (n+1)
+    dfs_num = [flag.UNVISITED.value] * (n+1)
+    for u in range(1, n+1):
+        if dfs_num[u] == flag.UNVISITED.value:
+            toposort(u)
+    ts = ts[::-1]
+    dp = [1] * (n+1)
+    print(ts)
+    for u in ts:
+        for v in DAG[u]:
+            if dp[u] > dp[v] + 1:
+                dp[u] += dp[v] + 1
+
+    print(dp)
+
+
+def solve(n ,a ):
+    pass
+
+
+
+if __name__ == "__main__":
+    main()
Index: IEEE/K.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/IEEE/K.py b/IEEE/K.py
new file mode 100644
--- /dev/null	(date 1729975929294)
+++ b/IEEE/K.py	(date 1729975929294)
@@ -0,0 +1,100 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+
+
+input = lambda: sys.stdin.readline().strip()
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 998244353
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+def compute_factorials(n, MOD):
+    fact = [1] * (n + 1)
+    inv_fact = [1] * (n + 1)
+    for i in range(1, n + 1):
+        fact[i] = fact[i - 1] * i % MOD
+    inv_fact[n] = pow(fact[n], MOD - 2, MOD)
+    for i in range(n - 1, -1, -1):
+        inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD
+    return fact, inv_fact
+
+
+def binom(n, k, fact, inv_fact):
+    if k > n:
+        return 0
+    if (k == 0 or k == n):
+        return 1
+    return fact[n] * inv_fact[k] % MOD * inv_fact[n - k] % MOD
+
+def main():
+    N = int(input())
+
+    A = set(list(ints())[1:])
+    B = set(list(ints())[1:])
+    total_numbers = list(range(1, 2 * N + 1))
+    S = total_numbers
+
+    dp_current = [0] * (N + 2)
+    dp_next = [0] * (N + 2)
+    dp_current[0] = 1
+
+    for idx, num in enumerate(S):
+        for k in range(N + 1):
+            dp_next[k] = 0
+        if num in A:
+            for k in range(N):
+                dp_next[k + 1] = (dp_next[k + 1] + dp_current[k]) % MOD
+        elif num in B:
+            for k in range(1, N + 1):
+                dp_next[k - 1] = (dp_next[k - 1] + dp_current[k]) % MOD
+        else:
+            for k in range(N):
+                dp_next[k + 1] = (dp_next[k + 1] + dp_current[k]) % MOD
+            for k in range(1, N + 1):
+                dp_next[k - 1] = (dp_next[k - 1] + dp_current[k]) % MOD
+
+        dp_current, dp_next = dp_next, dp_current
+
+    print(dp_current[0] % MOD)
+
+main()
\ No newline at end of file
Index: IEEE/D.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/IEEE/D.py b/IEEE/D.py
new file mode 100644
--- /dev/null	(date 1729983625194)
+++ b/IEEE/D.py	(date 1729983625194)
@@ -0,0 +1,69 @@
+from math import gcd
+from sys import stdin, stdout
+
+
+def main():
+    input = stdin.read
+    data = input().split()
+
+    index = 0
+    N = int(data[index])
+    Q = int(data[index + 1])
+    index += 2
+
+    # Initial salaries and happiness
+    salaries = list(map(int, data[index:index + N]))
+    index += N
+    happiness = [0] * N
+
+    output = []
+
+    for _ in range(Q):
+        event_type = int(data[index])
+        l = int(data[index + 1]) - 1  # Convert to 0-based index
+        r = int(data[index + 2]) - 1
+        if event_type == 0:
+            # Type 0: Set salaries from l to r to c
+            c = int(data[index + 3])
+            for i in range(l, r + 1):
+                if salaries[i] < c:
+                    happiness[i] += 1  # Salary increased
+                elif salaries[i] > c:
+                    happiness[i] -= 1  # Salary decreased
+                salaries[i] = c
+            index += 4
+        elif event_type == 1:
+            # Type 1: Change salaries from l to r by c
+            c = int(data[index + 3])
+            for i in range(l, r + 1):
+                if c > 0:
+                    happiness[i] += 1  # Salary will increase
+                elif c < 0:
+                    happiness[i] -= 1  # Salary will decrease
+                salaries[i] += c
+            index += 4
+        elif event_type == 2:
+            # Type 2: Calculate average salary from l to r
+            total_salary = sum(salaries[l:r + 1])
+            count = r - l + 1
+            P = total_salary
+            Q = count
+            d = gcd(P, Q)
+            output.append(f"{P // d}/{Q // d}")
+            index += 3
+        elif event_type == 3:
+            # Type 3: Calculate average happiness from l to r
+            total_happiness = sum(happiness[l:r + 1])
+            count = r - l + 1
+            P = total_happiness
+            Q = count
+            d = gcd(P, Q)
+            output.append(f"{P // d}/{Q // d}")
+            index += 3
+
+    # Output all results
+    stdout.write("\n".join(output) + "\n")
+
+
+if __name__ == "__main__":
+    main()
\ No newline at end of file
Index: IEEE/F_aux.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/IEEE/F_aux.py b/IEEE/F_aux.py
new file mode 100644
--- /dev/null	(date 1729973449749)
+++ b/IEEE/F_aux.py	(date 1729973449749)
@@ -0,0 +1,28 @@
+def maximize_number_greedy(N, K):
+    num_list = list(str(N))
+    n = len(num_list)
+    def find_max_position(start):
+        max_digit = '0'
+        max_pos = start
+        for i in range(n - 1, start - 1, -1):
+            if num_list[i] > max_digit:
+                max_digit = num_list[i]
+                max_pos = i
+        return max_pos
+    k = K
+    for i in range(n):
+        if k <= 0:
+            break
+        max_pos = find_max_position(i)
+        if num_list[i] != num_list[max_pos]:
+            num_list[i], num_list[max_pos] = num_list[max_pos], num_list[i]
+            k -= 1
+    ans = ''.join(num_list)
+    return ans
+
+n, k= map(str, input().split())
+N = n.strip()
+K = int(k)
+
+ans = maximize_number_greedy(N, K)
+print(ans)
\ No newline at end of file
Index: IEEE/D_aux.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/IEEE/D_aux.py b/IEEE/D_aux.py
new file mode 100644
--- /dev/null	(date 1729986048774)
+++ b/IEEE/D_aux.py	(date 1729986048774)
@@ -0,0 +1,61 @@
+import sys
+import threading
+
+
+def main():
+    import math
+
+    Q = int(sys.stdin.readline())
+    queries = [tuple(map(int, sys.stdin.readline().split())) for _ in range(Q)]
+
+    # Precompute the triangle sizes (not strictly necessary since we can start with a large size)
+    # Maximum size needed based on constraints (max x and y ≤ 1e9)
+    max_coordinate = max(max(x for x, y in queries), max(y for x, y in queries))
+
+    # Since the triangle size at each step N is S(N) = 3 * (2^(N-1)) - 1,
+    # we can find minimal N such that S(N) ≥ max_coordinate
+    # Let's compute S(N) up to N where S(N) ≥ 1e9
+    sizes = []
+    s = 2
+    while s < max_coordinate:
+        sizes.append(s)
+        s = 2 * s + 1  # Based on the recursive formula
+    sizes.append(s)  # Include the final size
+
+    max_size = sizes[-1]
+
+    def is_red(x, y, size):
+        while size >= 2:
+            if size == 2:
+                return True  # All points are red in the smallest triangle
+            mid = (size + 1) // 2
+            if x == mid:
+                # Middle row is blue
+                return False
+            elif x < mid:
+                # Point is in the top triangle
+                size = mid - 1
+            else:
+                # Point is in the bottom triangles
+                if y <= mid - 1:
+                    # Left bottom triangle
+                    x -= mid
+                    size = mid - 1
+                elif y > mid:
+                    # Right bottom triangle
+                    x -= mid
+                    y -= mid
+                    size = mid - 1
+                else:
+                    # Middle inverted triangle area (blue)
+                    return False
+        # If we reach here, the point is red
+        return True
+
+    for x, y in queries:
+        result = 1 if is_red(x, y, max_size) else 0
+        print(result)
+
+
+# To handle large recursion depths in threading
+threading.Thread(target=main).start()
\ No newline at end of file
Index: IEEE/F.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/IEEE/F.py b/IEEE/F.py
new file mode 100644
--- /dev/null	(date 1729974172659)
+++ b/IEEE/F.py	(date 1729974172659)
@@ -0,0 +1,60 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+
+input = lambda: sys.stdin.readline().strip()
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+def main():
+    while True:
+        s = input()
+        if not s:
+            break
+        list_ = s.split(',')
+        print(len(list_))
+
+
+if __name__ == "__main__":
+    main()
+
Index: IEEE/en2
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/IEEE/en2 b/IEEE/en2
new file mode 100644
--- /dev/null	(date 1729982773915)
+++ b/IEEE/en2	(date 1729982773915)
@@ -0,0 +1,131 @@
+Solve this competitive programming problem
+
+Here’s a formatted plain text version of the problem:
+
+---
+
+**Memory limit**: 512 MB
+
+Given an integer array **A** (1-indexed) with even length **n**, you can do the following operation as many times as you want:
+
+- Choose a pair of positions **2k - 1** and **2k** and multiply both **A[2k-1]** and **A[2k]** by **-1**.
+
+After finishing your operations, you must compute the maximum subarray sum of the resulting array. Maximize this value.
+
+**Standard input**
+The first line contains an integer **T**, the number of test cases.
+The following lines describe **T** test cases.
+The first line of each test case contains an even integer **N_i**, the length of the array.
+The second line contains **N_i** integers **A_j**, where the **j**-th integer is the **j**-th element of the array.
+
+**Standard output**
+Print **T** lines, where the **i**-th line must contain the answer to the **i**-th test case.
+
+**Constraints and notes**
+- **1 ≤ T ≤ 10^5**
+- **1 ≤ Σ N_i ≤ 4 * 10^5**
+- **2 ≤ N_i ≤ 2 * 10^5** for every **i = 1, …, T**
+- **N_i** is even for every **i = 1, …, T**
+- **|A_j| ≤ 10^4** for every valid **j**
+
+**Example**
+
+**Input**
+```
+2
+6
+9 -5 -3 8 0 -6
+2
+-8 0
+```
+
+**Output**
+```
+16
+8
+```
+
+**Explanation**
+For the first test case, it's possible to apply the operation on positions
+
+2 and
+
+6, which gives the array
+
+(−9,5,−3,8,0,6) and its maximum subarray sum is
+
+5+(−3)+8+0+6=16.
+
+
+For the second test case, it's possible to apply the operation on position
+
+2, which gives the array
+
+(8,0) and its maximum subarray sum is
+
+8+0=8 .
+
+---
+
+
+
+For this test case:
+
+5
+00000000
+0
+5
+C 80000000
+N 0 1
+N 0 2
+N 2 1
+N 3 4
+12345678
+0
+5
+C 80000000
+N 0 1
+N 0 2
+N 2 1
+N 3 4
+cccccccc
+0
+5
+C 80000000
+N 0 1
+N 0 2
+N 2 1
+N 3 4
+cdef0123
+0
+5
+C 80000000
+N 0 1
+N 0 2
+N 2 1
+N 3 4
+01020304
+0
+5
+C 80000000
+N 0 1
+N 0 2
+N 2 1
+N 3 4
+
+
+It provides:
+80000000
+80000000
+80000000
+80000000
+80000000
+
+
+But the correct answer is:
+80000000
+92345678
+4ccccccc
+4def0123
+81020304
+
Index: IEEE/en4
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/IEEE/en4 b/IEEE/en4
new file mode 100644
--- /dev/null	(date 1729984459639)
+++ b/IEEE/en4	(date 1729984459639)
@@ -0,0 +1,37 @@
+Solve this competitive programming problem
+
+Increasing-decreasing permutations
+
+Time limit: 1000 ms
+Memory limit: 256 MB
+
+There is a permutation of odd length N called P (P1, P2, ..., PN). The goal is to change the permutation in the smallest number of adjacent swaps so that the first (N+1)/2 items of the permutation are sorted in ascending order and the last (N+1)/2 items are sorted in descending order. For example, the permutation (1, 2, 3, 4, 5) can be changed into (1, 2, 5, 4, 3) in 3 swaps.
+
+For each permutation of length N, let’s find the minimum number of swaps needed to organize it in increasing-decreasing order. What is the sum of all those values for all permutations? Now, the sum can be very big, please answer it modulo a prime number M.
+
+Standard input
+The first line of input contains two integers N and M.
+
+Standard output
+Print the sum of the minimum number of swaps needed to reach the desired order for each permutation of length N modulo M.
+
+Constraints and notes
+3 ≤ N ≤ 23.
+2 ≤ M ≤ 2^30.
+M is prime.
+Example
+Input
+3 107
+
+Output
+4
+
+Explanation
+The permutations are the following:
+
+(1, 2, 3) → (1, 3, 2) requires 1 swap.
+(1, 3, 2) → (1, 3, 2) requires 0 swaps.
+(2, 1, 3) → (2, 3, 1) requires 1 swap.
+(2, 3, 1) → (2, 3, 1) requires 0 swaps.
+(3, 1, 2) → (1, 3, 2) requires 1 swap.
+(3, 2, 1) → (2, 3, 1) requires 1 swap.
\ No newline at end of file
Index: IEEE/en3
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/IEEE/en3 b/IEEE/en3
new file mode 100644
--- /dev/null	(date 1729984273052)
+++ b/IEEE/en3	(date 1729984273052)
@@ -0,0 +1,186 @@
+Solve this competitive programming problem
+
+
+---
+
+The IEEE 754 single-precision floating-point format is a 32-bit binary format that represents real numbers. These 32 bits are divided into three distinct parts:
+
+1. **Sign bit (1 bit):**
+   - The first bit (bit 31) indicates the sign of the number.
+   - `0` means the number is positive.
+   - `1` means the number is negative.
+
+2. **Exponent (8 bits):**
+   - The next 8 bits (bits 30 to 23) represent the exponent of the number.
+   - The exponent is stored using a "biased" format, with a bias of 127. This means the actual exponent is calculated as:
+     \[
+     \text{exponent} = \text{exponent bits value} - 127
+     \]
+   - For example, the bit pattern `10000001` represents \(129\) in decimal, and the actual exponent is \(129 - 127 = 2\).
+
+3. **Fraction (mantissa) (23 bits):**
+   - The remaining 23 bits (bits 22 to 0) represent the fraction (mantissa) of the number.
+   - IEEE 754 format assumes a "normalized" representation where the leading bit is always 1 and is not stored (it is implied). Therefore, the actual value of the mantissa is:
+     \[
+     1 + \text{fraction bits}
+     \]
+
+The fraction bits represent the fractional part of the number.
+
+The value of the floating-point number is calculated as:
+\[
+(-1)^{\text{sign bit}} \times (1 + \text{mantissa}) \times 2^{(\text{exponent} - 127)}
+\]
+
+For the hexadecimal value `0x3f800000`, the breakdown is:
+
+- **Sign bit:** `0` (positive)
+- **Exponent bits:** `01111111` (decimal 128, so actual exponent = \(128 - 127 = 1\))
+- **Mantissa bits:** `00000000000000000000000` (which corresponds to a fraction slightly greater than 1)
+
+This combination represents the number `1.1415927410125732421875` approximately.
+
+More information about floating-point numbers (with a calculator for testing) can be found in the following links:
+- **Addition and subtraction**
+- **Multiplication**
+
+---
+
+**Note:** Consider the following special rules:
+- \( x + x = +0 \) for \( x = 0 \).
+- \( x + (-x) = +0 \) for all \( x \neq 0 \).
+- \( 0/0 = \text{NaN} \).
+- \( x/0 = \text{NaN} \).
+- \( 0 \times \text{NaN} = 0 \).
+- \( x \times \text{NaN} = \text{NaN} \).
+
+To compute approximated values of functions we will assume that we must store first an hexadecimal value and then the result of many commands which (possibly) use some previously stored values.
+
+One of these interesting commands is Fused Multiply-Add (FMA), which receives 3 floating point values \(a\), \(b\), and \(c\) and computes \(a \times b + c\) with only one rounding step. This command differs with multiplying and then adding because general multiplication does one rounding step and addition makes another one, so precision might be lost due to this.
+
+We will start with a single hexadecimal value `C[0]` and then many commands follow:
+
+1. **Look-Up Table (LUT):** Consider that many hexadecimal values are stored in many tables `LUT^k` of size \(2^{k}\) for some \(k \geq 1\). Then, if we execute a LUT command `L i j b`, then we must compute the integer value of the bits in position \(j, j+1, \dots, j + b - 1\) from `C[i]` (this value will be masked) and the answer will be `LUT[j][\text{mask}]`. It must be guaranteed that both \(b \leq k\) and \(0 \leq j \leq j + b - 1 < 32\).
+
+2. **NAND Gate:** If we execute a NAND command `N i h`, then we must compute the Bitwise NAND of the values `C[i]` and `C[h]`.
+
+3. **Fused Multiply-Add:** If we execute an FMA command `F i j k`, then we must compute `C[i] = C[j] \times C[k] + C[h]`.
+
+4. **Constant declaration:** If we execute a Constant command `C h`, then we must store the hexadecimal `h`.
+
+Given `C[0]`, the LUTs and the commands to execute, your task is to compute the value stored by the last command.
+
+---
+
+### Standard Input
+The first line of input contains an integer `T`, the number of test cases.
+
+The following `T` blocks are for `T` test cases.
+
+The first line of each test case contains an hexadecimal value `C[0]` that represents a single-precision floating-point value.
+
+The second line of the test case contains an integer `n`, the number of commands to read.
+
+The `i`-th of the following `n` lines contains an integer `p`, followed by `2^k` hexadecimal bits that represent single-precision floating point values.
+
+The `n`-th of the following `n` lines contains a command.
+
+- **L i j b:** Store the corresponding result for this command. It is guaranteed that \(0 \leq i, j \leq j + b - 1 < 32\) and \(b \leq k\).
+- **N i j:** Store the corresponding NAND result for this command. It is guaranteed that \(0 \leq i, j \leq k\).
+- **F i j k:** Store the corresponding FMA command result. It is guaranteed that \(0 \leq i, j, k < n\).
+- **C h:** Store the corresponding Constant result for this command. It is guaranteed that `h` is an hexadecimal value.
+
+---
+
+### Standard Output
+Print `T` lines, the i-th line must contain the value stored by the last command of the i-th test case.
+
+Input:
+4
+00000000
+0
+3
+C bf800000
+C 40800000
+F 2 0 1
+3f800000
+0
+3
+C bf800000
+C 40800000
+F 2 0 1
+40490fdb
+0
+3
+C bf800000
+C 40800000
+F 2 0 1
+bf800001
+0
+3
+C bf800000
+C 40800000
+F 2 0 1
+
+
+Output:
+bf800000
+40400000
+41390fdb
+c0a00001
+
+
+Input:
+5
+00000000
+0
+5
+C 80000000
+N 0 1
+N 0 2
+N 2 1
+N 3 4
+12345678
+0
+5
+C 80000000
+N 0 1
+N 0 2
+N 2 1
+N 3 4
+cccccccc
+0
+5
+C 80000000
+N 0 1
+N 0 2
+N 2 1
+N 3 4
+cdef0123
+0
+5
+C 80000000
+N 0 1
+N 0 2
+N 2 1
+N 3 4
+01020304
+0
+5
+C 80000000
+N 0 1
+N 0 2
+N 2 1
+N 3 4
+
+
+output:
+80000000
+92345678
+4ccccccc
+4def0123
+81020304
+
+
+
+
Index: IEEE/q.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/IEEE/q.py b/IEEE/q.py
new file mode 100644
--- /dev/null	(date 1729978612580)
+++ b/IEEE/q.py	(date 1729978612580)
@@ -0,0 +1,58 @@
+def solve():
+    import sys
+    import threading
+
+    def main():
+        import sys
+        S = sys.stdin.readline().strip()
+        N = len(S)
+        ans = [float('inf')] * (N + 1)
+        mod = (1 << 61) - 1  # Large prime for modulus
+        base = 911  # Base for hashing
+
+        # Precompute prefix hashes and powers of base
+        h = [0] * (N + 1)
+        pow_base = [1] * (N + 1)
+
+        for i in range(1, N + 1):
+            h[i] = (h[i - 1] * base + ord(S[i - 1])) % mod
+            pow_base[i] = (pow_base[i - 1] * base) % mod
+
+        for L in range(1, N + 1):
+            substrings = dict()
+
+            # Compute hashes for all substrings of length L
+            for i in range(N - L + 1):
+                j = i + L - 1
+                # Compute substring hash using precomputed prefix hashes
+                hash_value = (h[j + 1] - h[i] * pow_base[L]) % mod
+                if hash_value not in substrings:
+                    substrings[hash_value] = []
+                substrings[hash_value].append(i)
+
+            # Process each unique substring
+            for positions in substrings.values():
+                intervals = []
+                for pos in positions:
+                    l = pos
+                    r = pos + L - 1
+                    intervals.append((l, r))
+
+                # Merge intervals
+                intervals.sort()
+                merged = []
+                for l, r in intervals:
+                    if not merged or merged[-1][1] + 1 < l:
+                        merged.append([l, r])
+                    else:
+                        merged[-1][1] = max(merged[-1][1], r)
+
+                # Calculate total covered islands and connected components
+                total_covered = sum(r - l + 1 for l, r in merged)
+                num_components = len(merged) + (N - total_covered)
+                ans[num_components] = min(ans[num_components], L)
+
+        # Output the results
+        print(' '.join(str(0 if val == float('inf') else val) for val in ans[1:N + 1]))
+    threading.Thread(target=main).start()
+solve()
\ No newline at end of file
Index: Bootcamp/CPC 6/M.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Bootcamp/CPC 6/M.py b/Bootcamp/CPC 6/M.py
new file mode 100644
--- /dev/null	(date 1726336144943)
+++ b/Bootcamp/CPC 6/M.py	(date 1726336144943)
@@ -0,0 +1,18 @@
+n = int(input())
+F = [0] * 5
+
+for i in range(n):
+    s = input()
+    if s[0] == 'M': F[0] += 1
+    if s[0] == 'A': F[1] += 1
+    if s[0] == 'R': F[2] += 1
+    if s[0] == 'C': F[3] += 1
+    if s[0] == 'H': F[4] += 1
+#print(F)
+ans = 0
+for i in range(5):
+    for j in range(i+1, 5):
+        for k in range(j+1, 5):
+            ans += F[i] * F[j] * F[k]
+
+print(ans)
\ No newline at end of file
Index: Bootcamp/CPC 6/E.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Bootcamp/CPC 6/E.py b/Bootcamp/CPC 6/E.py
new file mode 100644
--- /dev/null	(date 1726334762830)
+++ b/Bootcamp/CPC 6/E.py	(date 1726334762830)
@@ -0,0 +1,20 @@
+n, m = map(int, input().split())
+AM = [[int(1e9 + 5) for j in range(n)] for i in range(n)]
+EL = []
+for i in range(m):
+    u, v, w = map(int, input().split())
+    EL.append((u-1, v-1, w))
+    AM[u - 1][v - 1] = w
+    AM[v - 1][u - 1] = w
+
+#print(AM)
+ans = 0
+for k in range(n):
+    for i in range(n):
+        for j in range(n):
+            if AM[i][k] + AM[k][j] <= AM[i][j] and i != j:
+                AM[i][j] = AM[i][k] + AM[k][j]
+
+for u, v, w in EL:
+    ans += any(AM[u][i] + AM[i][v] <= w and u != i and v!= i for i in range(n))
+print(ans)
\ No newline at end of file
Index: Bootcamp/CPC 6/J.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Bootcamp/CPC 6/J.py b/Bootcamp/CPC 6/J.py
new file mode 100644
--- /dev/null	(date 1726340626692)
+++ b/Bootcamp/CPC 6/J.py	(date 1726340626692)
@@ -0,0 +1,23 @@
+n = int(input())
+a = list(map(int, input().split()))
+b = list(map(int, input().split()))
+k = int(input())
+MOD = int(1e9 + 7)
+p = 131
+def prepareP(n):
+    P = [0] * n
+    P[0] = 1
+    for i in range(1, n):
+        P[i] = P[i-1] * p % MOD
+    return P
+def computeRollingHash(T: str):
+    P = prepareP(len(T))
+    h = [0] * len(T)
+    for i in range(len(T)):
+        if i == 0:
+            h[i] = h[i-1]
+        h[i] = h[i] + (T[i] * P[i] % MOD) % MOD
+
+
+for i in range(k):
+    a, b = map(int, input().split())
Index: Bootcamp/CPC 6/B.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Bootcamp/CPC 6/B.py b/Bootcamp/CPC 6/B.py
new file mode 100644
--- /dev/null	(date 1726425475257)
+++ b/Bootcamp/CPC 6/B.py	(date 1726425475257)
@@ -0,0 +1,147 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+
+input = lambda: sys.stdin.readline().strip()
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = 10 ** 18
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+class Dinic:
+    def __init__(self, n):
+        self.lvl = [0] * n
+        self.ptr = [0] * n
+        self.q = [0] * n
+        self.adj = [[] for _ in range(n)]
+
+    def add_edge(self, a, b, c, rcap=0):
+        self.adj[a].append([b, len(self.adj[b]), c, 0])
+        self.adj[b].append([a, len(self.adj[a]) - 1, rcap, 0])
+
+    def dfs(self, v, t, f):
+        if v == t or not f:
+            return f
+
+        for i in range(self.ptr[v], len(self.adj[v])):
+            e = self.adj[v][i]
+            if self.lvl[e[0]] == self.lvl[v] + 1:
+                p = self.dfs(e[0], t, min(f, e[2] - e[3]))
+                if p:
+                    self.adj[v][i][3] += p
+                    self.adj[e[0]][e[1]][3] -= p
+                    return p
+            self.ptr[v] += 1
+
+        return 0
+
+    def calc(self, s, t):
+        flow, self.q[0] = 0, s
+        for l in range(31):  # l = 30 maybe faster for random data
+            while True:
+                self.lvl, self.ptr = [0] * len(self.q), [0] * len(self.q)
+                qi, qe, self.lvl[s] = 0, 1, 1
+                while qi < qe and not self.lvl[t]:
+                    v = self.q[qi]
+                    qi += 1
+                    for e in self.adj[v]:
+                        if not self.lvl[e[0]] and (e[2] - e[3]) >> (30 - l):
+                            self.q[qe] = e[0]
+                            qe += 1
+                            self.lvl[e[0]] = self.lvl[v] + 1
+
+                p = self.dfs(s, t, INF)
+                while p:
+                    flow += p
+                    p = self.dfs(s, t, INF)
+
+                if not self.lvl[t]:
+                    break
+
+        return flow
+
+
+def main():
+    N, M = ints()
+    edges = []
+    for _ in range(M):
+        u, v = ints()
+        edges.append((u, v))
+    c = list(ints())
+    total = 2 * N + 1
+    dinic = Dinic(total)
+    for i in range(2, N):
+        dinic.add_edge(i, i + N, c[i - 1])
+    for a, b in edges:
+        a_node = a if a in (1, N) else a + N
+        b_node = b if b in (1, N) else b + N
+        dinic.add_edge(a_node, b, INF)
+        dinic.add_edge(b_node, a, INF)
+
+    source = 1
+    sink = N
+    flow = dinic.calc(source, sink)
+    visited = [False] * (total)
+    q = deque()
+    q.append(source)
+    visited[source] = True
+    while q:
+        v = q.popleft()
+        for e in dinic.adj[v]:
+            if e[2] > e[3] and not visited[e[0]]:
+                visited[e[0]] = True
+                q.append(e[0])
+
+    separators = []
+    total_cost = 0
+    for i in range(2, N):
+        i_in = i
+        i_out = i + N
+        if visited[i_in] and not visited[i_out]:
+            separators.append(i)
+            total_cost += c[i - 1]
+    print(total_cost, flow)
+    print(len(separators))
+    print(' '.join(map(str, sorted(separators))))
+
+if __name__ == "__main__":
+    main()
Index: Bootcamp/CPC 10/L.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Bootcamp/CPC 10/L.py b/Bootcamp/CPC 10/L.py
new file mode 100644
--- /dev/null	(date 1730860566807)
+++ b/Bootcamp/CPC 10/L.py	(date 1730860566807)
@@ -0,0 +1,185 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+
+input = lambda: sys.stdin.readline().strip()
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+
+def ints(): return map(int, input().split())
+
+
+def strs(): return input().split()
+
+
+def chars(): return list(input().strip())
+
+
+def mat(n): return [list(ints()) for _ in range(n)]
+
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+
+def add(x, y, mod=MOD): return (x + y) % mod
+
+
+def sub(x, y, mod=MOD): return (x - y) % mod
+
+
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+
+RANDOM = getrandbits(32)
+
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+def _u(i, j, m):
+    return f'u_{i}_{j}'
+
+
+def _v(i, j, m):
+    return f'v_{i}_{j}'
+
+
+INF = 10 ** 18
+
+
+class min_cost_max_flow:
+    def __init__(self, V):
+        self.V = V
+        self.EL = []
+        self.AL = [list() for _ in range(V)]
+        self.vis = [False] * V
+        self.total_cost = 0
+        self.d = None
+        self.last = None
+
+    def SPFA(self, s, t):
+        self.d = [INF] * self.V
+        self.d[s] = 0
+        self.vis[s] = True
+        q = [s]
+        while len(q) != 0:
+            u = q[0]
+            q.pop(0)
+            self.vis[u] = False
+            for idx in self.AL[u]:
+                v, cap, flow, cost = self.EL[idx]
+                if cap - flow > 0 and self.d[v] > self.d[u] + cost:
+                    self.d[v] = self.d[u] + cost
+                    if not self.vis[v]:
+                        q.append(v)
+                        self.vis[v] = True
+        return self.d[t] != INF
+
+    def DFS(self, u, t, f=INF):
+        if u == t or f == 0:
+            return f
+        self.vis[u] = True
+        for i in range(self.last[u], len(self.AL[u])):
+            v, cap, flow, cost = self.EL[self.AL[u][i]]
+            if not self.vis[v] and self.d[v] == self.d[u] + cost:
+                pushed = self.DFS(v, t, min(f, cap - flow))
+                if pushed != 0:
+                    self.total_cost += pushed * cost
+                    flow += pushed
+                    self.EL[self.AL[u][i]][2] = flow
+                    rv, rcap, rflow, rcost = self.EL[self.AL[u][i] ^ 1]
+                    rflow -= pushed
+                    self.EL[self.AL[u][i] ^ 1][2] = rflow
+                    self.vis[u] = False
+                    self.last[u] = i
+                    return pushed
+        self.vis[u] = False
+        return 0
+
+    def add_edge(self, u, v, w, c, directed=True):
+        if u == v:
+            return
+        self.EL.append([v, w, 0, c])
+        self.AL[u].append(len(self.EL) - 1)
+        self.EL.append([u, 0 if directed else w, 0, -c])
+        self.AL[v].append(len(self.EL) - 1)
+
+    def mcmf(self, s, t):
+        mf = 0
+        while self.SPFA(s, t):
+            self.last = [0] * self.V
+            f = self.DFS(s, t)
+            while f != 0:
+                mf += f
+                f = self.DFS(s, t)
+        return mf, self.total_cost
+
+
+def main():
+    t = int(input())
+    for _ in range(t):
+        input()
+        n, m = ints()
+        mx = [list(ints()) for i in range(n)]
+        V = 2 * n * m
+        mapper = {}
+        total = 0
+        for i in range(n):
+            for j in range(m):
+                mapper[_u(i, j, m)] = total
+                total += 1
+                mapper[_v(i, j, m)] = total
+                total += 1
+        mcmf = min_cost_max_flow(V)
+        for i in range(n):
+            for j in range(m):
+                node_in = mapper[_u(i, j, m)]
+                node_out = mapper[_v(i, j, m)]
+                capacity = 2 if (i == 0 and j == 0) or (i == n - 1 and j == m - 1) else 1
+                cost = -mx[i][j]
+                mcmf.add_edge(node_in, node_out, capacity, cost)
+        for i in range(n):
+            for j in range(m):
+                node_out = mapper[_v(i, j, m)]
+
+                if j < m - 1:
+                    right_in = mapper[_u(i, j + 1, m)]
+                    mcmf.add_edge(node_out, right_in, 1, 0)
+                if i < n - 1:
+                    down_in = mapper[_u(i + 1, j, m)]
+                    mcmf.add_edge(node_out, down_in, 1, 0)
+        source = mapper[_u(0, 0, m)]
+        sink = mapper[_v(n - 1, m - 1, m)]
+        flow, cost = mcmf.mcmf(source, sink)
+        print(f"Case {_ + 1}: {-cost - mx[0][0] - mx[n - 1][m - 1]}")
+
+
+if __name__ == "__main__":
+    main()
Index: Bootcamp/CPC 11/E.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Bootcamp/CPC 11/E.py b/Bootcamp/CPC 11/E.py
new file mode 100644
--- /dev/null	(date 1730768322864)
+++ b/Bootcamp/CPC 11/E.py	(date 1730768322864)
@@ -0,0 +1,62 @@
+def merge_and_count(arr, temp_arr, left, mid, right):
+   i = left
+   j = mid + 1
+   k = left
+   inv_count = 0
+   while i <= mid and j <= right:
+       if arr[i] <= arr[j]:
+           temp_arr[k] = arr[i]
+           i += 1
+       else:
+           temp_arr[k] = arr[j]
+           inv_count += (mid - i + 1)
+           j += 1
+       k += 1
+   while i <= mid:
+       temp_arr[k] = arr[i]
+       i += 1
+       k += 1
+
+   while j <= right:
+       temp_arr[k] = arr[j]
+       j += 1
+       k += 1
+
+   for i in range(left, right + 1):
+       arr[i] = temp_arr[i]
+
+   return inv_count
+
+
+def merge_sort_and_count(arr, temp_arr, left, right):
+   inv_count = 0
+   if left < right:
+       mid = (left + right) // 2
+
+       inv_count += merge_sort_and_count(arr, temp_arr, left, mid)
+       inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right)
+       inv_count += merge_and_count(arr, temp_arr, left, mid, right)
+
+
+   return inv_count
+
+
+
+def count_inversions(arr):
+   cop = arr.copy()
+   temp_arr = [0] * len(arr)
+   return merge_sort_and_count(cop, temp_arr, 0, len(cop) - 1)
+
+
+t = int(input())
+for i in range(t):
+    n = int(input())
+    list_a = list(input().split())
+    list_b = list(input().split())
+    index = {}
+    ans = [0] * n
+    for i, it in enumerate(list_a):
+        index[it] = i + 1
+    for i, it in enumerate(list_b):
+        ans[i] = index[it]
+    print(count_inversions(ans))
\ No newline at end of file
Index: Bootcamp/CPC 11/A.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Bootcamp/CPC 11/A.py b/Bootcamp/CPC 11/A.py
new file mode 100644
--- /dev/null	(date 1730677030740)
+++ b/Bootcamp/CPC 11/A.py	(date 1730677030740)
@@ -0,0 +1,31 @@
+t = int(input())
+for _ in range(t):
+    n, k = map(int, input().split())
+    a = []
+    for i in range(n):
+        a.append(int(input()))
+
+
+    def can(mid, a, k):
+        total_cow = 1
+        prev = 0
+        index = 1
+        while index < len(a):
+            if a[index] - a[prev] >= mid:
+                total_cow += 1
+                prev = index
+            index += 1
+        return total_cow >= k
+
+
+    lo, hi = 0, max(a) + 1
+    a.sort()
+    ans = -1
+    while lo < hi:
+        mid = (lo + hi) // 2
+        if can(mid, a, k):
+            lo = mid + 1
+            ans = mid
+        else:
+            hi = mid
+    print(ans)
\ No newline at end of file
Index: USACO GUIDE/GOLD/DP/AC - D - Knapsack 1.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/USACO GUIDE/GOLD/DP/AC - D - Knapsack 1.py b/USACO GUIDE/GOLD/DP/AC - D - Knapsack 1.py
new file mode 100644
--- /dev/null	(date 1732678710864)
+++ b/USACO GUIDE/GOLD/DP/AC - D - Knapsack 1.py	(date 1732678710864)
@@ -0,0 +1,149 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+from types import GeneratorType
+
+input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+
+# region fastio
+
+BUFSIZE = 8192
+
+
+class FastIO(IOBase):
+    newlines = 0
+
+    def __init__(self, file):
+        self._file = file
+        self._fd = file.fileno()
+        self.buffer = BytesIO()
+        self.writable = "x" in file.mode or "r" not in file.mode
+        self.write = self.buffer.write if self.writable else None
+
+    def read(self):
+        while True:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            if not b:
+                break
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines = 0
+        return self.buffer.read()
+
+    def readline(self):
+        while self.newlines == 0:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            self.newlines = b.count(b"\n") + (not b)
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines -= 1
+        return self.buffer.readline()
+
+    def flush(self):
+        if self.writable:
+            os.write(self._fd, self.buffer.getvalue())
+            self.buffer.truncate(0), self.buffer.seek(0)
+
+
+class IOWrapper(IOBase):
+    def __init__(self, file):
+        self.buffer = FastIO(file)
+        self.flush = self.buffer.flush
+        self.writable = self.buffer.writable
+        self.write = lambda s: self.buffer.write(s.encode("ascii"))
+        self.read = lambda: self.buffer.read().decode("ascii")
+        self.readline = lambda: self.buffer.readline().decode("ascii")
+
+
+sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
+
+
+# endregion
+
+
+def main():
+    n, w = ints()
+    values = []
+    weights = []
+    for i in range(n):
+        a, b = ints()
+        values.append(b)
+        weights.append(a)
+    print(solve(n, w, values, weights))
+
+
+def solve(n, w, values, weights):
+    dp = [[0 for i in range(w + 1)] for i in range(n + 1)]
+    for i in range(n - 1, -1, -1):
+        for remW in range(w, -1, -1):
+            if remW - weights[i] < 0:
+                dp[i][remW] = dp[i + 1][remW]
+            else:
+                dp[i][remW] = max(dp[i + 1][remW], values[i] + dp[i + 1][remW - weights[i]])
+    return dp[0][w]
+
+if __name__ == "__main__":
+    main()
Index: USACO GUIDE/GOLD/DP/AC - B - Frog 2.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/USACO GUIDE/GOLD/DP/AC - B - Frog 2.py b/USACO GUIDE/GOLD/DP/AC - B - Frog 2.py
new file mode 100644
--- /dev/null	(date 1732663707023)
+++ b/USACO GUIDE/GOLD/DP/AC - B - Frog 2.py	(date 1732663707023)
@@ -0,0 +1,160 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+from types import GeneratorType
+
+#input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+
+# region fastio
+
+BUFSIZE = 8192
+
+
+class FastIO(IOBase):
+    newlines = 0
+
+    def __init__(self, file):
+        self._file = file
+        self._fd = file.fileno()
+        self.buffer = BytesIO()
+        self.writable = "x" in file.mode or "r" not in file.mode
+        self.write = self.buffer.write if self.writable else None
+
+    def read(self):
+        while True:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            if not b:
+                break
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines = 0
+        return self.buffer.read()
+
+    def readline(self):
+        while self.newlines == 0:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            self.newlines = b.count(b"\n") + (not b)
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines -= 1
+        return self.buffer.readline()
+
+    def flush(self):
+        if self.writable:
+            os.write(self._fd, self.buffer.getvalue())
+            self.buffer.truncate(0), self.buffer.seek(0)
+
+
+class IOWrapper(IOBase):
+    def __init__(self, file):
+        self.buffer = FastIO(file)
+        self.flush = self.buffer.flush
+        self.writable = self.buffer.writable
+        self.write = lambda s: self.buffer.write(s.encode("ascii"))
+        self.read = lambda: self.buffer.read().decode("ascii")
+        self.readline = lambda: self.buffer.readline().decode("ascii")
+
+
+#sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
+
+
+# endregion
+
+
+def main():
+    n, k = ints()
+    a = list(ints())
+    print(solve(n, a, k))
+
+
+
+
+
+def solve(n ,a, k ):
+    dp = [INF] * (n+1)
+    dp[-1] = 0
+    dp[-2] = 0
+    for i in range(n-2, -1, -1):
+        for j in range(1, k + 1):
+            if i + j < n:
+                dp[i] = min(dp[i], abs(a[i] - a[i + j]) + (dp[i + j]))
+
+    return dp[0]
+    """@lru_cache(maxsize=None)
+    def dp(i):
+        if i == n - 1:
+            return 0
+        else:
+            ans = INF
+            for j in range(1, k+1):
+                if i + j < n:
+                    ans = min(ans, abs(a[i] - a[i + j]) + (dp(i + j)))
+            return ans"""
+
+    return dp(0)
+
+if __name__ == "__main__":
+    main()
Index: USACO GUIDE/GOLD/DP/AC - C - Vacation.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/USACO GUIDE/GOLD/DP/AC - C - Vacation.py b/USACO GUIDE/GOLD/DP/AC - C - Vacation.py
new file mode 100644
--- /dev/null	(date 1732668232888)
+++ b/USACO GUIDE/GOLD/DP/AC - C - Vacation.py	(date 1732668232888)
@@ -0,0 +1,156 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+from types import GeneratorType
+
+input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+
+# region fastio
+
+BUFSIZE = 8192
+
+
+class FastIO(IOBase):
+    newlines = 0
+
+    def __init__(self, file):
+        self._file = file
+        self._fd = file.fileno()
+        self.buffer = BytesIO()
+        self.writable = "x" in file.mode or "r" not in file.mode
+        self.write = self.buffer.write if self.writable else None
+
+    def read(self):
+        while True:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            if not b:
+                break
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines = 0
+        return self.buffer.read()
+
+    def readline(self):
+        while self.newlines == 0:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            self.newlines = b.count(b"\n") + (not b)
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines -= 1
+        return self.buffer.readline()
+
+    def flush(self):
+        if self.writable:
+            os.write(self._fd, self.buffer.getvalue())
+            self.buffer.truncate(0), self.buffer.seek(0)
+
+
+class IOWrapper(IOBase):
+    def __init__(self, file):
+        self.buffer = FastIO(file)
+        self.flush = self.buffer.flush
+        self.writable = self.buffer.writable
+        self.write = lambda s: self.buffer.write(s.encode("ascii"))
+        self.read = lambda: self.buffer.read().decode("ascii")
+        self.readline = lambda: self.buffer.readline().decode("ascii")
+
+
+#sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
+
+
+# endregion
+
+
+def main():
+    n = int(input())
+    a, b, c = [], [], []
+    for i in range(n):
+        ai,bi,ci = ints()
+        a.append(ai)
+        b.append(bi)
+        c.append(ci)
+    print(solve(n, a, b, c))
+
+
+
+def solve(n ,a, b, c ):
+    dp = [[0,0,0] for i in range(n+1)]
+    dp[-1][-1] = 0
+    dp[-1][-2] = 0
+    dp[-1][-2] = 0
+    for i in range(n-1, -1, -1):
+        for type in range(3):
+            if type == 0:
+                dp[i][type] = max(dp[i][type], a[i] + dp[i + 1][ type + 1], a[i] + dp[i + 1][ type + 2])
+            if type == 1:
+                dp[i][type] = max(dp[i][type], b[i] + dp[i + 1][ type - 1], b[i] + dp[i + 1][ type + 1])
+            if type == 2:
+                dp[i][type] = max(dp[i][type], c[i] + dp[i + 1][ type - 1], c[i] + dp[i + 1][ type - 2])
+    return max(dp[0][0], dp[0][1], dp[0][2])
+
+
+if __name__ == "__main__":
+    main()
Index: USACO GUIDE/GOLD/Shortest Paths with Unweighted Edges/CowAtLarge.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/USACO GUIDE/GOLD/Shortest Paths with Unweighted Edges/CowAtLarge.py b/USACO GUIDE/GOLD/Shortest Paths with Unweighted Edges/CowAtLarge.py
new file mode 100644
--- /dev/null	(date 1727543685572)
+++ b/USACO GUIDE/GOLD/Shortest Paths with Unweighted Edges/CowAtLarge.py	(date 1727543685572)
@@ -0,0 +1,86 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+
+input = lambda: sys.stdin.readline().strip()
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+def main():
+    #sys.stdin = open('atlarge.in', 'r')
+    #sys.stdout = open('atlarge.out', 'w')
+    n, k = ints()
+    AL =  [[] for i in range(n+1)]
+    for i in range(n-1):
+        u, v = ints()
+        AL[u].append(v)
+        AL[v].append(u)
+    exits = [u for u in range(1, n+1) if len(AL[u]) == 1]
+    dist_f = [INF] * (n+1)
+    queue = deque([*exits])
+    for u in exits:
+        dist_f[u] = 0
+    while queue:
+        u = queue.pop()
+        for v in AL[u]:
+            if dist_f[v] == INF:
+                dist_f[v] = dist_f[u] + 1
+                queue.appendleft(v)
+
+    dist_c = [INF] * (n + 1)
+    queue = deque([k])
+    dist_c[k] = 0
+    ans = 0
+    while queue:
+        u = queue.pop()
+        if dist_f[u] <= dist_c[u]:
+            ans+=1
+            continue
+        for v in AL[u]:
+            if dist_c[v] == INF:
+                dist_c[v] = dist_c[u] + 1
+                queue.appendleft(v)
+    print(ans)
+
+if __name__ == "__main__":
+    main()
Index: Bootcamp/CPC 6/F.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Bootcamp/CPC 6/F.py b/Bootcamp/CPC 6/F.py
new file mode 100644
--- /dev/null	(date 1726349341954)
+++ b/Bootcamp/CPC 6/F.py	(date 1726349341954)
@@ -0,0 +1,75 @@
+def hopcroft_karp(graph, n, m):
+    """
+    Maximum bipartite matching using Hopcroft-Karp algorithm, running in O(|E| sqrt(|V|))
+    """
+    assert (n == len(graph))
+    match1 = [-1] * n
+    match2 = [-1] * m
+
+    # Find a greedy match for possible speed up
+    for node in range(n):
+        for nei in graph[node]:
+            if match2[nei] == -1:
+                match1[node] = nei
+                match2[nei] = node
+                break
+    while 1:
+        bfs = [node for node in range(n) if match1[node] == -1]
+        depth = [-1] * n
+        for node in bfs:
+            depth[node] = 0
+
+        for node in bfs:
+            for nei in graph[node]:
+                next_node = match2[nei]
+                if next_node == -1:
+                    break
+                if depth[next_node] == -1:
+                    depth[next_node] = depth[node] + 1
+                    bfs.append(next_node)
+            else:
+                continue
+            break
+        else:
+            break
+
+        pointer = [len(c) for c in graph]
+        dfs = [node for node in range(n) if depth[node] == 0]
+        while dfs:
+            node = dfs[-1]
+            while pointer[node]:
+                pointer[node] -= 1
+                nei = graph[node][pointer[node]]
+                next_node = match2[nei]
+                if next_node == -1:
+                    # Augmenting path found
+                    while nei != -1:
+                        node = dfs.pop()
+                        match2[nei], match1[node], nei = node, nei, match1[node]
+                    break
+                elif depth[node] + 1 == depth[next_node]:
+                    dfs.append(next_node)
+                    break
+            else:
+                dfs.pop()
+    return match1, match2
+
+
+t = int(input())
+
+for _ in range(t):
+    n, *a = map(int, input().split())
+    a_ = {a[i]: i+1 for i in range(n)}
+    m, *b = map(int, input().split())
+    b_ = {b[i]: n+i+1 for i in range(len(b))}
+
+    AL = [[] for i in range(n + m + 1)]
+    for i in range(len(a)):
+        for j in range(len(b)):
+            if b[j] == 0 or (a[i] and b[j] % a[i] == 0):
+                AL[i].append(j + n)
+                #AL[j + n].append(i)
+
+    #print(hopcrfot_karp(AL, n+m + 5, n+m + 5))
+    #print(sum(1 for it in hopcrfot_karp(AL, n+m + 5, n+m + 5)[0] if it != -1))
+    print("Case " + str(_+1) + ": " + str((sum(1 for it in hopcroft_karp(AL, len(AL), len(AL))[1] if it != -1))))
Index: Bootcamp/CPC 11/K.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Bootcamp/CPC 11/K.py b/Bootcamp/CPC 11/K.py
new file mode 100644
--- /dev/null	(date 1730674783773)
+++ b/Bootcamp/CPC 11/K.py	(date 1730674783773)
@@ -0,0 +1,29 @@
+from itertools import accumulate
+from bisect import bisect_left
+t = int(input())
+for _ in range(t):
+    n, k = map(int, input().split())
+    a = list(map(int, input().split()))
+    prefix = [0] * (n)
+    prefix[0] = 1
+    for i in range(1, n):
+        if a[i] != a[i-1]:
+            prefix[i] = prefix[i-1] + 1
+        else:
+            prefix[i] = prefix[i - 1]
+    prefix = [0] + prefix
+    a = [ 0] + sorted(list(set(a)))
+    prefix = sorted(list(set(prefix)))
+    print(f"Case {_ + 1}:")
+    for q in range(k):
+        x, y = map(int, input().split())
+        index_a = bisect_left(a, x)
+        index_b = bisect_left(a, y)
+
+        if index_b == n+1:
+            index_b -= 1
+        if a[index_b] > y:
+            index_b -= 1
+
+        print(prefix[index_b] - prefix[index_a - (1 if x != 0 else 0)])
+
Index: ICPC Preparation/Graph/Finding Articulation PointsBridges/12363 - Hedge Mazes.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import os\r\nimport sys\r\nfrom collections import *\r\nfrom heapq import *\r\nfrom math import gcd, floor, ceil, sqrt\r\nfrom copy import deepcopy\r\nfrom itertools import permutations, combinations, product\r\nfrom bisect import bisect_left, bisect_right\r\nfrom functools import lru_cache, reduce\r\nimport operator\r\n\r\n# Para mejorar el rendimiento de la entrada/salida\r\ninput = lambda: sys.stdin.readline().strip()\r\nflush = lambda: sys.stdout.flush()\r\nprint = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get(\"end\", \"\\n\")) and flush()\r\n\r\n# Optimización de la recursión para Python\r\nsys.setrecursionlimit(100000)\r\n\r\n\r\n# Funciones para lectura de múltiples tipos de datos\r\ndef ints(): return map(int, input().split())\r\ndef strs(): return input().split()\r\ndef chars(): return list(input().strip())\r\ndef mat(n): return [list(ints()) for _ in range(n)]  # Matriz de n x m donde m es el número de enteros en una línea\r\n\r\n\r\n# Constantes útiles\r\nINF = float('inf')\r\nMOD = 1000000007  # Modulo por defecto, cambiar si se necesita otro\r\n\r\n\r\n# Algunas funciones útiles\r\ndef add(x, y, mod=MOD): return (x + y) % mod\r\ndef sub(x, y, mod=MOD): return (x - y) % mod\r\ndef mul(x, y, mod=MOD): return (x * y) % mod\r\n\r\n\r\n# Fast power - a^b % mod\r\ndef powmod(a, b, mod=MOD):\r\n    res = 1\r\n    a = a % mod\r\n    while b > 0:\r\n        if b % 2:\r\n            res = mul(res, a, mod)\r\n        a = mul(a, a, mod)\r\n        b //= 2\r\n    return res\r\n\r\n\r\n# Inverso multiplicativo de a modulo m (cuando m es primo)\r\ndef invmod(a, mod=MOD): return powmod(a, mod - 2, mod)\r\n\r\n\r\n# GCD y LCM\r\ndef lcm(a, b): return a * b // gcd(a, b)\r\n\r\n\r\n# Factorial con memoización\r\n@lru_cache(maxsize=None)\r\ndef factorial(n): return n * factorial(n - 1) if n else 1\r\n\r\n\r\n# Combinaciones con memoización (nCr)\r\n@lru_cache(maxsize=None)\r\ndef comb(n, r):\r\n    if r == 0 or r == n: return 1\r\n    return comb(n - 1, r - 1) + comb(n - 1, r)\r\n\r\nans = []\r\nmap1 = {}\r\ndef main():\r\n    global ans\r\n    global map1\r\n    while True:\r\n        r, c, q = ints()\r\n        if r == c== q == 0:\r\n            break\r\n        AL = [[] for _ in range(r + 1)]\r\n        for _ in range(c):\r\n            u, v = ints()\r\n            AL[u].append(v)\r\n            AL[v].append(u)\r\n        #print(AL)\r\n\r\n        for i in range(q):\r\n            ans = []\r\n            map1 = {}\r\n            a, b = ints()\r\n            dfs(AL, a, b)\r\n            print(\"Y\" if len(ans) == 1 else \"N\")\r\n        print(\"-\")\r\n\r\n\r\ndef dfs(graph, current, destination, visited=set(), path=[]):\r\n    global ans\r\n    path.append(current)\r\n    if current == destination:\r\n        st = \" \".join(map(str, path))\r\n        if not map1.get(st):\r\n            ans.append(path)\r\n            map1[st] = True\r\n    visited.add(current)\r\n    for neighbor in graph[current]:\r\n        if neighbor not in visited:\r\n            dfs(graph, neighbor, destination, visited.copy(), path.copy())\r\n    path.pop()\r\n    visited.remove(current)\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    main()\r\n\r\n\r\n\r\n\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ICPC Preparation/Graph/Finding Articulation PointsBridges/12363 - Hedge Mazes.py b/ICPC Preparation/Graph/Finding Articulation PointsBridges/12363 - Hedge Mazes.py
--- a/ICPC Preparation/Graph/Finding Articulation PointsBridges/12363 - Hedge Mazes.py	(revision bc7ab91df3db33c143ee3ebd32c794cf710fdacb)
+++ b/ICPC Preparation/Graph/Finding Articulation PointsBridges/12363 - Hedge Mazes.py	(date 1734490331278)
@@ -8,6 +8,7 @@
 from bisect import bisect_left, bisect_right
 from functools import lru_cache, reduce
 import operator
+from enum import Enum
 
 # Para mejorar el rendimiento de la entrada/salida
 input = lambda: sys.stdin.readline().strip()
@@ -67,11 +68,46 @@
     if r == 0 or r == n: return 1
     return comb(n - 1, r - 1) + comb(n - 1, r)
 
+
+class flag(Enum):
+  UNVISITED = -1
+
+class DisjointSetUnion:
+    def __init__(self, n):
+        self.parent = list(range(n))
+        self.size = [1] * n
+        self.num_sets = n
+
+    def find(self, a):
+        acopy = a
+        while a != self.parent[a]:
+            a = self.parent[a]
+        while acopy != a:
+            self.parent[acopy], acopy = a, self.parent[acopy]
+        return a
+
+    def union(self, a, b):
+        a, b = self.find(a), self.find(b)
+        if a != b:
+            if self.size[a] < self.size[b]:
+                a, b = b, a
+
+            self.num_sets -= 1
+            self.parent[b] = a
+            self.size[a] += self.size[b]
+
+    def set_size(self, a):
+        return self.size[self.find(a)]
+
+    def __len__(self):
+        return self.num_sets
+
 ans = []
 map1 = {}
 def main():
     global ans
     global map1
+    res = []
     while True:
         r, c, q = ints()
         if r == c== q == 0:
@@ -82,32 +118,52 @@
             AL[u].append(v)
             AL[v].append(u)
         #print(AL)
+        uf = DisjointSetUnion(r+1)
+        dfs_num = []
+        dfs_low = []
+        dfs_parent = []
+        articulation_vertex = []
+        dfsNumberCounter = 0
+        dfsRoot = 0
+        rootChildren = 0
+        V = r + 1
+        dfs_num = [flag.UNVISITED.value] * V
+        dfs_low = [0] * V
+        dfs_parent = [-1] * V
+        articulation_vertex = [False] * V
+        dfsNumberCounter = 0
+        bridges = []
+        def articulationPointAndBridge(u):
+            nonlocal AL
+            nonlocal dfs_num, dfs_parent, dfs_low, articulation_vertex
+            nonlocal dfsNumberCounter, dfsRoot, rootChildren
 
+            dfs_low[u] = dfs_num[u] = dfsNumberCounter
+            dfsNumberCounter += 1
+            for v in AL[u]:
+                if dfs_num[v] == flag.UNVISITED.value:
+                    dfs_parent[v] = u
+                    if u == dfsRoot:
+                        rootChildren += 1
+                    articulationPointAndBridge(v)
+                    if dfs_low[v] >= dfs_num[u]:
+                        articulation_vertex[u] = True
+                    if dfs_low[v] > dfs_num[u]:
+                        uf.union(u, v)
+                        #print(' Edge (%d, %d) is a bridge' % (u, v))
+                    dfs_low[u] = min(dfs_low[u], dfs_low[v])
+                elif v != dfs_parent[u]:
+                    dfs_low[u] = min(dfs_low[u], dfs_num[v])
+        for u in range(r+1):
+            if dfs_num[u] != flag.UNVISITED:
+                articulationPointAndBridge(u)
         for i in range(q):
-            ans = []
-            map1 = {}
-            a, b = ints()
-            dfs(AL, a, b)
-            print("Y" if len(ans) == 1 else "N")
-        print("-")
-
-
-def dfs(graph, current, destination, visited=set(), path=[]):
-    global ans
-    path.append(current)
-    if current == destination:
-        st = " ".join(map(str, path))
-        if not map1.get(st):
-            ans.append(path)
-            map1[st] = True
-    visited.add(current)
-    for neighbor in graph[current]:
-        if neighbor not in visited:
-            dfs(graph, neighbor, destination, visited.copy(), path.copy())
-    path.pop()
-    visited.remove(current)
-
-
+            u,v = ints()
+            if uf.find(u) == uf.find(v):
+                res.append("Y")
+            else: res.append("N")
+        res.append("-")
+    print("\n".join(res))
 if __name__ == "__main__":
     main()
 
Index: Bootcamp/RPC 12 Nov/D.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Bootcamp/RPC 12 Nov/D.py b/Bootcamp/RPC 12 Nov/D.py
new file mode 100644
--- /dev/null	(date 1730589165755)
+++ b/Bootcamp/RPC 12 Nov/D.py	(date 1730589165755)
@@ -0,0 +1,63 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+
+input = lambda: sys.stdin.readline().strip()
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+def main():
+    t = int(input())
+    for _ in range(t):
+        n = int(input())
+        a = list(ints())
+        print(solve(n, a))
+
+
+def solve(n ,a ):
+    pass
+
+
+
+if __name__ == "__main__":
+    main()
Index: Bootcamp/RPC 12 Nov/C.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Bootcamp/RPC 12 Nov/C.py b/Bootcamp/RPC 12 Nov/C.py
new file mode 100644
--- /dev/null	(date 1730581201808)
+++ b/Bootcamp/RPC 12 Nov/C.py	(date 1730581201808)
@@ -0,0 +1,13 @@
+from functools import lru_cache
+N, K = map(int, input().split())
+length = N * K
+a = list(map(int, input().split()))
+b = list(map(int, input().split()))
+@lru_cache(maxsize=None)
+def dp(i, j):
+    if i >= length or j >= length:
+        return 0
+    if (a[i] == b[j]):
+        return 1 + dp(i + 1, j + 1)
+    return max(dp(i + 1, j), dp(i, j + 1))
+print(dp(0, 0))
\ No newline at end of file
Index: Bootcamp/IEEE Tech/C.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Bootcamp/IEEE Tech/C.py b/Bootcamp/IEEE Tech/C.py
new file mode 100644
--- /dev/null	(date 1728789595057)
+++ b/Bootcamp/IEEE Tech/C.py	(date 1728789595057)
@@ -0,0 +1,34 @@
+from collections import defaultdict
+n = int(input())
+AL = defaultdict(list)
+nodes = set()
+for i in range(n):
+    c = list(map(str, input().split()))
+    if c[1] == "->":
+        AL[c[0]].append(c[2])
+    else:
+        AL[c[0]].append(c[2])
+        AL[c[2]].append(c[0])
+    nodes.add(c[0])
+    nodes.add(c[2])
+
+memo = {}
+visited = {node: 0 for node in nodes}
+def dfs(node):
+    if visited[node] == 2:
+        return memo[node]
+    if visited[node] == 1:
+        return 0
+    visited[node] = 1
+    total_reachable = 1
+    for neighbor in AL[node]:
+        total_reachable += dfs(neighbor)
+    visited[node] = 2
+    memo[node] = total_reachable
+    return total_reachable
+
+for node in list(AL):
+    if visited[node] == 0:
+        dfs(node)
+ans = [it for it in memo.keys() if memo[it]>= n]
+print("\n".join(sorted(ans)), memo)
\ No newline at end of file
Index: USACO GUIDE/BRONZE/Complete Search with Recursion/LivestockLineup.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import os\r\nimport sys\r\nfrom collections import *\r\nfrom heapq import *\r\nfrom math import gcd, floor, ceil, sqrt\r\nfrom copy import deepcopy\r\nfrom itertools import permutations, combinations, product\r\nfrom bisect import bisect_left, bisect_right\r\nfrom functools import lru_cache, reduce\r\nimport operator\r\nfrom random import getrandbits\r\n\r\n# Para mejorar el rendimiento de la entrada/salida\r\ninput = lambda: sys.stdin.readline().strip()\r\nflush = lambda: sys.stdout.flush()\r\nprint = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get(\"end\", \"\\n\")) and flush()\r\n\r\n# Optimización de la recursión para Python\r\nsys.setrecursionlimit(100000)\r\n\r\n\r\n# Funciones para lectura de múltiples tipos de datos\r\ndef ints(): return map(int, input().split())\r\ndef strs(): return input().split()\r\ndef chars(): return list(input().strip())\r\ndef mat(n): return [list(ints()) for _ in range(n)]  # Matriz de n x m donde m es el número de enteros en una línea\r\n\r\n\r\n# Constantes útiles\r\nINF = float('inf')\r\nMOD = 1000000007  # Modulo por defecto, cambiar si se necesita otro\r\nabcd = \"abcdefghijklmnopqrstuvwxyz\"\r\n\r\n# Algunas funciones útiles\r\ndef add(x, y, mod=MOD): return (x + y) % mod\r\ndef sub(x, y, mod=MOD): return (x - y) % mod\r\ndef mul(x, y, mod=MOD): return (x * y) % mod\r\n\r\n# Inverso multiplicativo de a modulo m (cuando m es primo)\r\ndef invmod(a, mod=MOD): return powmod(a, mod - 2, mod)\r\n\r\ndef lcm(a, b): return a * b // gcd(a, b)\r\n\r\nRANDOM = getrandbits(32)\r\n\r\nclass Wrapper(int):\r\n    def __init__(self, x):\r\n        int.__init__(x)\r\n    def __hash__(self):\r\n        return super(Wrapper, self).__hash__() ^ RANDOM\r\n\r\nnames = [\"Bessie\", \"Buttercup\", \"Belinda\", \"Beatrice\", \"Bella\", \"Blue\", \"Betsy\", \"Sue\"]\r\nAL = []\r\nvisited = []\r\ndepth = []\r\ndef dfs(u, d, p = False):\r\n    global visited, AL, depth\r\n    if p ==  True: print(names[u])\r\n    visited[u] = True\r\n    depth[u] = (d, u)\r\n    for v in AL[u]:\r\n        if not visited[v]:\r\n            dfs(v, d+1)\r\ndef main():\r\n    global visited, AL, depth\r\n    sys.stdin = open('lineup.in', 'r')\r\n    sys.stdout = open('lineup.out', 'w')\r\n    n = int(input())\r\n    AL = defaultdict(list)\r\n    mapper = {names[i]: i for i in range(8)}\r\n    for i in range(n):\r\n        aux = list(input().split())\r\n        AL[mapper[aux[0]]].append(mapper[aux[-1]])\r\n        AL[mapper[aux[-1]]].append(mapper[aux[0]])\r\n    visited = [False] * 8\r\n    depth = [0] * 8\r\n    for i in range(8):\r\n        if not visited[i]:\r\n            dfs(i, 0)\r\n    depth.sort(reverse=True)\r\n    visited = [False] * 8\r\n    for d, u in depth:\r\n        dfs(u, 0,  True)\r\n\r\n\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    main()\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/USACO GUIDE/BRONZE/Complete Search with Recursion/LivestockLineup.py b/USACO GUIDE/BRONZE/Complete Search with Recursion/LivestockLineup.py
--- a/USACO GUIDE/BRONZE/Complete Search with Recursion/LivestockLineup.py	(revision bc7ab91df3db33c143ee3ebd32c794cf710fdacb)
+++ b/USACO GUIDE/BRONZE/Complete Search with Recursion/LivestockLineup.py	(date 1733928669797)
@@ -1,89 +1,31 @@
-import os
+from itertools import permutations
 import sys
-from collections import *
-from heapq import *
-from math import gcd, floor, ceil, sqrt
-from copy import deepcopy
-from itertools import permutations, combinations, product
-from bisect import bisect_left, bisect_right
-from functools import lru_cache, reduce
-import operator
-from random import getrandbits
-
-# Para mejorar el rendimiento de la entrada/salida
-input = lambda: sys.stdin.readline().strip()
-flush = lambda: sys.stdout.flush()
-print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
-
-# Optimización de la recursión para Python
-sys.setrecursionlimit(100000)
-
-
-# Funciones para lectura de múltiples tipos de datos
-def ints(): return map(int, input().split())
-def strs(): return input().split()
-def chars(): return list(input().strip())
-def mat(n): return [list(ints()) for _ in range(n)]  # Matriz de n x m donde m es el número de enteros en una línea
 
-
-# Constantes útiles
-INF = float('inf')
-MOD = 1000000007  # Modulo por defecto, cambiar si se necesita otro
-abcd = "abcdefghijklmnopqrstuvwxyz"
-
-# Algunas funciones útiles
-def add(x, y, mod=MOD): return (x + y) % mod
-def sub(x, y, mod=MOD): return (x - y) % mod
-def mul(x, y, mod=MOD): return (x * y) % mod
-
-# Inverso multiplicativo de a modulo m (cuando m es primo)
-def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
-
-def lcm(a, b): return a * b // gcd(a, b)
-
-RANDOM = getrandbits(32)
-
-class Wrapper(int):
-    def __init__(self, x):
-        int.__init__(x)
-    def __hash__(self):
-        return super(Wrapper, self).__hash__() ^ RANDOM
-
-names = ["Bessie", "Buttercup", "Belinda", "Beatrice", "Bella", "Blue", "Betsy", "Sue"]
-AL = []
-visited = []
-depth = []
-def dfs(u, d, p = False):
-    global visited, AL, depth
-    if p ==  True: print(names[u])
-    visited[u] = True
-    depth[u] = (d, u)
-    for v in AL[u]:
-        if not visited[v]:
-            dfs(v, d+1)
 def main():
-    global visited, AL, depth
     sys.stdin = open('lineup.in', 'r')
     sys.stdout = open('lineup.out', 'w')
     n = int(input())
-    AL = defaultdict(list)
-    mapper = {names[i]: i for i in range(8)}
-    for i in range(n):
-        aux = list(input().split())
-        AL[mapper[aux[0]]].append(mapper[aux[-1]])
-        AL[mapper[aux[-1]]].append(mapper[aux[0]])
-    visited = [False] * 8
-    depth = [0] * 8
-    for i in range(8):
-        if not visited[i]:
-            dfs(i, 0)
-    depth.sort(reverse=True)
-    visited = [False] * 8
-    for d, u in depth:
-        dfs(u, 0,  True)
-
-
+    constraints = []
+    for _ in range(n):
+        words = input().strip().split()
+        cow1 = words[0]
+        cow2 = words[-1]
+        constraints.append((cow1, cow2))
+    cows = ["Beatrice", "Belinda", "Bessie", "Betsy", "Blue", "Buttercup", "Sue", "Bella"]
+    cows.sort()
+    for perm in permutations(cows):
+        valid = True
+        for cow1, cow2 in constraints:
+            idx1 = perm.index(cow1)
+            idx2 = perm.index(cow2)
+            if abs(idx1 - idx2) != 1:
+                valid = False
+                break
+        if valid:
+            for cow in perm:
+                print(cow)
+            break
 
 
 if __name__ == "__main__":
-    main()
+    main()
\ No newline at end of file
Index: Bootcamp/CPC 11/F.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Bootcamp/CPC 11/F.py b/Bootcamp/CPC 11/F.py
new file mode 100644
--- /dev/null	(date 1730684293585)
+++ b/Bootcamp/CPC 11/F.py	(date 1730684293585)
@@ -0,0 +1,50 @@
+import datetime
+#from datetime import _is_leap
+
+def _is_leap(year):
+    "year -> 1 if leap year, else 0."
+    return year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)
+
+t = int(input())
+res = []
+for _ in range(t):
+    mapper = {"January": 1, "February": 2, "March": 3, "April": 4, "May": 5, "June": 6, "July": 7, "August": 8,
+              "September": 9, "October": 10, "November": 11, "December": 12}
+    s1 = input()
+    s2 = input()
+    date0 = s1.split(",")
+    date1 = s2.split(",")
+    #print(date0, date1)
+    date0_month = date0[0].split(" ")[0]
+    date0_day = date0[0].split(" ")[1]
+    date0_year = date0[1]
+    #print(datetime.date(int(date0_year), mapper[date0_month], int(date0_day)))
+    date1_month = date1[0].split(" ")[0]
+    date1_day = date1[0].split(" ")[1]
+    date1_year = date1[1]
+    date0_day = int(date0_day)
+    date0_year = int(date0_year)
+    date1_day = int(date1_day)
+    date1_year = int(date1_year)
+    date0_month_int = mapper[date0_month]
+    date1_month_int = mapper[date1_month]
+    if date0_year < date1_year or (date0_year == date1_year and date0_month_int < date1_month_int) or (
+            date0_year == date1_year and date0_month_int == date1_month_int and date0_day < date1_day):
+        first_date = [date0_year, date0_month_int, date0_day]
+        second_date = [date1_year, date1_month_int, date1_day]
+    else:
+        first_date = [date1_year, date1_month_int, date1_day]
+        second_date = [date0_year, date0_month_int, date0_day]
+    ans = 0
+    if first_date[1] > 2:
+        first_date[0] += 1
+
+    if second_date[1] < 2 or (
+            second_date[1] == 2 and second_date[2] < 29):
+        second_date[0] -= 1
+    #di
+    first_date[0] -= 1
+    ans += second_date[0] // 4 - second_date[0] // 100 + second_date[0] // 400
+    ans -= first_date[0] // 4 - first_date[0] // 100 + first_date[0] // 400
+    res.append(f"Case {_+1}: {ans}")
+print("\n".join(res))
\ No newline at end of file
Index: Bootcamp/2022-2023 ACM-ICPC Latin American Regional Programming Contest/D.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Bootcamp/2022-2023 ACM-ICPC Latin American Regional Programming Contest/D.py b/Bootcamp/2022-2023 ACM-ICPC Latin American Regional Programming Contest/D.py
new file mode 100644
--- /dev/null	(date 1730931066480)
+++ b/Bootcamp/2022-2023 ACM-ICPC Latin American Regional Programming Contest/D.py	(date 1730931066480)
@@ -0,0 +1,67 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+
+input = lambda: sys.stdin.readline().strip()
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+def main():
+    n, h, w = ints()
+    for i in range(n):
+        go, back = strs()
+        ans_go, ans_back = "N", "N"
+        if go == "Y" and h or go  == "N" and not w:
+            w += 1
+            h-=1
+            ans_go = "Y"
+        if back == "Y" and w or back == "N" and not h:
+            w -= 1
+            h += 1
+            ans_back = "Y"
+        print(ans_go, ans_back)
+
+
+
+if __name__ == "__main__":
+    main()
Index: USACO GUIDE/BRONZE/Complete Search/SleepingInClass.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import os\r\nimport sys\r\nfrom collections import *\r\nfrom heapq import *\r\nfrom math import gcd, floor, ceil, sqrt\r\nfrom copy import deepcopy\r\nfrom itertools import permutations, combinations, product\r\nfrom bisect import bisect_left, bisect_right\r\nfrom functools import lru_cache, reduce\r\nimport operator\r\nfrom random import getrandbits\r\n\r\n# Para mejorar el rendimiento de la entrada/salida\r\ninput = lambda: sys.stdin.readline().strip()\r\nflush = lambda: sys.stdout.flush()\r\nprint = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get(\"end\", \"\\n\")) and flush()\r\n\r\n# Optimización de la recursión para Python\r\nsys.setrecursionlimit(100000)\r\n\r\n\r\n# Funciones para lectura de múltiples tipos de datos\r\ndef ints(): return map(int, input().split())\r\n\r\n\r\ndef strs(): return input().split()\r\n\r\n\r\ndef chars(): return list(input().strip())\r\n\r\n\r\ndef mat(n): return [list(ints()) for _ in range(n)]  # Matriz de n x m donde m es el número de enteros en una línea\r\n\r\n\r\n# Constantes útiles\r\nINF = float('inf')\r\nMOD = 1000000007  # Modulo por defecto, cambiar si se necesita otro\r\nabcd = \"abcdefghijklmnopqrstuvwxyz\"\r\n\r\n\r\n# Algunas funciones útiles\r\ndef add(x, y, mod=MOD): return (x + y) % mod\r\n\r\n\r\ndef sub(x, y, mod=MOD): return (x - y) % mod\r\n\r\n\r\ndef mul(x, y, mod=MOD): return (x * y) % mod\r\n\r\n\r\n# Inverso multiplicativo de a modulo m (cuando m es primo)\r\ndef invmod(a, mod=MOD): return powmod(a, mod - 2, mod)\r\n\r\n\r\ndef lcm(a, b): return a * b // gcd(a, b)\r\n\r\n\r\nRANDOM = getrandbits(32)\r\n\r\n\r\nclass Wrapper(int):\r\n    def __init__(self, x):\r\n        int.__init__(x)\r\n\r\n    def __hash__(self):\r\n        return super(Wrapper, self).__hash__() ^ RANDOM\r\n\r\n\r\ndef main():\r\n    #sys.stdin = open('circlecross.in', 'r')\r\n    #sys.stdout = open('circlecross.out', 'w')\r\n    t = int(input())\r\n    for _ in range(t):\r\n        n = int(input())\r\n        a = list(ints())\r\n        sum_ = sum(a)\r\n        ans = INF\r\n        for l in range(sum_ + 1):\r\n            if l != 0 and sum_ % l != 0:\r\n                continue\r\n            curr = 0\r\n            flag = True\r\n            for it in a:\r\n                curr += it\r\n                if curr > l:\r\n                    flag = False\r\n                    break\r\n                elif curr == l:\r\n                    curr = 0\r\n            if flag:\r\n                if l == 0:\r\n                    ans = 0\r\n                else:\r\n                    ans = n - sum_ // l\r\n                break\r\n        print(ans)\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    main()\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/USACO GUIDE/BRONZE/Complete Search/SleepingInClass.py b/USACO GUIDE/BRONZE/Complete Search/SleepingInClass.py
--- a/USACO GUIDE/BRONZE/Complete Search/SleepingInClass.py	(revision bc7ab91df3db33c143ee3ebd32c794cf710fdacb)
+++ b/USACO GUIDE/BRONZE/Complete Search/SleepingInClass.py	(date 1733947593197)
@@ -65,7 +65,15 @@
     def __hash__(self):
         return super(Wrapper, self).__hash__() ^ RANDOM
 
-
+def can(target, a):
+    curr = 0
+    for num in a:
+        curr += num
+        if curr > target:
+            return False
+        elif curr == target:
+            curr = 0
+    return curr == 0
 def main():
     #sys.stdin = open('circlecross.in', 'r')
     #sys.stdout = open('circlecross.out', 'w')
@@ -75,25 +83,15 @@
         a = list(ints())
         sum_ = sum(a)
         ans = INF
-        for l in range(sum_ + 1):
-            if l != 0 and sum_ % l != 0:
-                continue
-            curr = 0
-            flag = True
-            for it in a:
-                curr += it
-                if curr > l:
-                    flag = False
-                    break
-                elif curr == l:
-                    curr = 0
-            if flag:
+        possible_ls = [l for l in range(1, sum_ + 1) if sum_ % l == 0]
+        for l in possible_ls:
+            if can(l, a):
                 if l == 0:
                     ans = 0
                 else:
                     ans = n - sum_ // l
                 break
-        print(ans)
+        print(0 if ans == INF else ans)
 
 
 if __name__ == "__main__":
Index: Bootcamp/CPC 11/H.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Bootcamp/CPC 11/H.py b/Bootcamp/CPC 11/H.py
new file mode 100644
--- /dev/null	(date 1730671752636)
+++ b/Bootcamp/CPC 11/H.py	(date 1730671752636)
@@ -0,0 +1,21 @@
+t = int(input())
+for _ in range(t):
+    n = int(input())
+    a = list(map(int, input().split()))
+    ans = 2
+    total = 0
+    index = 0
+    while ans < a[-1]:
+        if ans == a[index]:
+            index += 1
+            continue
+        if a[index] - ans < 5:
+            ans += a[index] - ans
+            total += 1
+            index += 1
+        else:
+            ans+= 5
+            total += 1
+
+
+    print(f"Case {_ +1}: {(total)}")
\ No newline at end of file
Index: Bootcamp/The 2024 ICPC Caribbean Finals (Qualifier) - Real Contest/C2.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Bootcamp/The 2024 ICPC Caribbean Finals (Qualifier) - Real Contest/C2.py b/Bootcamp/The 2024 ICPC Caribbean Finals (Qualifier) - Real Contest/C2.py
new file mode 100644
--- /dev/null	(date 1728432266901)
+++ b/Bootcamp/The 2024 ICPC Caribbean Finals (Qualifier) - Real Contest/C2.py	(date 1728432266901)
@@ -0,0 +1,24 @@
+from functools import lru_cache
+from collections import deque
+n = int(input())
+AL = [[] for i in range(n + 1)]
+mapper = {}
+edges = 1
+visited = [False] * (edges + 1)
+labels = [0] * (n+1)
+for i in range(n):
+    l, m, *u = map(int, input().split())
+    labels[i + 1] = l
+    for u_ in u:
+        AL[u_].append(i+1)
+
+q = deque([i for i, it in enumerate(labels) if it == 1])
+can = [None] * (n+1)
+while q:
+    u = q.popleft()
+    for v in AL[u]:
+        if can[v] is None:
+            can[v] = True
+            q.append(v)
+print(sum([1 for i, it in enumerate(can) if it and labels[i]]))
+#print(ans_ + 1 if ans_ == 49494 else ans_)
Index: Bootcamp/The 2024 ICPC Caribbean Finals (Qualifier) - Real Contest/J.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Bootcamp/The 2024 ICPC Caribbean Finals (Qualifier) - Real Contest/J.py b/Bootcamp/The 2024 ICPC Caribbean Finals (Qualifier) - Real Contest/J.py
new file mode 100644
--- /dev/null	(date 1728433381435)
+++ b/Bootcamp/The 2024 ICPC Caribbean Finals (Qualifier) - Real Contest/J.py	(date 1728433381435)
@@ -0,0 +1,25 @@
+def dfs(u, AL, can):
+    stack = [u]
+    while stack:
+        u = stack.pop()
+        for v in AL[u]:
+            if can[v] is None:
+                can[v] = True
+                stack.append(v)
+
+n = int(input())
+AL = [[] for i in range(n + 1)]
+labels = [0] * (n+1)
+for i in range(n):
+    l, m, *u = map(int, input().split())
+    labels[i + 1] = l
+    for u_ in u:
+        AL[u_].append(i+1)
+
+can = [None] * (n+1)
+
+for u in range(1, n+1):
+    if labels[u]:
+        dfs(u, AL, can)
+
+print(sum([1 for i, it in enumerate(can) if it and labels[i]]))
Index: Codeforces/Random/2035C - Alya and Permutation.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Codeforces/Random/2035C - Alya and Permutation.py b/Codeforces/Random/2035C - Alya and Permutation.py
new file mode 100644
--- /dev/null	(date 1730330400063)
+++ b/Codeforces/Random/2035C - Alya and Permutation.py	(date 1730330400063)
@@ -0,0 +1,63 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+
+input = lambda: sys.stdin.readline().strip()
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+def main():
+    t = int(input())
+    for _ in range(t):
+        n = int(input())
+        a = list(ints())
+        print(solve(n, a))
+
+
+def solve(n ,a ):
+    pass
+
+
+
+if __name__ == "__main__":
+    main()
Index: Codeforces/Educational Codeforces Round 172 (Rated for Div 2)/A.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Codeforces/Educational Codeforces Round 172 (Rated for Div 2)/A.py b/Codeforces/Educational Codeforces Round 172 (Rated for Div 2)/A.py
new file mode 100644
--- /dev/null	(date 1733150635288)
+++ b/Codeforces/Educational Codeforces Round 172 (Rated for Div 2)/A.py	(date 1733150635288)
@@ -0,0 +1,147 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+from types import GeneratorType
+
+input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+
+# region fastio
+
+BUFSIZE = 8192
+
+
+class FastIO(IOBase):
+    newlines = 0
+
+    def __init__(self, file):
+        self._file = file
+        self._fd = file.fileno()
+        self.buffer = BytesIO()
+        self.writable = "x" in file.mode or "r" not in file.mode
+        self.write = self.buffer.write if self.writable else None
+
+    def read(self):
+        while True:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            if not b:
+                break
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines = 0
+        return self.buffer.read()
+
+    def readline(self):
+        while self.newlines == 0:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            self.newlines = b.count(b"\n") + (not b)
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines -= 1
+        return self.buffer.readline()
+
+    def flush(self):
+        if self.writable:
+            os.write(self._fd, self.buffer.getvalue())
+            self.buffer.truncate(0), self.buffer.seek(0)
+
+
+class IOWrapper(IOBase):
+    def __init__(self, file):
+        self.buffer = FastIO(file)
+        self.flush = self.buffer.flush
+        self.writable = self.buffer.writable
+        self.write = lambda s: self.buffer.write(s.encode("ascii"))
+        self.read = lambda: self.buffer.read().decode("ascii")
+        self.readline = lambda: self.buffer.readline().decode("ascii")
+
+
+sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
+
+
+# endregion
+
+
+def main():
+    t = int(input())
+    for _ in range(t):
+        n, k = ints()
+        a = list(ints())
+        print(solve(n, k, a))
+
+
+def solve(n, k ,a ):
+    prefix = list(accumulate(sorted(a, reverse=True)))
+    ans = 0
+    for i in range(n):
+        if prefix[i] <= k:
+            ans = prefix[i]
+        else:
+            break
+    return k - ans
+
+
+if __name__ == "__main__":
+    main()
Index: Codeforces/Educational Codeforces Round 172 (Rated for Div 2)/B.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Codeforces/Educational Codeforces Round 172 (Rated for Div 2)/B.py b/Codeforces/Educational Codeforces Round 172 (Rated for Div 2)/B.py
new file mode 100644
--- /dev/null	(date 1733152719013)
+++ b/Codeforces/Educational Codeforces Round 172 (Rated for Div 2)/B.py	(date 1733152719013)
@@ -0,0 +1,145 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+from types import GeneratorType
+
+input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+
+# region fastio
+
+BUFSIZE = 8192
+
+
+class FastIO(IOBase):
+    newlines = 0
+
+    def __init__(self, file):
+        self._file = file
+        self._fd = file.fileno()
+        self.buffer = BytesIO()
+        self.writable = "x" in file.mode or "r" not in file.mode
+        self.write = self.buffer.write if self.writable else None
+
+    def read(self):
+        while True:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            if not b:
+                break
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines = 0
+        return self.buffer.read()
+
+    def readline(self):
+        while self.newlines == 0:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            self.newlines = b.count(b"\n") + (not b)
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines -= 1
+        return self.buffer.readline()
+
+    def flush(self):
+        if self.writable:
+            os.write(self._fd, self.buffer.getvalue())
+            self.buffer.truncate(0), self.buffer.seek(0)
+
+
+class IOWrapper(IOBase):
+    def __init__(self, file):
+        self.buffer = FastIO(file)
+        self.flush = self.buffer.flush
+        self.writable = self.buffer.writable
+        self.write = lambda s: self.buffer.write(s.encode("ascii"))
+        self.read = lambda: self.buffer.read().decode("ascii")
+        self.readline = lambda: self.buffer.readline().decode("ascii")
+
+
+#sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
+
+
+# endregion
+
+
+def main():
+    t = int(input())
+    for _ in range(t):
+        n = int(input())
+        a = list(ints())
+        print(solve(n, a))
+
+def solve(n ,a ):
+    frec = Counter(a)
+    s = sum(1 for v in frec.values() if v == 1)
+    mid = (n + 1) // 2
+    ans = ceil(s / 2)
+    ans = min(ans, mid, s)
+    rem = mid - ans
+    return  2 * ans + min(len(frec) - s, rem)
+
+
+if __name__ == "__main__":
+    main()
Index: Codeforces/Codeforces Round 981 (Div 3)/C.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Codeforces/Codeforces Round 981 (Div 3)/C.py b/Codeforces/Codeforces Round 981 (Div 3)/C.py
new file mode 100644
--- /dev/null	(date 1730330370040)
+++ b/Codeforces/Codeforces Round 981 (Div 3)/C.py	(date 1730330370040)
@@ -0,0 +1,85 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+
+input = lambda: sys.stdin.readline().strip()
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+def main():
+    t = int(input())
+    for _ in range(t):
+        n = int(input())
+        a = list(ints())
+        print(solve(n, a))
+
+
+def solve(n ,a ):
+    #print(current_d)
+    for i in range(n//2):
+        change_to = n-(i + 1)
+        current_ = 0
+        current_ += a[i] == a[i+1]
+        current_ += a[i] == a[i-1]
+        current_ += a[change_to] == a[change_to - 1]
+        if change_to != n-1:
+            current_ += a[change_to] == a[change_to + 1]
+        a[i],a[change_to] = a[change_to], a[i]
+        current_a = 0
+        current_a += a[i] == a[i + 1]
+        current_a += a[i] == a[i - 1]
+        current_a += a[change_to] == a[change_to - 1]
+        if change_to != n-1:
+            current_a += a[change_to] == a[change_to + 1]
+        if current_a >= current_:
+            a[i], a[change_to] = a[change_to], a[i]
+
+    #print(a)
+    current_d = sum(1 for i in range(n-1) if a[i] == a[i+1])
+    a[0], a[n-1] = a[n-1], a[0]
+    return current_d
+
+
+
+if __name__ == "__main__":
+    main()
Index: Codeforces/Educational Codeforces Round 172 (Rated for Div 2)/C.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Codeforces/Educational Codeforces Round 172 (Rated for Div 2)/C.py b/Codeforces/Educational Codeforces Round 172 (Rated for Div 2)/C.py
new file mode 100644
--- /dev/null	(date 1733153828670)
+++ b/Codeforces/Educational Codeforces Round 172 (Rated for Div 2)/C.py	(date 1733153828670)
@@ -0,0 +1,147 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+from types import GeneratorType
+
+input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+
+# region fastio
+
+BUFSIZE = 8192
+
+
+class FastIO(IOBase):
+    newlines = 0
+
+    def __init__(self, file):
+        self._file = file
+        self._fd = file.fileno()
+        self.buffer = BytesIO()
+        self.writable = "x" in file.mode or "r" not in file.mode
+        self.write = self.buffer.write if self.writable else None
+
+    def read(self):
+        while True:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            if not b:
+                break
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines = 0
+        return self.buffer.read()
+
+    def readline(self):
+        while self.newlines == 0:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            self.newlines = b.count(b"\n") + (not b)
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines -= 1
+        return self.buffer.readline()
+
+    def flush(self):
+        if self.writable:
+            os.write(self._fd, self.buffer.getvalue())
+            self.buffer.truncate(0), self.buffer.seek(0)
+
+
+class IOWrapper(IOBase):
+    def __init__(self, file):
+        self.buffer = FastIO(file)
+        self.flush = self.buffer.flush
+        self.writable = self.buffer.writable
+        self.write = lambda s: self.buffer.write(s.encode("ascii"))
+        self.read = lambda: self.buffer.read().decode("ascii")
+        self.readline = lambda: self.buffer.readline().decode("ascii")
+
+
+sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
+
+
+# endregion
+
+
+def main():
+    t = int(input())
+    for _ in range(t):
+        n, k = ints()
+        s = input()
+        print(solve(n,k,s))
+
+
+def solve(n ,k,s):
+    diff = [1 if ch == '1' else -1 for ch in s]
+    suffix_sum = [0] * (n + 2)
+    for p in range(n, 0, -1):
+        suffix_sum[p] = suffix_sum[p + 1] + diff[p - 1]
+    prefix_sum = list(accumulate(sorted((suffix_sum[p + 1] for p in range(1, n)), reverse=True)))
+    for q, val in enumerate(prefix_sum, 1):
+        if val >= k:
+            return q + 1
+    return -1
+
+if __name__ == "__main__":
+    main()
Index: Codeforces/Educational Codeforces Round 172 (Rated for Div 2)/D.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Codeforces/Educational Codeforces Round 172 (Rated for Div 2)/D.py b/Codeforces/Educational Codeforces Round 172 (Rated for Div 2)/D.py
new file mode 100644
--- /dev/null	(date 1733157064511)
+++ b/Codeforces/Educational Codeforces Round 172 (Rated for Div 2)/D.py	(date 1733157064511)
@@ -0,0 +1,150 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+from types import GeneratorType
+
+input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+
+# region fastio
+
+BUFSIZE = 8192
+
+
+class FastIO(IOBase):
+    newlines = 0
+
+    def __init__(self, file):
+        self._file = file
+        self._fd = file.fileno()
+        self.buffer = BytesIO()
+        self.writable = "x" in file.mode or "r" not in file.mode
+        self.write = self.buffer.write if self.writable else None
+
+    def read(self):
+        while True:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            if not b:
+                break
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines = 0
+        return self.buffer.read()
+
+    def readline(self):
+        while self.newlines == 0:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            self.newlines = b.count(b"\n") + (not b)
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines -= 1
+        return self.buffer.readline()
+
+    def flush(self):
+        if self.writable:
+            os.write(self._fd, self.buffer.getvalue())
+            self.buffer.truncate(0), self.buffer.seek(0)
+
+
+class IOWrapper(IOBase):
+    def __init__(self, file):
+        self.buffer = FastIO(file)
+        self.flush = self.buffer.flush
+        self.writable = self.buffer.writable
+        self.write = lambda s: self.buffer.write(s.encode("ascii"))
+        self.read = lambda: self.buffer.read().decode("ascii")
+        self.readline = lambda: self.buffer.readline().decode("ascii")
+
+
+sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
+
+
+# endregion
+def find(intervals, res):
+    intervals.sort(key=lambda x: (x[0], -x[1], x[2]))
+    ends = []
+    for l, r, index in intervals:
+        pos = bisect_left(ends, r)
+        if pos < len(ends):
+            res[index] += ends[pos] - r
+        ends.insert(pos, r)
+
+def main():
+    for _ in range(int(input())):
+        n = int(input())
+        intervals = [(l, r, i) for i, (l, r) in enumerate(map(lambda _: ints(), range(n)))]
+        res = [0] * n
+        find(intervals, res)
+        find([(-r, -l, i) for l, r, i in intervals], res)
+        freq = defaultdict(int)
+        for l, r, _ in intervals:
+            freq[(l, r)] += 1
+        for l, r, i in intervals:
+            if freq[(l, r)] > 1:
+                res[i] = 0
+        print("\n".join(map(str, res)))
+
+if __name__ == "__main__":
+    main()
Index: USACO GUIDE/GOLD/DP/AC - H - Grid 1.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/USACO GUIDE/GOLD/DP/AC - H - Grid 1.py b/USACO GUIDE/GOLD/DP/AC - H - Grid 1.py
new file mode 100644
--- /dev/null	(date 1733255861747)
+++ b/USACO GUIDE/GOLD/DP/AC - H - Grid 1.py	(date 1733255861747)
@@ -0,0 +1,165 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+from types import GeneratorType
+
+input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+
+# region fastio
+
+BUFSIZE = 8192
+
+
+class FastIO(IOBase):
+    newlines = 0
+
+    def __init__(self, file):
+        self._file = file
+        self._fd = file.fileno()
+        self.buffer = BytesIO()
+        self.writable = "x" in file.mode or "r" not in file.mode
+        self.write = self.buffer.write if self.writable else None
+
+    def read(self):
+        while True:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            if not b:
+                break
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines = 0
+        return self.buffer.read()
+
+    def readline(self):
+        while self.newlines == 0:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            self.newlines = b.count(b"\n") + (not b)
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines -= 1
+        return self.buffer.readline()
+
+    def flush(self):
+        if self.writable:
+            os.write(self._fd, self.buffer.getvalue())
+            self.buffer.truncate(0), self.buffer.seek(0)
+
+
+class IOWrapper(IOBase):
+    def __init__(self, file):
+        self.buffer = FastIO(file)
+        self.flush = self.buffer.flush
+        self.writable = self.buffer.writable
+        self.write = lambda s: self.buffer.write(s.encode("ascii"))
+        self.read = lambda: self.buffer.read().decode("ascii")
+        self.readline = lambda: self.buffer.readline().decode("ascii")
+
+
+sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
+
+
+# endregion
+
+
+def main():
+    n, m = ints()
+    a = [input() for i in range(n)]
+    print(solve(n,m, a))
+
+
+def solve(n,m, a):
+    """@lru_cache(None)
+    def dp(i, j):
+        if i == 0 and j == 0:
+            return 1
+        if a[i][j] == '#':
+            return 0
+        ans = 0
+        if i - 1 >= 0:
+            ans += dp(i - 1, j)
+        if j - 1 >= 0:
+            ans += dp(i, j - 1)
+        return ans
+
+    return dp(n - 1, m - 1) % MOD"""
+    dp = [[0 for i in range(m+1)] for i in range(n + 1)]
+    dp[0][0] = 1
+    for i in range(n):
+        for j in range(m):
+            if a[i][j] == '#':
+                continue
+            if i > 0:
+                dp[i][j] += dp[i-1][j]
+            if j > 0:
+                dp[i][j] += dp[i][j - 1]
+    for it in dp:
+        print(it)
+    return dp[n-1][m-1] % MOD
+
+
+
+if __name__ == "__main__":
+    main()
Index: USACO GUIDE/GOLD/DP/AC - Y - Grid 2.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/USACO GUIDE/GOLD/DP/AC - Y - Grid 2.py b/USACO GUIDE/GOLD/DP/AC - Y - Grid 2.py
new file mode 100644
--- /dev/null	(date 1733255697534)
+++ b/USACO GUIDE/GOLD/DP/AC - Y - Grid 2.py	(date 1733255697534)
@@ -0,0 +1,176 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce, total_ordering
+import operator
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+from types import GeneratorType
+
+input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+
+# region fastio
+
+BUFSIZE = 8192
+
+
+class FastIO(IOBase):
+    newlines = 0
+
+    def __init__(self, file):
+        self._file = file
+        self._fd = file.fileno()
+        self.buffer = BytesIO()
+        self.writable = "x" in file.mode or "r" not in file.mode
+        self.write = self.buffer.write if self.writable else None
+
+    def read(self):
+        while True:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            if not b:
+                break
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines = 0
+        return self.buffer.read()
+
+    def readline(self):
+        while self.newlines == 0:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            self.newlines = b.count(b"\n") + (not b)
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines -= 1
+        return self.buffer.readline()
+
+    def flush(self):
+        if self.writable:
+            os.write(self._fd, self.buffer.getvalue())
+            self.buffer.truncate(0), self.buffer.seek(0)
+
+
+class IOWrapper(IOBase):
+    def __init__(self, file):
+        self.buffer = FastIO(file)
+        self.flush = self.buffer.flush
+        self.writable = self.buffer.writable
+        self.write = lambda s: self.buffer.write(s.encode("ascii"))
+        self.read = lambda: self.buffer.read().decode("ascii")
+        self.readline = lambda: self.buffer.readline().decode("ascii")
+
+
+#sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
+
+
+# endregion
+
+
+def main():
+    n, m, k = ints()
+    a = []
+    for i in range(k):
+        i, j = ints()
+        a.append((i,j))
+    print(solve(n,m, a))
+MAX_N = int(2 * 10e5+6)
+factorials = [0] * (MAX_N)
+inversors = [0] * (MAX_N)
+factorials[0] = 0
+factorials[1] = 1
+factorials[2] = 2
+inversors[0] = 1
+inversors[1] = 1
+for i in range(2, MAX_N):
+    factorials[i] = (factorials[i-1] * i) % MOD
+    inversors[i] = pow(factorials[i], MOD - 2, MOD)
+
+
+def comb(a, b):
+    if a < 0 or b < 0 or b > a:
+        return 0
+    return factorials[a] * inversors[b] % MOD * inversors[a - b] % MOD
+
+def solve(n,m, a):
+    a.sort()
+    H = n
+    W = m
+    total = comb(n - 1 + m - 1, m -1)
+    n = len(a)
+
+    dp = [0 for i in range(n + 1)]
+    for i in range(n):
+        xi, yi = a[i]
+        dp[i] = comb(xi-1 + yi-1, yi-1)
+        for j in range(i):
+            xj, yj = a[j]
+            if xj <= xi and yj <= yi:
+                ways = comb(xi-xj + yi - yj, xi - xj)
+                dp[i] -= dp[j] * ways
+    for i in range(n):
+        xi, yi = a[i]
+        ways = comb(H - xi + W - yi, H - xi)
+        total -= dp[i] * ways
+    return (total % MOD)
+
+
+if __name__ == "__main__":
+    main()
Index: USACO GUIDE/GOLD/DP/CSES - Coding Company.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/USACO GUIDE/GOLD/DP/CSES - Coding Company.py b/USACO GUIDE/GOLD/DP/CSES - Coding Company.py
new file mode 100644
--- /dev/null	(date 1733241308371)
+++ b/USACO GUIDE/GOLD/DP/CSES - Coding Company.py	(date 1733241308371)
@@ -0,0 +1,154 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+from types import GeneratorType
+
+input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+
+# region fastio
+
+BUFSIZE = 8192
+
+
+class FastIO(IOBase):
+    newlines = 0
+
+    def __init__(self, file):
+        self._file = file
+        self._fd = file.fileno()
+        self.buffer = BytesIO()
+        self.writable = "x" in file.mode or "r" not in file.mode
+        self.write = self.buffer.write if self.writable else None
+
+    def read(self):
+        while True:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            if not b:
+                break
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines = 0
+        return self.buffer.read()
+
+    def readline(self):
+        while self.newlines == 0:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            self.newlines = b.count(b"\n") + (not b)
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines -= 1
+        return self.buffer.readline()
+
+    def flush(self):
+        if self.writable:
+            os.write(self._fd, self.buffer.getvalue())
+            self.buffer.truncate(0), self.buffer.seek(0)
+
+
+class IOWrapper(IOBase):
+    def __init__(self, file):
+        self.buffer = FastIO(file)
+        self.flush = self.buffer.flush
+        self.writable = self.buffer.writable
+        self.write = lambda s: self.buffer.write(s.encode("ascii"))
+        self.read = lambda: self.buffer.read().decode("ascii")
+        self.readline = lambda: self.buffer.readline().decode("ascii")
+
+
+sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
+
+
+# endregion
+
+
+def main():
+    n, x = ints()
+    a = list(ints())
+    print(solve(n, x, a))
+
+
+
+def solve(n, x ,a ):
+    a.sort()
+
+    @lru_cache(maxsize=None)
+    def dfs(i, current_penalty):
+        if i == n:
+            return 1 if current_penalty <= x else 0
+        total = 0
+        for j in range(i + 1, n + 1):
+            #p = a[j - 1] - a[i] if j - 1 >= i else 0
+            # Corrected penalty calculation
+            p = a[j - 1] - a[i]
+            if current_penalty + p > x:
+                continue  # Skip if penalty exceeds limit
+            total = (total + dfs(j, current_penalty + p)) % MOD
+        return total
+
+    return dfs(0, 0)
+
+if __name__ == "__main__":
+    main()
Index: USACO GUIDE/GOLD/DP/LO - Baker Vai.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/USACO GUIDE/GOLD/DP/LO - Baker Vai.py b/USACO GUIDE/GOLD/DP/LO - Baker Vai.py
new file mode 100644
--- /dev/null	(date 1733269474575)
+++ b/USACO GUIDE/GOLD/DP/LO - Baker Vai.py	(date 1733269474575)
@@ -0,0 +1,101 @@
+# BISMILLAHIRRAHMANIRRAHIM
+"""
+manus tar shopner soman boro
+Author :: Shakil Ahmed
+.............AUST_CSE27.........
+prob   ::
+Type   ::
+verdict::
+"""
+
+import sys
+from math import inf
+
+# Constants
+dx = [1, 0]
+dy = [0, 1]
+
+# Helper functions
+def valid(x, y, n, m):
+    return 0 <= x < n and 0 <= y < m
+
+# Recursive DP function
+def DP(r1, c1, r2, c2, n, m, inp, dp):
+    if r1 >= n or r2 >= n or c1 >= m or c2 >= m:
+        return 0
+    if r1 == r2 and c1 == c2:
+        return 0
+    if dp[r1][c1][r2] != -1:
+        return dp[r1][c1][r2]
+
+    ret = 0
+    ret = max(ret, DP(r1 + 1, c1, r2 + 1, c2, n, m, inp, dp))
+    ret = max(ret, DP(r1 + 1, c1, r2, c2 + 1, n, m, inp, dp))
+    ret = max(ret, DP(r1, c1 + 1, r2 + 1, c2, n, m, inp, dp))
+    ret = max(ret, DP(r1, c1 + 1, r2, c2 + 1, n, m, inp, dp))
+
+    dp[r1][c1][r2] = ret + inp[r1][c1] + inp[r2][c2]
+    return dp[r1][c1][r2]
+
+
+def DP_iterative(n, m, inp):
+    # Initialize the 4D DP table with 0
+    # Dimensions: r1, c1, r2, c2
+    dp = [[[[0 for _ in range(m)] for __ in range(n)] for ___ in range(m)] for ____ in range(n)]
+
+    # Iterate through all possible positions of r1 and c1
+    for r1 in range(n):
+        for c1 in range(m):
+            for r2 in range(n):
+                for c2 in range(m):
+                    # Check for out-of-bounds indices
+                    if r1 >= n or r2 >= n or c1 >= m or c2 >= m:
+                        dp[r1][c1][r2][c2] = 0
+                        continue
+                    # If both pointers are on the same cell, avoid double-counting
+                    if r1 == r2 and c1 == c2:
+                        current_value = inp[r1][c1]
+                    else:
+                        current_value = inp[r1][c1] + inp[r2][c2]
+                    # Initialize the maximum value for this state
+                    ret = 0
+                    # Explore all four possible previous states
+                    # 1. Both pointers moved from above
+                    if r1 > 0 and r2 > 0:
+                        ret = max(ret, dp[r1 - 1][c1][r2 - 1][c2])
+                    # 2. First pointer moved from above, second from the left
+                    if r1 > 0 and c2  > 0:
+                        ret = max(ret, dp[r1 - 1][c1][r2][c2 - 1])
+                    # 3. First pointer moved from the left, second from above
+                    if c1 > 0 and r2 > 0:
+                        ret = max(ret, dp[r1][c1 - 1][r2 - 1][c2])
+                    # 4. Both pointers moved from the left
+                    if c1 > 0 and c2 > 0:
+                        ret = max(ret, dp[r1][c1 - 1][r2][c2 - 1])
+                    # Update the DP table with the current value and the best previous state
+                    dp[r1][c1][r2][c2] = ret + current_value
+
+    # The answer is in the state where both pointers are at the last cell
+    return dp[n - 1][m - 1][n - 1][m - 1]
+
+
+# Main function
+def main():
+    t = int(input())  # Number of test cases
+    for cs in range(1, t + 1):
+        input()
+        n, m = map(int, input().split())  # Dimensions of the grid
+        inp = []
+        for _ in range(n):
+            inp.append(list(map(int, input().split())))
+
+        # Initialize DP table
+        dp = [[[-1 for _ in range(n)] for _ in range(m)] for _ in range(n)]
+
+        # Solve the problem
+        #result = DP(0, 1, 1, 0, n, m, inp, dp) + inp[0][0] + inp[n - 1][m - 1]
+        result = DP_iterative(n, m, inp)
+        print(f"Case {cs}: {result}")
+
+if __name__ == "__main__":
+    main()
\ No newline at end of file
Index: USACO GUIDE/GOLD/DP/LIS.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/USACO GUIDE/GOLD/DP/LIS.py b/USACO GUIDE/GOLD/DP/LIS.py
new file mode 100644
--- /dev/null	(date 1733284485847)
+++ b/USACO GUIDE/GOLD/DP/LIS.py	(date 1733284485847)
@@ -0,0 +1,18 @@
+from bisect import *
+
+MAX_N = 11
+
+n = 11
+A = [-7, 10, 9, 2, 3, 8, 8, 1, 2, 3, 4]
+
+L = [None] * MAX_N
+lis = 0
+for i in range(n):
+    pos = bisect_left(L, A[i], 0, lis)
+    L[pos] = A[i]
+    if pos+1 > lis:
+        lis = pos+1
+    print('Considering element A[{}] = {}'.format(i, A[i]))
+    print('LIS ending at A[{}] is of length {}: '.format(i, pos+1), end='')
+    print('L is now: [' + ', '.join(map(str, L[:lis])) + ']\n')
+print('Final LIS is of length:', L[:lis])
\ No newline at end of file
Index: USACO GUIDE/GOLD/DP/AC - Q - Flowers.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/USACO GUIDE/GOLD/DP/AC - Q - Flowers.py b/USACO GUIDE/GOLD/DP/AC - Q - Flowers.py
new file mode 100644
--- /dev/null	(date 1733328208478)
+++ b/USACO GUIDE/GOLD/DP/AC - Q - Flowers.py	(date 1733328208478)
@@ -0,0 +1,160 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+from types import GeneratorType
+
+input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+
+# region fastio
+
+BUFSIZE = 8192
+
+
+class FastIO(IOBase):
+    newlines = 0
+
+    def __init__(self, file):
+        self._file = file
+        self._fd = file.fileno()
+        self.buffer = BytesIO()
+        self.writable = "x" in file.mode or "r" not in file.mode
+        self.write = self.buffer.write if self.writable else None
+
+    def read(self):
+        while True:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            if not b:
+                break
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines = 0
+        return self.buffer.read()
+
+    def readline(self):
+        while self.newlines == 0:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            self.newlines = b.count(b"\n") + (not b)
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines -= 1
+        return self.buffer.readline()
+
+    def flush(self):
+        if self.writable:
+            os.write(self._fd, self.buffer.getvalue())
+            self.buffer.truncate(0), self.buffer.seek(0)
+
+
+class IOWrapper(IOBase):
+    def __init__(self, file):
+        self.buffer = FastIO(file)
+        self.flush = self.buffer.flush
+        self.writable = self.buffer.writable
+        self.write = lambda s: self.buffer.write(s.encode("ascii"))
+        self.read = lambda: self.buffer.read().decode("ascii")
+        self.readline = lambda: self.buffer.readline().decode("ascii")
+
+
+sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
+
+
+# endregion
+
+
+def main():
+    n = int(input())
+    a = list(ints())
+    b = list(ints())
+    print(solve(n, a, b))
+
+
+def solve(n ,A, B):
+    L = []
+    predecessor = [None] * n
+    pos_in_L = [None] * n
+    for i in range(n):
+        pos = bisect_left(L, A[i])
+        if pos == len(L):
+            L.append(A[i])
+        else:
+            L[pos] = A[i]
+        pos_in_L[pos] = i
+        if pos > 0:
+            predecessor[i] = pos_in_L[pos - 1]
+        else:
+            predecessor[i] = None
+    k = pos_in_L[len(L) - 1]
+    lis_sequence = []
+    index = []
+    while k is not None:
+        index.append(k)
+        lis_sequence.append(A[k])
+        k = predecessor[k]
+    print(lis_sequence, index)
+    return sum(B[it] for it in index)
+
+if __name__ == "__main__":
+    main()
Index: USACO GUIDE/GOLD/DP/AC - Q - Flowers - FT.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/USACO GUIDE/GOLD/DP/AC - Q - Flowers - FT.py b/USACO GUIDE/GOLD/DP/AC - Q - Flowers - FT.py
new file mode 100644
--- /dev/null	(date 1733323284933)
+++ b/USACO GUIDE/GOLD/DP/AC - Q - Flowers - FT.py	(date 1733323284933)
@@ -0,0 +1,49 @@
+import sys
+sys.setrecursionlimit(1 << 25)
+N_and_rest = sys.stdin.read().split()
+N = int(N_and_rest[0])
+h_list = list(map(int, N_and_rest[1:N + 1]))
+a_list = list(map(int, N_and_rest[N + 1:]))
+N = len(h_list)
+h_set = set(h_list)
+h_sorted = sorted(h_set)
+h_comp = {h: idx + 1 for idx, h in enumerate(h_sorted)}
+
+h_comp_list = [h_comp[h] for h in h_list]
+
+class FenwickTree:
+    def __init__(self, size):
+        self.N = size
+        self.tree = [0] * (self.N + 2)
+
+    def update(self, idx, value):
+        while idx <= self.N:
+            if self.tree[idx] < value:
+                self.tree[idx] = value
+            else:
+                break
+            idx += idx & -idx
+
+    def query(self, idx):
+        result = 0
+        while idx > 0:
+            if self.tree[idx] > result:
+                result = self.tree[idx]
+            idx -= idx & -idx
+        return result
+
+ft_size = len(h_comp)
+ft = FenwickTree(ft_size + 2)
+
+max_beauty = 0
+
+for i in range(N):
+    h_i = h_comp_list[i]
+    a_i = a_list[i]
+    max_prev = ft.query(h_i - 1)
+    current = max_prev + a_i
+    ft.update(h_i, current)
+    if current > max_beauty:
+        max_beauty = current
+
+print(max_beauty)
\ No newline at end of file
Index: ICPC Preparation/Problem Solving Paradigms/Dynamic Programming/Longest Increasing Subsequence (LIS)/10534 - Wavio Sequence.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ICPC Preparation/Problem Solving Paradigms/Dynamic Programming/Longest Increasing Subsequence (LIS)/10534 - Wavio Sequence.py b/ICPC Preparation/Problem Solving Paradigms/Dynamic Programming/Longest Increasing Subsequence (LIS)/10534 - Wavio Sequence.py
new file mode 100644
--- /dev/null	(date 1733344056542)
+++ b/ICPC Preparation/Problem Solving Paradigms/Dynamic Programming/Longest Increasing Subsequence (LIS)/10534 - Wavio Sequence.py	(date 1733344056542)
@@ -0,0 +1,180 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+from types import GeneratorType
+
+input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+
+# region fastio
+
+BUFSIZE = 8192
+
+
+class FastIO(IOBase):
+    newlines = 0
+
+    def __init__(self, file):
+        self._file = file
+        self._fd = file.fileno()
+        self.buffer = BytesIO()
+        self.writable = "x" in file.mode or "r" not in file.mode
+        self.write = self.buffer.write if self.writable else None
+
+    def read(self):
+        while True:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            if not b:
+                break
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines = 0
+        return self.buffer.read()
+
+    def readline(self):
+        while self.newlines == 0:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            self.newlines = b.count(b"\n") + (not b)
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines -= 1
+        return self.buffer.readline()
+
+    def flush(self):
+        if self.writable:
+            os.write(self._fd, self.buffer.getvalue())
+            self.buffer.truncate(0), self.buffer.seek(0)
+
+
+class IOWrapper(IOBase):
+    def __init__(self, file):
+        self.buffer = FastIO(file)
+        self.flush = self.buffer.flush
+        self.writable = self.buffer.writable
+        self.write = lambda s: self.buffer.write(s.encode("ascii"))
+        self.read = lambda: self.buffer.read().decode("ascii")
+        self.readline = lambda: self.buffer.readline().decode("ascii")
+
+
+#sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
+
+
+# endregion
+
+def compute_LIS(sequence):
+    MAX_N = len(sequence)
+    A = sequence
+    n = len(sequence)
+    L = [None] * MAX_N
+    lis = 0
+    LIS = [None] * MAX_N
+    for i in range(n):
+        pos = bisect_left(L, A[i], 0, lis)
+        L[pos] = A[i]
+        if pos + 1 > lis:
+            lis = pos + 1
+        LIS[i] = pos + 1
+    return LIS
+
+def main():
+    """input_data = sys.stdin.read().split()
+    idx = 0
+    while idx < len(input_data):
+        N = int(input_data[idx])
+        idx += 1
+        sequence = []
+        while len(sequence) < N and idx < len(input_data):
+            sequence.append(int(input_data[idx]))
+            idx += 1
+        a = sequence
+        lis = compute_LIS(a)
+        a.reverse()
+        lds = compute_LIS(a)
+        lds.reverse()
+        # print(lds, lis)
+        ans = 0
+        for i in range(len(lis)):
+            ans = max(ans, 2 * min(lis[i], lds[i]) - 1)
+        print(ans)"""
+    while True:
+        n = input()
+        if not n:
+            break
+        n = int(n)
+        print(n)
+        a = list(ints())
+        print(a)
+        lis = compute_LIS(a)
+        a.reverse()
+        lds = compute_LIS(a)
+        lds.reverse()
+        print(lds, lis)
+        ans = 0
+        for i in range(len(lis)):
+            ans = max(ans, 2 * min(lis[i], lds[i]) - 1)
+        print(ans)
+
+if __name__ == "__main__":
+    main()
Index: ICPC Preparation/Problem Solving Paradigms/Dynamic Programming/Longest Increasing Subsequence (LIS)/1196 - Tiling Up Blocks.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ICPC Preparation/Problem Solving Paradigms/Dynamic Programming/Longest Increasing Subsequence (LIS)/1196 - Tiling Up Blocks.py b/ICPC Preparation/Problem Solving Paradigms/Dynamic Programming/Longest Increasing Subsequence (LIS)/1196 - Tiling Up Blocks.py
new file mode 100644
--- /dev/null	(date 1733332750185)
+++ b/ICPC Preparation/Problem Solving Paradigms/Dynamic Programming/Longest Increasing Subsequence (LIS)/1196 - Tiling Up Blocks.py	(date 1733332750185)
@@ -0,0 +1,77 @@
+import sys
+import bisect
+
+
+def tallest_tiling_blocks(blocks):
+    blocks.sort(key=lambda x: (x[0], x[1]))
+    dp = []
+    for block in blocks:
+        m = block[1]
+        idx = bisect.bisect_right(dp, m)
+        if idx == len(dp):
+            dp.append(m)
+        else:
+            dp[idx] = m
+    return len(dp)
+
+
+def main():
+    for line in sys.stdin:
+        n = int(line.strip())
+        if n == 0:
+            break
+        blocks = []
+        for _ in range(n):
+            l, m = map(int, sys.stdin.readline().strip().split())
+            blocks.append((l, m))
+        print(tallest_tiling_blocks(blocks))
+    print("*")
+
+
+if __name__ == "__main__":
+    main()
+
+"""
+def tallest_stack(blocks):
+    # Initialize a 2D DP array with dimensions (101 x 101)
+    dp = [[0] * 101 for _ in range(101)]
+    
+    for l, m in blocks:
+        # Find the maximum stack height for all blocks with l' <= l and m' <= m
+        max_prev = 0
+        for i in range(1, l + 1):
+            for j in range(1, m + 1):
+                if dp[i][j] > max_prev:
+                    max_prev = dp[i][j]
+        # Update the DP table for the current block
+        dp[l][m] = max_prev + 1
+    
+    # Find the overall maximum stack height
+    return max(max(row) for row in dp)
+
+def process_input():
+    results = []
+    while True:
+        try:
+            n = int(input())
+            if n == 0:
+                break
+            blocks = []
+            for _ in range(n):
+                l, m = map(int, input().split())
+                blocks.append((l, m))
+            # Sort blocks by l ascending and then m ascending
+            blocks.sort()
+            result = tallest_stack(blocks)
+            results.append(result)
+        except EOFError:
+            break
+    return results
+
+if __name__ == "__main__":
+    results = process_input()
+    for res in results:
+        print(res)
+    print('*')
+"""
+
Index: USACO GUIDE/GOLD/DP/AC - N - Slimes.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/USACO GUIDE/GOLD/DP/AC - N - Slimes.py b/USACO GUIDE/GOLD/DP/AC - N - Slimes.py
new file mode 100644
--- /dev/null	(date 1733521981571)
+++ b/USACO GUIDE/GOLD/DP/AC - N - Slimes.py	(date 1733521981571)
@@ -0,0 +1,28 @@
+def min_total_cost(N, a):
+    # Initialize prefix sums
+    prefix_sum = [0] * (N + 1)
+    for i in range(N):
+        prefix_sum[i + 1] = prefix_sum[i] + a[i]
+
+    # Initialize DP table
+    dp = [[0] * (N + 1) for _ in range(N + 1)]
+
+    # Fill DP table
+    for length in range(2, N + 1):  # length of the sequence
+        for i in range(1, N - length + 2):  # starting index
+            j = i + length - 1  # ending index
+            dp[i][j] = float('inf')
+            for k in range(i, j):
+                cost = dp[i][k] + dp[k + 1][j] + prefix_sum[j] - prefix_sum[i - 1]
+                if cost < dp[i][j]:
+                    dp[i][j] = cost
+            print(i, j, cost)
+    return dp[1][N]
+
+
+# Example usage:
+if __name__ == "__main__":
+    import sys
+    N = int(input())
+    a = list(map(int, input().split()))
+    print(min_total_cost(N, a))
\ No newline at end of file
Index: USACO GUIDE/GOLD/DP/248.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/USACO GUIDE/GOLD/DP/248.py b/USACO GUIDE/GOLD/DP/248.py
new file mode 100644
--- /dev/null	(date 1733527470462)
+++ b/USACO GUIDE/GOLD/DP/248.py	(date 1733527470462)
@@ -0,0 +1,201 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+from types import GeneratorType
+
+input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+
+# region fastio
+
+BUFSIZE = 8192
+
+
+class FastIO(IOBase):
+    newlines = 0
+
+    def __init__(self, file):
+        self._file = file
+        self._fd = file.fileno()
+        self.buffer = BytesIO()
+        self.writable = "x" in file.mode or "r" not in file.mode
+        self.write = self.buffer.write if self.writable else None
+
+    def read(self):
+        while True:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            if not b:
+                break
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines = 0
+        return self.buffer.read()
+
+    def readline(self):
+        while self.newlines == 0:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            self.newlines = b.count(b"\n") + (not b)
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines -= 1
+        return self.buffer.readline()
+
+    def flush(self):
+        if self.writable:
+            os.write(self._fd, self.buffer.getvalue())
+            self.buffer.truncate(0), self.buffer.seek(0)
+
+
+class IOWrapper(IOBase):
+    def __init__(self, file):
+        self.buffer = FastIO(file)
+        self.flush = self.buffer.flush
+        self.writable = self.buffer.writable
+        self.write = lambda s: self.buffer.write(s.encode("ascii"))
+        self.read = lambda: self.buffer.read().decode("ascii")
+        self.readline = lambda: self.buffer.readline().decode("ascii")
+
+
+#sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
+
+
+
+# endregion
+
+
+def main():
+    #sys.stdin = open('248.in', 'r')
+    #sys.stdout = open('248.out', 'w')
+    n = int(input())
+    a = [int(input()) for i in range(n)]
+    print(solve(n, a))
+
+
+def solve(n ,a ):
+    """@lru_cache(maxsize=None)
+    def dfs(i, j):
+        if i == j:
+            return a[i]
+        max_val = 0
+        for k in range(i, j):
+            left = dfs(i, k)
+            right = dfs(k + 1, j)
+            max_val = max(max_val, left, right)
+            if left == right:
+                max_val = max(max_val, left + 1)
+        return max_val
+    return dfs(0, n - 1)"""
+    """dp = [[0 for i in range(n)]  for _ in range(n)]
+    for i in range(n):
+        dp[i][i] = a[i]
+    for length in range(2, n + 1):
+        for i in range(n - length + 1):
+            j = i + length - 1
+            dp[i][j] = max(dp[i][k] for k in range(i, j))
+            for k in range(i, j):
+                if dp[i][k] == dp[k + 1][j]:
+                    dp[i][j] = max(dp[i][j], dp[i][k] + 1)
+    return max(max(row) for row in dp)"""
+
+    """@lru_cache(maxsize=None)
+    def dp(i, j):
+        if i == j:
+            return a[i]
+        merged = -1
+        for k in range(i, j):
+            left = dp(i, k)
+            right = dp(k + 1, j)
+            if left != -1 and left == right:
+                merged = left + 1
+                break  # You can remove break if you want the smallest k
+        return merged
+
+    max_val = -1
+    for i in range(n):
+        for j in range(i, n):
+            current = dp(i, j)
+            if current > max_val:
+                max_val = current
+
+    return (max_val)"""
+    dp = [[-1 for _ in range(n)] for _ in range(n)]
+
+    ans = 0
+    for length in range(1, n + 1):
+        for i in range(n - length + 1):
+            j = i + length - 1
+            if i == j:
+                dp[i][j] = a[i]
+            else:
+                for k in range(i, j):
+                    if dp[i][k] != -1 and dp[i][k] == dp[k + 1][j]:
+                        dp[i][j] = dp[i][k] + 1
+                        break
+            ans = max(ans, dp[i][j])
+
+    return (ans)
+
+if __name__ == "__main__":
+    main()
Index: Codeforces/Codeforces Global Round 27/B.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Codeforces/Codeforces Global Round 27/B.py b/Codeforces/Codeforces Global Round 27/B.py
new file mode 100644
--- /dev/null	(date 1730412925943)
+++ b/Codeforces/Codeforces Global Round 27/B.py	(date 1730412925943)
@@ -0,0 +1,112 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate, combinations_with_replacement
+
+input = lambda: sys.stdin.readline().strip()
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+
+def ints(): return map(int, input().split())
+
+
+def strs(): return input().split()
+
+
+def chars(): return list(input().strip())
+
+
+def mat(n): return [list(ints()) for _ in range(n)]
+
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+
+def add(x, y, mod=MOD): return (x + y) % mod
+
+
+def sub(x, y, mod=MOD): return (x - y) % mod
+
+
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+
+RANDOM = getrandbits(32)
+
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+n=  0
+def main():
+    global n
+    t = int(input())
+    ans_ = []
+    for _ in range(t):
+        n = int(input())
+        ans_.append(solve(n))
+    print("\n".join(ans_))
+
+
+@lru_cache(maxsize=None)
+def dfs(pos, diff_mod11):
+    if pos > n:
+        if diff_mod11 % 11 == 0:
+            return ''
+        else:
+            return None
+    elif pos == n:
+        d = 6
+        if pos % 2 == 1:
+            new_diff_mod11 = (diff_mod11 + d) % 11
+        else:
+            new_diff_mod11 = (diff_mod11 - d) % 11
+        res = dfs(pos + 1, new_diff_mod11)
+        if res is not None:
+            return str(d) + res
+        else:
+            return None
+    else:
+        for d in ['3', '6']:
+            digit = int(d)
+            if pos % 2 == 1:
+                new_diff_mod11 = (diff_mod11 + digit) % 11
+            else:
+                new_diff_mod11 = (diff_mod11 - digit) % 11
+            res = dfs(pos + 1, new_diff_mod11)
+            if res is not None:
+                return d + res
+        return None
+def solve(n):
+    ans = dfs(1, 0)
+    dfs.cache_clear()
+    return ans if ans is not None else "-1"
+
+if __name__ == "__main__":
+    main()
Index: USACO GUIDE/Dec Bronze Contest/RoundabountRounding.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/USACO GUIDE/Dec Bronze Contest/RoundabountRounding.py b/USACO GUIDE/Dec Bronze Contest/RoundabountRounding.py
new file mode 100644
--- /dev/null	(date 1734106119784)
+++ b/USACO GUIDE/Dec Bronze Contest/RoundabountRounding.py	(date 1734106119784)
@@ -0,0 +1,149 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+from types import GeneratorType
+
+input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+
+# region fastio
+
+BUFSIZE = 8192
+
+
+class FastIO(IOBase):
+    newlines = 0
+
+    def __init__(self, file):
+        self._file = file
+        self._fd = file.fileno()
+        self.buffer = BytesIO()
+        self.writable = "x" in file.mode or "r" not in file.mode
+        self.write = self.buffer.write if self.writable else None
+
+    def read(self):
+        while True:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            if not b:
+                break
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines = 0
+        return self.buffer.read()
+
+    def readline(self):
+        while self.newlines == 0:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            self.newlines = b.count(b"\n") + (not b)
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines -= 1
+        return self.buffer.readline()
+
+    def flush(self):
+        if self.writable:
+            os.write(self._fd, self.buffer.getvalue())
+            self.buffer.truncate(0), self.buffer.seek(0)
+
+
+class IOWrapper(IOBase):
+    def __init__(self, file):
+        self.buffer = FastIO(file)
+        self.flush = self.buffer.flush
+        self.writable = self.buffer.writable
+        self.write = lambda s: self.buffer.write(s.encode("ascii"))
+        self.read = lambda: self.buffer.read().decode("ascii")
+        self.readline = lambda: self.buffer.readline().decode("ascii")
+
+
+sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
+
+import math
+# endregion
+
+def pow_teen(x, power):
+    return ((x + power // 2) // power) * power
+
+def main():
+    # sys.stdin = open('tracing.in', 'r')
+    # sys.stdout = open('tracing.out', 'w')
+    t = int(input())
+    results = []
+    for _ in range(t):
+        n = int(input())
+        ans = 0
+        for x in range(2, n + 1):
+            digits = int(math.log10(x)) + 1
+            power = 10 ** digits
+            rounded = pow_teen(x, power)
+            modified_x = x
+            for p in range(1, digits + 1):
+                modified_x = pow_teen(modified_x, 10 ** p)
+            if rounded != modified_x:
+                ans += 1
+        results.append(ans)
+    print("\n".join(map(str, results)))
+if __name__ == "__main__":
+    main()
Index: Codeforces/Codeforces Global Round 27/A.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Codeforces/Codeforces Global Round 27/A.py b/Codeforces/Codeforces Global Round 27/A.py
new file mode 100644
--- /dev/null	(date 1730409313722)
+++ b/Codeforces/Codeforces Global Round 27/A.py	(date 1730409313722)
@@ -0,0 +1,61 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+
+input = lambda: sys.stdin.readline().strip()
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+def main():
+    t = int(input())
+    for _ in range(t):
+        m, n,r,c = ints()
+        ans = n - c
+        ans += (n-1) * (m - r)
+        ans += n * (m - r)
+        print(ans)
+
+
+
+if __name__ == "__main__":
+    main()
Index: USACO GUIDE/Dec Bronze Contest/FarmerJohnsCheeseBlock.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/USACO GUIDE/Dec Bronze Contest/FarmerJohnsCheeseBlock.py b/USACO GUIDE/Dec Bronze Contest/FarmerJohnsCheeseBlock.py
new file mode 100644
--- /dev/null	(date 1734099139007)
+++ b/USACO GUIDE/Dec Bronze Contest/FarmerJohnsCheeseBlock.py	(date 1734099139007)
@@ -0,0 +1,147 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+from types import GeneratorType
+
+input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+
+# region fastio
+
+BUFSIZE = 8192
+
+
+class FastIO(IOBase):
+    newlines = 0
+
+    def __init__(self, file):
+        self._file = file
+        self._fd = file.fileno()
+        self.buffer = BytesIO()
+        self.writable = "x" in file.mode or "r" not in file.mode
+        self.write = self.buffer.write if self.writable else None
+
+    def read(self):
+        while True:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            if not b:
+                break
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines = 0
+        return self.buffer.read()
+
+    def readline(self):
+        while self.newlines == 0:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            self.newlines = b.count(b"\n") + (not b)
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines -= 1
+        return self.buffer.readline()
+
+    def flush(self):
+        if self.writable:
+            os.write(self._fd, self.buffer.getvalue())
+            self.buffer.truncate(0), self.buffer.seek(0)
+
+
+class IOWrapper(IOBase):
+    def __init__(self, file):
+        self.buffer = FastIO(file)
+        self.flush = self.buffer.flush
+        self.writable = self.buffer.writable
+        self.write = lambda s: self.buffer.write(s.encode("ascii"))
+        self.read = lambda: self.buffer.read().decode("ascii")
+        self.readline = lambda: self.buffer.readline().decode("ascii")
+
+
+sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
+
+
+# endregion
+
+
+def main():
+    #sys.stdin = open('tracing.in', 'r')
+    #sys.stdout = open('tracing.out', 'w')
+    ans = 0
+    n, q = ints()
+    counts = [[0] * (n * n) for _ in range(3)]
+    for _ in range(q):
+        x, y, z = ints()
+        indices = [y * n + z, x * n + z, x * n + y]
+        for i in range(3):
+            counts[i][indices[i]] += 1
+            if counts[i][indices[i]] == n:
+                ans += 1
+        print(ans)
+
+
+def solve(n ,a ):
+    pass
+
+if __name__ == "__main__":
+    main()
Index: USACO GUIDE/Dec Bronze Contest/ItsMooinTime.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/USACO GUIDE/Dec Bronze Contest/ItsMooinTime.py b/USACO GUIDE/Dec Bronze Contest/ItsMooinTime.py
new file mode 100644
--- /dev/null	(date 1734104762635)
+++ b/USACO GUIDE/Dec Bronze Contest/ItsMooinTime.py	(date 1734104762635)
@@ -0,0 +1,172 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+from types import GeneratorType
+
+input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+
+# region fastio
+
+BUFSIZE = 8192
+
+
+class FastIO(IOBase):
+    newlines = 0
+
+    def __init__(self, file):
+        self._file = file
+        self._fd = file.fileno()
+        self.buffer = BytesIO()
+        self.writable = "x" in file.mode or "r" not in file.mode
+        self.write = self.buffer.write if self.writable else None
+
+    def read(self):
+        while True:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            if not b:
+                break
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines = 0
+        return self.buffer.read()
+
+    def readline(self):
+        while self.newlines == 0:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            self.newlines = b.count(b"\n") + (not b)
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines -= 1
+        return self.buffer.readline()
+
+    def flush(self):
+        if self.writable:
+            os.write(self._fd, self.buffer.getvalue())
+            self.buffer.truncate(0), self.buffer.seek(0)
+
+
+class IOWrapper(IOBase):
+    def __init__(self, file):
+        self.buffer = FastIO(file)
+        self.flush = self.buffer.flush
+        self.writable = self.buffer.writable
+        self.write = lambda s: self.buffer.write(s.encode("ascii"))
+        self.read = lambda: self.buffer.read().decode("ascii")
+        self.readline = lambda: self.buffer.readline().decode("ascii")
+
+
+sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
+
+
+# endregion
+
+
+def main():
+    n, f = map(int, input().split())
+    s = input()
+    moos_set = set()
+    moos_list = []
+    for ci in range(26):
+        for cj in range(26):
+            if ci != cj:
+                c_i = chr(ord('a') + ci)
+                c_j = chr(ord('a') + cj)
+                m = c_i + c_j + c_j
+                moos_set.add(m)
+                moos_list.append(m)
+    mapper = defaultdict(int)
+    for i in range(n - 2):
+        s_ = s[i:i + 3]
+        if s_ in moos_set:
+            mapper[s_] += 1
+    max_counts = mapper.copy()
+    for p in range(n):
+        original_char = s[p]
+        for c_ord in range(26):
+            c = chr(c_ord + ord('a'))
+            if c == original_char:
+                continue
+            delta_counts = defaultdict(int)
+            for i in range(p - 2, p + 1):
+                if 0 <= i <= n - 3:
+                    old_sub = s[i:i + 3]
+                    new_sub_list = list(s[i:i + 3])
+                    new_sub_list[p - i] = c
+                    new_sub = ''.join(new_sub_list)
+                    if old_sub in moos_set:
+                        delta_counts[old_sub] -= 1
+                    if new_sub in moos_set:
+                        delta_counts[new_sub] += 1
+            for m in delta_counts:
+                temp_count = mapper.get(m, 0) + delta_counts[m]
+                max_counts[m] = max(max_counts.get(m, 0), temp_count)
+    ans = [m for m in moos_list if max_counts.get(m, 0) >= f]
+    ans.sort()
+    print(len(ans))
+    print("\n".join(ans))
+
+if __name__ == "__main__":
+    main()
Index: Bootcamp/CPC Trainign DEC/D.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Bootcamp/CPC Trainign DEC/D.py b/Bootcamp/CPC Trainign DEC/D.py
new file mode 100644
--- /dev/null	(date 1734301238453)
+++ b/Bootcamp/CPC Trainign DEC/D.py	(date 1734301238453)
@@ -0,0 +1,88 @@
+import heapq
+from collections import deque
+def get_id(i, j, m):
+    return i * m + j
+
+def get_coords(id, m):
+    return divmod(id, m)
+
+n, m = map(int, input().split())
+grid = [input() for _ in range(n)]
+MAX_N = n * m
+AL = [[] for _ in range(MAX_N)]
+s = t = -1
+
+for i in range(n):
+    for j in range(m):
+        current_id = get_id(i, j, m)
+        cell = grid[i][j]
+        if cell == "S":
+            s = current_id
+        if cell == "T":
+            t = current_id
+        if cell != "#":
+            for di, dj in [(-1,0), (1,0), (0,-1), (0,1)]:
+                ni, nj = i + di, j + dj
+                if 0 <= ni < n and 0 <= nj < m and grid[ni][nj] != "#":
+                    neighbor_id = get_id(ni, nj, m)
+                    AL[current_id].append(neighbor_id)
+
+INF = int(1e9)
+dist = [INF] * MAX_N
+steps = [INF] * MAX_N
+dist[s] = 0
+steps[s] = 0
+
+pq = deque()
+pq.append((0, s, 0, -1, -1))
+
+while pq:
+    w, u, step_, dir, p = pq.popleft()
+    if w > dist[u]:
+        continue
+    for v in AL[u]:
+        if p == v: continue
+        u_i, u_j = get_coords(u, m)
+        v_i, v_j = get_coords(v, m)
+        dif_row = u_i - v_i
+        dif_col = u_j - v_j
+
+        if dir == 1 and dif_col == -1 and dif_row == 0:
+            new_step = step_ + 1
+            cur = dir
+        elif dir == 2 and dif_col == 1 and dif_row == 0:
+            new_step = step_ + 1
+            cur = dir
+        elif dir == 3 and dif_col == 0 and dif_row == 1:
+            new_step = step_ + 1
+            cur = dir
+        elif dir == 4 and dif_col == 0 and dif_row == -1:
+            new_step = step_ + 1
+            cur = dir
+        else:
+            new_step = 1
+            if dif_col == 0 and dif_row == 1:
+                cur = 3
+            elif dif_col == 0 and dif_row == -1:
+                cur = 4
+            elif dif_col == 1 and dif_row == 0:
+                cur = 2
+            elif dif_col == -1 and dif_row == 0:
+                cur = 1
+
+        if new_step > 3:
+            new_distance = dist[u] + 3
+            new_step = 2
+        else:
+            new_distance = dist[u] + 1
+
+        if new_distance > dist[v]:
+            continue
+        if new_distance == dist[v] and steps[v] < new_step:
+            continue
+
+        dist[v] = new_distance
+        steps[v] = new_step
+        pq.append((new_distance, v, new_step, cur, u))
+
+print(dist[t] if dist[t] != INF else -1)
\ No newline at end of file
Index: USACO GUIDE/GOLD/Divisibility/CSES - Counting Divisors.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/USACO GUIDE/GOLD/Divisibility/CSES - Counting Divisors.py b/USACO GUIDE/GOLD/Divisibility/CSES - Counting Divisors.py
new file mode 100644
--- /dev/null	(date 1727209663885)
+++ b/USACO GUIDE/GOLD/Divisibility/CSES - Counting Divisors.py	(date 1727209663885)
@@ -0,0 +1,68 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+
+input = lambda: sys.stdin.readline().strip()
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+def main():
+    t = int(input())
+    for _ in range(t):
+        n = int(input())
+        print(solve(n))
+
+
+def solve(n ):
+    i = 1
+    div_num = 0
+    while i * i <= n:
+        if n % i == 0:
+            div_num += 1 if i**2 == n else 2
+        i+= 1
+    return (div_num)
+
+
+
+if __name__ == "__main__":
+    main()
Index: Codeforces/CodeTON Round 9 (Div 1 + Div 2, Rated, Prizes!)/B.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Codeforces/CodeTON Round 9 (Div 1 + Div 2, Rated, Prizes!)/B.py b/Codeforces/CodeTON Round 9 (Div 1 + Div 2, Rated, Prizes!)/B.py
new file mode 100644
--- /dev/null	(date 1732373711327)
+++ b/Codeforces/CodeTON Round 9 (Div 1 + Div 2, Rated, Prizes!)/B.py	(date 1732373711327)
@@ -0,0 +1,149 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+from types import GeneratorType
+
+input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+
+# region fastio
+
+BUFSIZE = 8192
+
+
+class FastIO(IOBase):
+    newlines = 0
+
+    def __init__(self, file):
+        self._file = file
+        self._fd = file.fileno()
+        self.buffer = BytesIO()
+        self.writable = "x" in file.mode or "r" not in file.mode
+        self.write = self.buffer.write if self.writable else None
+
+    def read(self):
+        while True:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            if not b:
+                break
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines = 0
+        return self.buffer.read()
+
+    def readline(self):
+        while self.newlines == 0:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            self.newlines = b.count(b"\n") + (not b)
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines -= 1
+        return self.buffer.readline()
+
+    def flush(self):
+        if self.writable:
+            os.write(self._fd, self.buffer.getvalue())
+            self.buffer.truncate(0), self.buffer.seek(0)
+
+
+class IOWrapper(IOBase):
+    def __init__(self, file):
+        self.buffer = FastIO(file)
+        self.flush = self.buffer.flush
+        self.writable = self.buffer.writable
+        self.write = lambda s: self.buffer.write(s.encode("ascii"))
+        self.read = lambda: self.buffer.read().decode("ascii")
+        self.readline = lambda: self.buffer.readline().decode("ascii")
+
+
+sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
+
+
+# endregion
+
+
+def main():
+    t = int(input())
+    for _ in range(t):
+        s = input()
+        print(solve(s))
+
+
+def solve(s):
+    n = len(s)
+    for i in range(n - 1):
+        if s[i] == s[i + 1]:
+            return s[i:i + 2]
+    for i in range(n - 2):
+        if len(set(s[i:i + 3])) == 3:
+            return s[i:i + 3]
+    for i in range(n - 3):
+        if len(set(s[i:i + 4])) == 4:
+            return s[i:i + 4]
+    return -1
+
+
+if __name__ == "__main__":
+    main()
Index: Codeforces/Codeforces Round 993 (Div 4)/A.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Codeforces/Codeforces Round 993 (Div 4)/A.py b/Codeforces/Codeforces Round 993 (Div 4)/A.py
new file mode 100644
--- /dev/null	(date 1734273561656)
+++ b/Codeforces/Codeforces Round 993 (Div 4)/A.py	(date 1734273561656)
@@ -0,0 +1,146 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+from types import GeneratorType
+
+input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+
+# region fastio
+
+BUFSIZE = 8192
+
+
+class FastIO(IOBase):
+    newlines = 0
+
+    def __init__(self, file):
+        self._file = file
+        self._fd = file.fileno()
+        self.buffer = BytesIO()
+        self.writable = "x" in file.mode or "r" not in file.mode
+        self.write = self.buffer.write if self.writable else None
+
+    def read(self):
+        while True:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            if not b:
+                break
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines = 0
+        return self.buffer.read()
+
+    def readline(self):
+        while self.newlines == 0:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            self.newlines = b.count(b"\n") + (not b)
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines -= 1
+        return self.buffer.readline()
+
+    def flush(self):
+        if self.writable:
+            os.write(self._fd, self.buffer.getvalue())
+            self.buffer.truncate(0), self.buffer.seek(0)
+
+
+class IOWrapper(IOBase):
+    def __init__(self, file):
+        self.buffer = FastIO(file)
+        self.flush = self.buffer.flush
+        self.writable = self.buffer.writable
+        self.write = lambda s: self.buffer.write(s.encode("ascii"))
+        self.read = lambda: self.buffer.read().decode("ascii")
+        self.readline = lambda: self.buffer.readline().decode("ascii")
+
+
+sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
+
+
+# endregion
+
+
+def main():
+    t = int(input())
+    for _ in range(t):
+        n = int(input())
+        a = list(range(n))
+        print(solve(n, a))
+
+
+def solve(n ,a ):
+    ans=0
+    for i in range(1, n+1):
+        for j in range(1, n+1):
+            if i == n - j:
+                ans += 1
+                #print(i, j)
+
+    return ans
+
+if __name__ == "__main__":
+    main()
Index: Codeforces/CodeTON Round 9 (Div 1 + Div 2, Rated, Prizes!)/C.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Codeforces/CodeTON Round 9 (Div 1 + Div 2, Rated, Prizes!)/C.py b/Codeforces/CodeTON Round 9 (Div 1 + Div 2, Rated, Prizes!)/C.py
new file mode 100644
--- /dev/null	(date 1732374904168)
+++ b/Codeforces/CodeTON Round 9 (Div 1 + Div 2, Rated, Prizes!)/C.py	(date 1732374904168)
@@ -0,0 +1,167 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+from types import GeneratorType
+
+input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+
+# region fastio
+
+BUFSIZE = 8192
+
+
+class FastIO(IOBase):
+    newlines = 0
+
+    def __init__(self, file):
+        self._file = file
+        self._fd = file.fileno()
+        self.buffer = BytesIO()
+        self.writable = "x" in file.mode or "r" not in file.mode
+        self.write = self.buffer.write if self.writable else None
+
+    def read(self):
+        while True:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            if not b:
+                break
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines = 0
+        return self.buffer.read()
+
+    def readline(self):
+        while self.newlines == 0:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            self.newlines = b.ans(b"\n") + (not b)
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines -= 1
+        return self.buffer.readline()
+
+    def flush(self):
+        if self.writable:
+            os.write(self._fd, self.buffer.getvalue())
+            self.buffer.truncate(0), self.buffer.seek(0)
+
+
+class IOWrapper(IOBase):
+    def __init__(self, file):
+        self.buffer = FastIO(file)
+        self.flush = self.buffer.flush
+        self.writable = self.buffer.writable
+        self.write = lambda s: self.buffer.write(s.encode("ascii"))
+        self.read = lambda: self.buffer.read().decode("ascii")
+        self.readline = lambda: self.buffer.readline().decode("ascii")
+
+
+#sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
+
+
+# endregion
+
+
+def all_factors(n):
+    """Pyrival: returns a sorted list of all distinct factors of n"""
+    small, large = [], []
+    for i in range(1, int(n**0.5) + 1, 2 if n & 1 else 1):
+        if not n % i:
+            small.append(i)
+            large.append(n // i)
+    if small[-1] == large[-1]:
+        large.pop()
+    large.reverse()
+    small.extend(large)
+    return small
+
+def main():
+    t = int(input())
+    res = []
+    for _ in range(t):
+        x, m = ints()
+        res.append(solve(x, m))
+    print("\n".join(map(str, res)))
+
+
+def solve(x, m):
+    factors = all_factors(x)
+    mapper = {}
+    for it in factors:
+        mapper[Wrapper(it)] = True
+    ans = 0
+    for it in factors:
+        y = x ^ it
+        if y != x and 1 <= y <= m:
+            ans += 1
+    for z in range(1, x + 1):
+        if not mapper.get(Wrapper(z), False):
+            y = x ^ z
+            if y != x and y <= m and y % z == 0:
+                ans += 1
+    return ans
+
+if __name__ == "__main__":
+    main()
Index: Codeforces/Codeforces Round 993 (Div 4)/B.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Codeforces/Codeforces Round 993 (Div 4)/B.py b/Codeforces/Codeforces Round 993 (Div 4)/B.py
new file mode 100644
--- /dev/null	(date 1734273844681)
+++ b/Codeforces/Codeforces Round 993 (Div 4)/B.py	(date 1734273844681)
@@ -0,0 +1,146 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+from types import GeneratorType
+
+input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+
+# region fastio
+
+BUFSIZE = 8192
+
+
+class FastIO(IOBase):
+    newlines = 0
+
+    def __init__(self, file):
+        self._file = file
+        self._fd = file.fileno()
+        self.buffer = BytesIO()
+        self.writable = "x" in file.mode or "r" not in file.mode
+        self.write = self.buffer.write if self.writable else None
+
+    def read(self):
+        while True:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            if not b:
+                break
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines = 0
+        return self.buffer.read()
+
+    def readline(self):
+        while self.newlines == 0:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            self.newlines = b.count(b"\n") + (not b)
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines -= 1
+        return self.buffer.readline()
+
+    def flush(self):
+        if self.writable:
+            os.write(self._fd, self.buffer.getvalue())
+            self.buffer.truncate(0), self.buffer.seek(0)
+
+
+class IOWrapper(IOBase):
+    def __init__(self, file):
+        self.buffer = FastIO(file)
+        self.flush = self.buffer.flush
+        self.writable = self.buffer.writable
+        self.write = lambda s: self.buffer.write(s.encode("ascii"))
+        self.read = lambda: self.buffer.read().decode("ascii")
+        self.readline = lambda: self.buffer.readline().decode("ascii")
+
+
+sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
+
+
+# endregion
+
+
+def main():
+    t = int(input())
+    for _ in range(t):
+        s = input()
+        print(solve( s))
+
+
+def solve(a ):
+    a = a[::-1]
+    index_q = [i for i in range(len(a)) if a[i] == 'q']
+    index_p = [i for i in range(len(a)) if a[i] == 'p']
+    a = list(a)
+    for it in index_q:
+        a[it] = 'p'
+    for it in index_p:
+        a[it] = 'q'
+    return "".join(a)
+
+if __name__ == "__main__":
+    main()
Index: Codeforces/CodeTON Round 9 (Div 1 + Div 2, Rated, Prizes!)/D.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Codeforces/CodeTON Round 9 (Div 1 + Div 2, Rated, Prizes!)/D.py b/Codeforces/CodeTON Round 9 (Div 1 + Div 2, Rated, Prizes!)/D.py
new file mode 100644
--- /dev/null	(date 1732470786939)
+++ b/Codeforces/CodeTON Round 9 (Div 1 + Div 2, Rated, Prizes!)/D.py	(date 1732470786939)
@@ -0,0 +1,182 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+from types import GeneratorType
+
+input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
+
+def ints(): return map(int, input().split())
+
+
+def strs(): return input().split()
+
+
+def chars(): return list(input().strip())
+
+
+def mat(n): return [list(ints()) for _ in range(n)]
+
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+
+def add(x, y, mod=MOD): return (x + y) % mod
+
+
+def sub(x, y, mod=MOD): return (x - y) % mod
+
+
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+
+RANDOM = getrandbits(32)
+
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+# region fastio
+
+BUFSIZE = 8192
+
+
+class FastIO(IOBase):
+    newlines = 0
+
+    def __init__(self, file):
+        self._file = file
+        self._fd = file.fileno()
+        self.buffer = BytesIO()
+        self.writable = "x" in file.mode or "r" not in file.mode
+        self.write = self.buffer.write if self.writable else None
+
+    def read(self):
+        while True:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            if not b:
+                break
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines = 0
+        return self.buffer.read()
+
+    def readline(self):
+        while self.newlines == 0:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            self.newlines = b.count(b"\n") + (not b)
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines -= 1
+        return self.buffer.readline()
+
+    def flush(self):
+        if self.writable:
+            os.write(self._fd, self.buffer.getvalue())
+            self.buffer.truncate(0), self.buffer.seek(0)
+
+
+class IOWrapper(IOBase):
+    def __init__(self, file):
+        self.buffer = FastIO(file)
+        self.flush = self.buffer.flush
+        self.writable = self.buffer.writable
+        self.write = lambda s: self.buffer.write(s.encode("ascii"))
+        self.read = lambda: self.buffer.read().decode("ascii")
+        self.readline = lambda: self.buffer.readline().decode("ascii")
+
+
+#sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
+
+
+# endregion
+
+debug = False
+def main():
+    t = int(input())
+    for _ in range(t):
+        n, m = ints()
+        a = list(ints())
+        print(solve(n, m, a))
+
+
+MAX_K = 300000 + 5
+criba = [[] for _ in range(MAX_K + 1)]
+for d in range(1, MAX_K +1):
+    for multiple in range(2*d, MAX_K +1, d):
+        criba[multiple].append(d)
+
+
+def solve(n, m, a):
+    a.sort(reverse=True)
+    ans = [0] * (n + 1)
+    possible = True
+    for k in range(1, n + 1):
+        pos = [ans[d] for d in criba[k] if ans[d] != 0] if k <= MAX_K else []
+        if debug: print(pos)
+        assigned = False
+        for x in a:
+            if all(x % c != 0 for c in pos):
+                ans[k] = x
+                if debug: print(x)
+                assigned = True
+                break
+        if not assigned:
+            possible = False
+            break
+
+    return ' '.join(map(str, ans[1:n + 1])) if possible else "-1"
+
+
+if __name__ == "__main__":
+    main()
Index: USACO GUIDE/GOLD/DP/FruitFeast.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/USACO GUIDE/GOLD/DP/FruitFeast.py b/USACO GUIDE/GOLD/DP/FruitFeast.py
new file mode 100644
--- /dev/null	(date 1733108871163)
+++ b/USACO GUIDE/GOLD/DP/FruitFeast.py	(date 1733108871163)
@@ -0,0 +1,165 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+from types import GeneratorType
+
+input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+
+# region fastio
+
+BUFSIZE = 8192
+
+
+class FastIO(IOBase):
+    newlines = 0
+
+    def __init__(self, file):
+        self._file = file
+        self._fd = file.fileno()
+        self.buffer = BytesIO()
+        self.writable = "x" in file.mode or "r" not in file.mode
+        self.write = self.buffer.write if self.writable else None
+
+    def read(self):
+        while True:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            if not b:
+                break
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines = 0
+        return self.buffer.read()
+
+    def readline(self):
+        while self.newlines == 0:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            self.newlines = b.count(b"\n") + (not b)
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines -= 1
+        return self.buffer.readline()
+
+    def flush(self):
+        if self.writable:
+            os.write(self._fd, self.buffer.getvalue())
+            self.buffer.truncate(0), self.buffer.seek(0)
+
+
+class IOWrapper(IOBase):
+    def __init__(self, file):
+        self.buffer = FastIO(file)
+        self.flush = self.buffer.flush
+        self.writable = self.buffer.writable
+        self.write = lambda s: self.buffer.write(s.encode("ascii"))
+        self.read = lambda: self.buffer.read().decode("ascii")
+        self.readline = lambda: self.buffer.readline().decode("ascii")
+
+
+#sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
+
+
+# endregion
+
+
+def main():
+    #sys.stdin = open('feast.in', 'r')
+    #sys.stdout = open('feast.out', 'w')
+    total, a, b = ints()
+    print(solve(total, a, b))
+
+
+def solve(w, a, b):
+    """@lru_cache(maxsize=None)
+    def dp(remW, water):
+        if remW == w:
+            return w
+        max_f = remW
+        if remW + a <= w:
+            max_f = max(max_f, dp(remW + a, water))
+        if remW + b <= w:
+            max_f = max(max_f, dp(remW + b, water))
+        if not water and remW > 0:
+            new_f = remW // 2
+            max_f = max(max_f, dp(new_f, True))
+        return max_f"""
+    dp = [[0 for _ in range(2)] for i in range(w + 1)]
+    for water in range(2):
+        dp[w][water] = w
+    for remW  in range(w - 1, -1, -1):
+        for water in range(0, 2):
+            dp[remW][water] = remW
+            if remW + a <= w:
+                dp[remW][water] = max(dp[remW][water], dp[remW + a][ water])
+            if remW + b <= w:
+                dp[remW][water] = max(dp[remW][water], dp[remW + b][ water])
+            if not water and remW > 0:
+                new_f = remW // 2
+                dp[remW][water] = max(dp[remW][water], dp[new_f][True])
+
+    return dp[0][False]
+
+if __name__ == "__main__":
+    main()
Index: test_cases.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/test_cases.txt b/test_cases.txt
new file mode 100644
--- /dev/null	(date 1738365574785)
+++ b/test_cases.txt	(date 1738365574785)
@@ -0,0 +1,3 @@
+version https://git-lfs.github.com/spec/v1
+oid sha256:834921f2fbb42b46d0b84ad93bc1523f159fd8a7d86d0312ab4d07cc8d6fc80e
+size 214547835
Index: Codeforces/Codeforces Round 993 (Div 4)/C.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Codeforces/Codeforces Round 993 (Div 4)/C.py b/Codeforces/Codeforces Round 993 (Div 4)/C.py
new file mode 100644
--- /dev/null	(date 1734275246316)
+++ b/Codeforces/Codeforces Round 993 (Div 4)/C.py	(date 1734275246316)
@@ -0,0 +1,157 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+from types import GeneratorType
+
+input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+
+# region fastio
+
+BUFSIZE = 8192
+
+
+class FastIO(IOBase):
+    newlines = 0
+
+    def __init__(self, file):
+        self._file = file
+        self._fd = file.fileno()
+        self.buffer = BytesIO()
+        self.writable = "x" in file.mode or "r" not in file.mode
+        self.write = self.buffer.write if self.writable else None
+
+    def read(self):
+        while True:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            if not b:
+                break
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines = 0
+        return self.buffer.read()
+
+    def readline(self):
+        while self.newlines == 0:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            self.newlines = b.count(b"\n") + (not b)
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines -= 1
+        return self.buffer.readline()
+
+    def flush(self):
+        if self.writable:
+            os.write(self._fd, self.buffer.getvalue())
+            self.buffer.truncate(0), self.buffer.seek(0)
+
+
+class IOWrapper(IOBase):
+    def __init__(self, file):
+        self.buffer = FastIO(file)
+        self.flush = self.buffer.flush
+        self.writable = self.buffer.writable
+        self.write = lambda s: self.buffer.write(s.encode("ascii"))
+        self.read = lambda: self.buffer.read().decode("ascii")
+        self.readline = lambda: self.buffer.readline().decode("ascii")
+
+
+#sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
+
+
+# endregion
+
+
+def main():
+    t = int(input())
+    for _ in range(t):
+        a = list(ints())
+        print(solve(a))
+
+
+def solve(a ):
+    seats_p_r1 = a[0]
+    seats_p_r2 = a[0]
+    ans = 0
+    seats_p_r1 -= a[1]
+    if seats_p_r1 <= 0:
+        ans += a[0]
+    if seats_p_r1 > 0:
+        ans += a[1]
+        res = min(seats_p_r1, a[3])
+        a[3]-=res
+        ans += res
+
+    seats_p_r2 -= a[2]
+    if seats_p_r2 <= 0:
+        ans += a[0]
+    if seats_p_r2 > 0:
+        ans += a[2]
+        res = min(seats_p_r2, a[3])
+        a[3] -= res
+        ans += res
+    return ans
+if __name__ == "__main__":
+    main()
Index: Codeforces/Codeforces Round 993 (Div 4)/H.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Codeforces/Codeforces Round 993 (Div 4)/H.py b/Codeforces/Codeforces Round 993 (Div 4)/H.py
new file mode 100644
--- /dev/null	(date 1734276947296)
+++ b/Codeforces/Codeforces Round 993 (Div 4)/H.py	(date 1734276947296)
@@ -0,0 +1,150 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+from types import GeneratorType
+
+input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+
+# region fastio
+
+BUFSIZE = 8192
+
+
+class FastIO(IOBase):
+    newlines = 0
+
+    def __init__(self, file):
+        self._file = file
+        self._fd = file.fileno()
+        self.buffer = BytesIO()
+        self.writable = "x" in file.mode or "r" not in file.mode
+        self.write = self.buffer.write if self.writable else None
+
+    def read(self):
+        while True:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            if not b:
+                break
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines = 0
+        return self.buffer.read()
+
+    def readline(self):
+        while self.newlines == 0:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            self.newlines = b.count(b"\n") + (not b)
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines -= 1
+        return self.buffer.readline()
+
+    def flush(self):
+        if self.writable:
+            os.write(self._fd, self.buffer.getvalue())
+            self.buffer.truncate(0), self.buffer.seek(0)
+
+
+class IOWrapper(IOBase):
+    def __init__(self, file):
+        self.buffer = FastIO(file)
+        self.flush = self.buffer.flush
+        self.writable = self.buffer.writable
+        self.write = lambda s: self.buffer.write(s.encode("ascii"))
+        self.read = lambda: self.buffer.read().decode("ascii")
+        self.readline = lambda: self.buffer.readline().decode("ascii")
+
+
+sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
+
+
+# endregion
+
+
+def main():
+    t = int(input())
+    for _ in range(t):
+        n, q = ints()
+        mx = [list(ints()) for i in range(n)]
+        p1 = [[0] * (n + 1) for _ in range(n + 1)]
+        p2 = [[0] * (n + 1) for _ in range(n + 1)]
+        p3 = [[0] * (n + 1) for _ in range(n + 1)]
+        ans = []
+        for i in range(1, n + 1):
+            for j in range(1, n + 1):
+                val = mx[i - 1][j - 1]
+                p1[i][j] = p1[i - 1][j] + p1[i][j - 1] - p1[i - 1][j - 1] + val
+                p2[i][j] = p2[i - 1][j] + p2[i][j - 1] - p2[i - 1][j - 1] + val * i
+                p3[i][j] = p3[i - 1][j] + p3[i][j - 1] - p3[i - 1][j - 1] + val * j
+        for _ in range(q):
+            x1, y1, x2, y2 = ints()
+            prefix_r1 = p1[x2][y2] - p1[x1 - 1][y2] - p1[x2][y1 - 1] + p1[x1 - 1][y1 - 1]
+            prefix_r2 = p2[x2][y2] - p2[x1 - 1][y2] - p2[x2][y1 - 1] + p2[x1 - 1][y1 - 1]
+            prefix_r3 = p3[x2][y2] - p3[x1 - 1][y2] - p3[x2][y1 - 1] + p3[x1 - 1][y1 - 1]
+            ans.append((y2 - y1 + 1) * (prefix_r2 - x1 * prefix_r1) + prefix_r3 - y1 * prefix_r1 + prefix_r1)
+        print(*ans)
+if __name__ == "__main__":
+    main()
Index: Codeforces/Codeforces Round 993 (Div 4)/E.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Codeforces/Codeforces Round 993 (Div 4)/E.py b/Codeforces/Codeforces Round 993 (Div 4)/E.py
new file mode 100644
--- /dev/null	(date 1734277801398)
+++ b/Codeforces/Codeforces Round 993 (Div 4)/E.py	(date 1734277801398)
@@ -0,0 +1,141 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+from types import GeneratorType
+
+input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+
+# region fastio
+
+BUFSIZE = 8192
+
+
+class FastIO(IOBase):
+    newlines = 0
+
+    def __init__(self, file):
+        self._file = file
+        self._fd = file.fileno()
+        self.buffer = BytesIO()
+        self.writable = "x" in file.mode or "r" not in file.mode
+        self.write = self.buffer.write if self.writable else None
+
+    def read(self):
+        while True:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            if not b:
+                break
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines = 0
+        return self.buffer.read()
+
+    def readline(self):
+        while self.newlines == 0:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            self.newlines = b.count(b"\n") + (not b)
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines -= 1
+        return self.buffer.readline()
+
+    def flush(self):
+        if self.writable:
+            os.write(self._fd, self.buffer.getvalue())
+            self.buffer.truncate(0), self.buffer.seek(0)
+
+
+class IOWrapper(IOBase):
+    def __init__(self, file):
+        self.buffer = FastIO(file)
+        self.flush = self.buffer.flush
+        self.writable = self.buffer.writable
+        self.write = lambda s: self.buffer.write(s.encode("ascii"))
+        self.read = lambda: self.buffer.read().decode("ascii")
+        self.readline = lambda: self.buffer.readline().decode("ascii")
+
+
+sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
+
+
+# endregion
+
+
+def main():
+    t = int(input())
+    for _ in range(t):
+        k, l1, r1, l2, r2 = ints()
+        ans, pow_k_n = 0, 1
+        while pow_k_n <= r2 // l1:
+            x_min = max(l1, (l2 + pow_k_n - 1) // pow_k_n)
+            x_max = min(r1, r2 // pow_k_n)
+            ans+=x_max-x_min+1 if x_min<=x_max else 0
+            if pow_k_n > 1e18 // k: break
+            pow_k_n *= k
+        print(ans)
+
+if __name__ == "__main__":
+    main()
Index: Codeforces/Codeforces Round 993 (Div 4)/G.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Codeforces/Codeforces Round 993 (Div 4)/G.py b/Codeforces/Codeforces Round 993 (Div 4)/G.py
new file mode 100644
--- /dev/null	(date 1734281288034)
+++ b/Codeforces/Codeforces Round 993 (Div 4)/G.py	(date 1734281288034)
@@ -0,0 +1,208 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+from types import GeneratorType
+
+input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+
+# region fastio
+
+BUFSIZE = 8192
+
+
+class FastIO(IOBase):
+    newlines = 0
+
+    def __init__(self, file):
+        self._file = file
+        self._fd = file.fileno()
+        self.buffer = BytesIO()
+        self.writable = "x" in file.mode or "r" not in file.mode
+        self.write = self.buffer.write if self.writable else None
+
+    def read(self):
+        while True:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            if not b:
+                break
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines = 0
+        return self.buffer.read()
+
+    def readline(self):
+        while self.newlines == 0:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            self.newlines = b.count(b"\n") + (not b)
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines -= 1
+        return self.buffer.readline()
+
+    def flush(self):
+        if self.writable:
+            os.write(self._fd, self.buffer.getvalue())
+            self.buffer.truncate(0), self.buffer.seek(0)
+
+
+class IOWrapper(IOBase):
+    def __init__(self, file):
+        self.buffer = FastIO(file)
+        self.flush = self.buffer.flush
+        self.writable = self.buffer.writable
+        self.write = lambda s: self.buffer.write(s.encode("ascii"))
+        self.read = lambda: self.buffer.read().decode("ascii")
+        self.readline = lambda: self.buffer.readline().decode("ascii")
+
+
+sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
+
+
+# endregion
+
+UNVISITED = -1
+def main():
+    global a
+    t = int(input())
+    for _ in range(t):
+        n = int(input())
+        a = list(ints())
+        print(solve(n, a))
+
+dfsNumberCounter = 0
+numSCC = 0
+AL = []
+AL_T = []
+dfs_num = []
+dfs_low = []
+S = []
+visited = []
+st = []
+in_cycle = []
+a  = []
+
+def tarjanSCC(u):
+    global dfsNumberCounter, numSCC
+    dfs_num[u] = dfs_low[u] = dfsNumberCounter
+    dfsNumberCounter += 1
+    st.append(u)
+    visited[u] = True
+    for v in AL[u]:
+        if dfs_num[v] == UNVISITED:
+            tarjanSCC(v)
+        if visited[v]:
+            dfs_low[u] = min(dfs_low[u], dfs_low[v])
+    if dfs_low[u] == dfs_num[u]:
+        # Found an SCC
+        numSCC += 1
+        scc = []
+        while True:
+            v = st.pop()
+            visited[v] = False
+            scc.append(v)
+            if u == v:
+                break
+        if len(scc) > 1 or a[u] == u:
+            for node in scc:
+                #print(node)
+                in_cycle[node] = True
+
+def solve(n ,a ):
+    global dfs_low, dfs_num, dfsNumberCounter, visited, AL, AL_T, in_cycle, numSCC, st
+    a = [it - 1 for it in a]
+    AL = [[] for i in range(n)]
+    AL_T = [[] for _ in range(n)]
+    for i in range(n):
+        AL[i].append(a[i])
+        AL_T[a[i]].append(i)
+    dfs_num = [UNVISITED] * n
+    dfs_low = [0] * n
+    visited = [False] * n
+    st = []
+    dfsNumberCounter = 0
+    numSCC = 0
+    in_cycle = [False] * n
+    for v in range(n):
+        if dfs_num[v] == UNVISITED:
+            tarjanSCC(v)
+    dist = [INF] * n
+    q = deque()
+
+    for i in range(n):
+        if in_cycle[i]:
+            dist[i] = 0
+            q.append(i)
+    while q:
+        u = q.popleft()
+        for v in AL_T[u]:
+            if dist[v] == INF:
+                dist[v] = dist[u] + 1
+                q.append(v)
+    ans = max([d for d in dist if d != INF], default=0)
+    #print(ans, "ANS")
+    return ans  + 2
+if __name__ == "__main__":
+    main()
Index: Codeforces/Codeforces Round 993 (Div 4)/D.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Codeforces/Codeforces Round 993 (Div 4)/D.py b/Codeforces/Codeforces Round 993 (Div 4)/D.py
new file mode 100644
--- /dev/null	(date 1734280310019)
+++ b/Codeforces/Codeforces Round 993 (Div 4)/D.py	(date 1734280310019)
@@ -0,0 +1,141 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+from types import GeneratorType
+
+input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+
+# region fastio
+
+BUFSIZE = 8192
+
+
+class FastIO(IOBase):
+    newlines = 0
+
+    def __init__(self, file):
+        self._file = file
+        self._fd = file.fileno()
+        self.buffer = BytesIO()
+        self.writable = "x" in file.mode or "r" not in file.mode
+        self.write = self.buffer.write if self.writable else None
+
+    def read(self):
+        while True:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            if not b:
+                break
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines = 0
+        return self.buffer.read()
+
+    def readline(self):
+        while self.newlines == 0:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            self.newlines = b.count(b"\n") + (not b)
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines -= 1
+        return self.buffer.readline()
+
+    def flush(self):
+        if self.writable:
+            os.write(self._fd, self.buffer.getvalue())
+            self.buffer.truncate(0), self.buffer.seek(0)
+
+
+class IOWrapper(IOBase):
+    def __init__(self, file):
+        self.buffer = FastIO(file)
+        self.flush = self.buffer.flush
+        self.writable = self.buffer.writable
+        self.write = lambda s: self.buffer.write(s.encode("ascii"))
+        self.read = lambda: self.buffer.read().decode("ascii")
+        self.readline = lambda: self.buffer.readline().decode("ascii")
+
+
+sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
+
+
+# endregion
+
+
+def main():
+    t = int(input())
+    for _ in range(t):
+        n = int(input())
+        a = list(ints())
+        print(solve(n, a))
+
+
+def solve(n ,a):
+    current = list(set(range(1, n + 1)) - set(a))
+    seen = set()
+    b = [x if x not in seen and not seen.add(x) else current.pop() for x in a]
+    return ' '.join(map(str, b))
+if __name__ == "__main__":
+    main()
Index: Codeforces/Codeforces Round 988 (Div 3)/B.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Codeforces/Codeforces Round 988 (Div 3)/B.py b/Codeforces/Codeforces Round 988 (Div 3)/B.py
new file mode 100644
--- /dev/null	(date 1731950153429)
+++ b/Codeforces/Codeforces Round 988 (Div 3)/B.py	(date 1731950153429)
@@ -0,0 +1,70 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+
+input = lambda: sys.stdin.readline().strip()
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+def main():
+    t = int(input())
+    for _ in range(t):
+        n = int(input())
+        a = list(ints())
+        print(*solve(n, a))
+
+
+def solve(k ,a ):
+    to_find = k - 2
+    mapper = {}
+    for it in a:
+        mapper[Wrapper(it)] = mapper.get(Wrapper(it),0) + 1
+    for it in a:
+        if to_find % it == 0:
+            x = to_find // it
+            if x == it and Wrapper(x) in mapper and mapper[Wrapper(x)] > 1 or Wrapper(x) in mapper and x != it:
+               return [it, x]
+    return [1, 1]
+
+if __name__ == "__main__":
+    main()
Index: ICPC Preparation/Graph/ Ad Hoc Graph Traversal/12376 - As Long as I Learn, I Live.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ICPC Preparation/Graph/ Ad Hoc Graph Traversal/12376 - As Long as I Learn, I Live.py b/ICPC Preparation/Graph/ Ad Hoc Graph Traversal/12376 - As Long as I Learn, I Live.py
new file mode 100644
--- /dev/null	(date 1734367181151)
+++ b/ICPC Preparation/Graph/ Ad Hoc Graph Traversal/12376 - As Long as I Learn, I Live.py	(date 1734367181151)
@@ -0,0 +1,156 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+from types import GeneratorType
+
+input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+
+# region fastio
+
+BUFSIZE = 8192
+
+
+class FastIO(IOBase):
+    newlines = 0
+
+    def __init__(self, file):
+        self._file = file
+        self._fd = file.fileno()
+        self.buffer = BytesIO()
+        self.writable = "x" in file.mode or "r" not in file.mode
+        self.write = self.buffer.write if self.writable else None
+
+    def read(self):
+        while True:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            if not b:
+                break
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines = 0
+        return self.buffer.read()
+
+    def readline(self):
+        while self.newlines == 0:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            self.newlines = b.count(b"\n") + (not b)
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines -= 1
+        return self.buffer.readline()
+
+    def flush(self):
+        if self.writable:
+            os.write(self._fd, self.buffer.getvalue())
+            self.buffer.truncate(0), self.buffer.seek(0)
+
+
+class IOWrapper(IOBase):
+    def __init__(self, file):
+        self.buffer = FastIO(file)
+        self.flush = self.buffer.flush
+        self.writable = self.buffer.writable
+        self.write = lambda s: self.buffer.write(s.encode("ascii"))
+        self.read = lambda: self.buffer.read().decode("ascii")
+        self.readline = lambda: self.buffer.readline().decode("ascii")
+
+
+#sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
+
+
+# endregion
+
+
+def main():
+    t = int(input())
+    for case in range(t):
+        input()
+        n, m = ints()
+        a = list(ints())
+        AL = [[] for i in range(n)]
+        for _ in range(m):
+            u, v = ints()
+            AL[u].append(v)
+        visited = [False] * n
+        ans = 0
+        last = 0
+        def dfs(u):
+            nonlocal ans, last
+            last = u
+            visited[u] = True
+            to_ = None
+            cur = 0
+            for v in AL[u]:
+                if a[v] > cur:
+                    cur = a[v]
+                    to_ = v
+            if to_ is not None:
+                ans += a[to_]
+                dfs(to_)
+        dfs(0)
+        print(f"Case {case+1}: {ans} {last}")
+if __name__ == "__main__":
+    main()
Index: ICPC Preparation/Graph/ Ad Hoc Graph Traversal/12442 - Forwarding Emails.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ICPC Preparation/Graph/ Ad Hoc Graph Traversal/12442 - Forwarding Emails.py b/ICPC Preparation/Graph/ Ad Hoc Graph Traversal/12442 - Forwarding Emails.py
new file mode 100644
--- /dev/null	(date 1734372918426)
+++ b/ICPC Preparation/Graph/ Ad Hoc Graph Traversal/12442 - Forwarding Emails.py	(date 1734372918426)
@@ -0,0 +1,164 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+from types import GeneratorType
+
+input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+
+# region fastio
+
+BUFSIZE = 8192
+
+
+class FastIO(IOBase):
+    newlines = 0
+
+    def __init__(self, file):
+        self._file = file
+        self._fd = file.fileno()
+        self.buffer = BytesIO()
+        self.writable = "x" in file.mode or "r" not in file.mode
+        self.write = self.buffer.write if self.writable else None
+
+    def read(self):
+        while True:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            if not b:
+                break
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines = 0
+        return self.buffer.read()
+
+    def readline(self):
+        while self.newlines == 0:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            self.newlines = b.count(b"\n") + (not b)
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines -= 1
+        return self.buffer.readline()
+
+    def flush(self):
+        if self.writable:
+            os.write(self._fd, self.buffer.getvalue())
+            self.buffer.truncate(0), self.buffer.seek(0)
+
+
+class IOWrapper(IOBase):
+    def __init__(self, file):
+        self.buffer = FastIO(file)
+        self.flush = self.buffer.flush
+        self.writable = self.buffer.writable
+        self.write = lambda s: self.buffer.write(s.encode("ascii"))
+        self.read = lambda: self.buffer.read().decode("ascii")
+        self.readline = lambda: self.buffer.readline().decode("ascii")
+
+
+#sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
+
+
+# endregion
+
+
+def main():
+    t = int(input())
+    res = []
+    for _ in range(t):
+        n = int(input())
+        AL = [[] for i in range(n+1)]
+        for i in range(n):
+            u, v = ints()
+            AL[u].append(v)
+        ans = 0
+        visited = [False] * (n+1)
+        d = [-1] * (n+1)
+        def dfs(u):
+            visited[u] = True
+            ans = 0
+            for v in AL[u]:
+                if not visited[v]:
+                    ans += 1 + dfs(v)
+            visited[u] = False
+            d[u] = ans
+            return ans
+        #print(dfs(1),dfs(5))
+        node = 0
+        for u in range(1, n+1):
+            if (d[u] == -1): dfs(u)
+            # print(d)
+            if ans < d[u]:
+                ans = d[u]
+                node = u
+
+        res.append(f"Case {_+1}: {node}")
+    print("\n".join(res))
+
+def solve(n ,a ):
+    pass
+
+if __name__ == "__main__":
+    main()
Index: ICPC Preparation/Graph/ Ad Hoc Graph Traversal/11831 - Sticker Collector Robot.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ICPC Preparation/Graph/ Ad Hoc Graph Traversal/11831 - Sticker Collector Robot.py b/ICPC Preparation/Graph/ Ad Hoc Graph Traversal/11831 - Sticker Collector Robot.py
new file mode 100644
--- /dev/null	(date 1734406746228)
+++ b/ICPC Preparation/Graph/ Ad Hoc Graph Traversal/11831 - Sticker Collector Robot.py	(date 1734406746228)
@@ -0,0 +1,171 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+from types import GeneratorType
+
+input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+
+# region fastio
+
+BUFSIZE = 8192
+
+
+class FastIO(IOBase):
+    newlines = 0
+
+    def __init__(self, file):
+        self._file = file
+        self._fd = file.fileno()
+        self.buffer = BytesIO()
+        self.writable = "x" in file.mode or "r" not in file.mode
+        self.write = self.buffer.write if self.writable else None
+
+    def read(self):
+        while True:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            if not b:
+                break
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines = 0
+        return self.buffer.read()
+
+    def readline(self):
+        while self.newlines == 0:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            self.newlines = b.count(b"\n") + (not b)
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines -= 1
+        return self.buffer.readline()
+
+    def flush(self):
+        if self.writable:
+            os.write(self._fd, self.buffer.getvalue())
+            self.buffer.truncate(0), self.buffer.seek(0)
+
+
+class IOWrapper(IOBase):
+    def __init__(self, file):
+        self.buffer = FastIO(file)
+        self.flush = self.buffer.flush
+        self.writable = self.buffer.writable
+        self.write = lambda s: self.buffer.write(s.encode("ascii"))
+        self.read = lambda: self.buffer.read().decode("ascii")
+        self.readline = lambda: self.buffer.readline().decode("ascii")
+
+
+#sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
+
+
+# endregion
+
+
+def main():
+    mapper = {
+        'O': {"D":"N", "E":"S"},
+        'N': {"D":"L", "E":"O"},
+        'S': {"D":"O", "E":"L"},
+        'L': {"D":"S", "E":"N"}
+    }
+    while True:
+        n, m , q = ints()
+        if n == m == q == 0: break
+        mx = [list(input().strip()) for i in range(n)]
+        s = input()
+        o_i, o_j = 0, 0
+        curr = ""
+        for i in range(n):
+            for j in range(m):
+                if mx[i][j] != '.' and mx[i][j] != '#' and mx[i][j] != '*':
+                    o_i, o_j = i, j
+                    curr = mx[i][j]
+                    mx[i][j] = "."
+        ans = 0
+        for it in s:
+            if curr == 'O' and it == 'F':
+                if o_j > 0  and mx[o_i][o_j - 1] != '#':
+                    o_j -= 1
+            elif curr == 'N' and it == 'F':
+                if o_i > 0  and mx[o_i - 1][o_j] != '#':
+                    o_i -= 1
+            elif curr == 'S' and it == 'F':
+                if o_i < n - 1  and mx[o_i + 1][o_j] != '#':
+                    o_i += 1
+            elif curr == 'L' and it == 'F':
+                if o_j < m - 1  and mx[o_i][o_j + 1] != '#':
+                    o_j += 1
+            elif it == 'D' or it  == 'E':
+                curr = mapper[curr][it]
+            if mx[o_i][o_j] == '*':
+                ans += 1
+                mx[o_i][o_j] = '.'
+        print(ans)
+def solve(n ,a ):
+    pass
+
+if __name__ == "__main__":
+    main()
Index: Meta Hacker Cup 2024/Round 1/A/A.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Meta Hacker Cup 2024/Round 1/A/A.py b/Meta Hacker Cup 2024/Round 1/A/A.py
new file mode 100644
--- /dev/null	(date 1728148452202)
+++ b/Meta Hacker Cup 2024/Round 1/A/A.py	(date 1728148452202)
@@ -0,0 +1,85 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+
+input = lambda: sys.stdin.readline().strip()
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+def main():
+    t = int(input())
+    for _ in range(t):
+        max_L = 0.0
+        min_U = float('inf')
+        n = int(input())
+        for i in range(1, n + 1):
+            ai, bi = ints()
+            L_i = i / bi
+            max_L = max(max_L, L_i)
+            if ai > 0:
+                U_i = i / ai
+                min_U = min(min_U, U_i)
+            else:
+                pass
+        if max_L <= min_U + 1e-9:
+            print(f"Case #{_ + 1}: {max_L:.10f}")
+        else:
+            print(f"Case #{_ + 1}: -1")
+
+
+def solve(n ,k, a ):
+    ans = 0
+    a.sort()
+    for i in range(1, n):
+        if i == n-1:
+            ans+=a[0]
+        else:
+            ans += a[0]*2
+
+    ans += a[0] if n == 1 else 0
+    return "YES" if ans <= k else "NO"
+
+
+
+if __name__ == "__main__":
+    main()
Index: Codeforces/Codeforces Round 994 (Div 2)/A.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Codeforces/Codeforces Round 994 (Div 2)/A.py b/Codeforces/Codeforces Round 994 (Div 2)/A.py
new file mode 100644
--- /dev/null	(date 1734706282358)
+++ b/Codeforces/Codeforces Round 994 (Div 2)/A.py	(date 1734706282358)
@@ -0,0 +1,149 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+from types import GeneratorType
+
+input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+
+# region fastio
+
+BUFSIZE = 8192
+
+
+class FastIO(IOBase):
+    newlines = 0
+
+    def __init__(self, file):
+        self._file = file
+        self._fd = file.fileno()
+        self.buffer = BytesIO()
+        self.writable = "x" in file.mode or "r" not in file.mode
+        self.write = self.buffer.write if self.writable else None
+
+    def read(self):
+        while True:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            if not b:
+                break
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines = 0
+        return self.buffer.read()
+
+    def readline(self):
+        while self.newlines == 0:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            self.newlines = b.count(b"\n") + (not b)
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines -= 1
+        return self.buffer.readline()
+
+    def flush(self):
+        if self.writable:
+            os.write(self._fd, self.buffer.getvalue())
+            self.buffer.truncate(0), self.buffer.seek(0)
+
+
+class IOWrapper(IOBase):
+    def __init__(self, file):
+        self.buffer = FastIO(file)
+        self.flush = self.buffer.flush
+        self.writable = self.buffer.writable
+        self.write = lambda s: self.buffer.write(s.encode("ascii"))
+        self.read = lambda: self.buffer.read().decode("ascii")
+        self.readline = lambda: self.buffer.readline().decode("ascii")
+
+
+sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
+
+
+# endregion
+
+
+def main():
+    t = int(input())
+    for _ in range(t):
+        n = int(input())
+        a = list(ints())
+        print(solve(n, a))
+
+
+def solve(n ,a ):
+    if all(it == 0 for it in a):
+        return 0
+    ans = 0
+    flag = False
+    for it in a:
+        if it != 0 and not flag:
+            ans += 1
+            flag = True
+        elif it == 0:
+            flag = False
+    return 1 if ans == 1 else 2
+
+if __name__ == "__main__":
+    main()
Index: Codeforces/Codeforces Round 994 (Div 2)/B.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Codeforces/Codeforces Round 994 (Div 2)/B.py b/Codeforces/Codeforces Round 994 (Div 2)/B.py
new file mode 100644
--- /dev/null	(date 1734707384687)
+++ b/Codeforces/Codeforces Round 994 (Div 2)/B.py	(date 1734707384687)
@@ -0,0 +1,161 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+from types import GeneratorType
+
+input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+
+# region fastio
+
+BUFSIZE = 8192
+
+
+class FastIO(IOBase):
+    newlines = 0
+
+    def __init__(self, file):
+        self._file = file
+        self._fd = file.fileno()
+        self.buffer = BytesIO()
+        self.writable = "x" in file.mode or "r" not in file.mode
+        self.write = self.buffer.write if self.writable else None
+
+    def read(self):
+        while True:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            if not b:
+                break
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines = 0
+        return self.buffer.read()
+
+    def readline(self):
+        while self.newlines == 0:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            self.newlines = b.count(b"\n") + (not b)
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines -= 1
+        return self.buffer.readline()
+
+    def flush(self):
+        if self.writable:
+            os.write(self._fd, self.buffer.getvalue())
+            self.buffer.truncate(0), self.buffer.seek(0)
+
+
+class IOWrapper(IOBase):
+    def __init__(self, file):
+        self.buffer = FastIO(file)
+        self.flush = self.buffer.flush
+        self.writable = self.buffer.writable
+        self.write = lambda s: self.buffer.write(s.encode("ascii"))
+        self.read = lambda: self.buffer.read().decode("ascii")
+        self.readline = lambda: self.buffer.readline().decode("ascii")
+
+
+sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
+
+
+# endregion
+
+
+def main():
+    t = int(input())
+    res = []
+    for _ in range(t):
+        n = int(input())
+        s = input()
+        res.append(solve(n, s))
+    print("\n".join(res))
+
+def solve(n, s):
+    if n == 1: return "YES"
+    p = [INF] * (n + 1)
+    for i, it in enumerate(s, 1):
+        if it == 'p' and i < n:
+            p[i] = i
+    p_r = [INF] * (n + 2)
+    for i in range(n, 0, -1):
+        p_r[i] = min(p[i], p_r[i + 1])
+    values = [INF] * (n + 1)
+    for i, it in enumerate(s, 1):
+        if it == 's' and i > 1:
+            values[i] = n - i + 1
+    p_l = [INF] * (n + 1)
+    for i in range(1, n + 1):
+        p_l[i] = min(p_l[i - 1], values[i]) if i > 1 else values[i]
+    max_ = [min(p_r[i], p_l[i]) if min(p_r[i], p_l[i]) != INF else n for i in range(n + 1)]
+    ans = sorted((max_[i], i) for i in range(1, n + 1))
+    can, count = True, 1
+    for bound, _ in ans:
+        #print(count)
+        if count > bound: return "NO"
+        count += 1
+    return "YES" if can else "NO"
+if __name__ == "__main__":
+    main()
Index: Codeforces/Codeforces Round 994 (Div 2)/C.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Codeforces/Codeforces Round 994 (Div 2)/C.py b/Codeforces/Codeforces Round 994 (Div 2)/C.py
new file mode 100644
--- /dev/null	(date 1734711114014)
+++ b/Codeforces/Codeforces Round 994 (Div 2)/C.py	(date 1734711114014)
@@ -0,0 +1,154 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+from types import GeneratorType
+
+input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+
+# region fastio
+
+BUFSIZE = 8192
+
+
+class FastIO(IOBase):
+    newlines = 0
+
+    def __init__(self, file):
+        self._file = file
+        self._fd = file.fileno()
+        self.buffer = BytesIO()
+        self.writable = "x" in file.mode or "r" not in file.mode
+        self.write = self.buffer.write if self.writable else None
+
+    def read(self):
+        while True:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            if not b:
+                break
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines = 0
+        return self.buffer.read()
+
+    def readline(self):
+        while self.newlines == 0:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            self.newlines = b.count(b"\n") + (not b)
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines -= 1
+        return self.buffer.readline()
+
+    def flush(self):
+        if self.writable:
+            os.write(self._fd, self.buffer.getvalue())
+            self.buffer.truncate(0), self.buffer.seek(0)
+
+
+class IOWrapper(IOBase):
+    def __init__(self, file):
+        self.buffer = FastIO(file)
+        self.flush = self.buffer.flush
+        self.writable = self.buffer.writable
+        self.write = lambda s: self.buffer.write(s.encode("ascii"))
+        self.read = lambda: self.buffer.read().decode("ascii")
+        self.readline = lambda: self.buffer.readline().decode("ascii")
+
+
+sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
+
+
+# endregion
+
+
+def main():
+    t = int(input())
+    for _ in range(t):
+        n,x,y = ints()
+        print(*solve(n, x, y))
+
+
+def solve(n ,x, y):
+    AL =  [[] for i in range(n+1)]
+    for i in range(n+1):
+        AL[i].append((i - 1) if i > 1 else n)
+        AL[i].append((i + 1) if i < n else 1)
+    AL[x].append(y)
+    AL[y].append(x)
+    ans = [-1] * (n + 1)
+    for u in range(1, n + 1):
+        mex = 0
+        set_ = set()
+        for friend in AL[u]:
+            if ans[friend] != -1:
+                set_.add(ans[friend])
+        while mex in set_: #POC
+            mex += 1
+        ans[u] = mex
+    return ans[1:]
+
+if __name__ == "__main__":
+    main()
Index: Codeforces/Codeforces Round 995 (Div 3)/A.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Codeforces/Codeforces Round 995 (Div 3)/A.py b/Codeforces/Codeforces Round 995 (Div 3)/A.py
new file mode 100644
--- /dev/null	(date 1734878434899)
+++ b/Codeforces/Codeforces Round 995 (Div 3)/A.py	(date 1734878434899)
@@ -0,0 +1,145 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+from types import GeneratorType
+
+input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+
+# region fastio
+
+BUFSIZE = 8192
+
+
+class FastIO(IOBase):
+    newlines = 0
+
+    def __init__(self, file):
+        self._file = file
+        self._fd = file.fileno()
+        self.buffer = BytesIO()
+        self.writable = "x" in file.mode or "r" not in file.mode
+        self.write = self.buffer.write if self.writable else None
+
+    def read(self):
+        while True:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            if not b:
+                break
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines = 0
+        return self.buffer.read()
+
+    def readline(self):
+        while self.newlines == 0:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            self.newlines = b.count(b"\n") + (not b)
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines -= 1
+        return self.buffer.readline()
+
+    def flush(self):
+        if self.writable:
+            os.write(self._fd, self.buffer.getvalue())
+            self.buffer.truncate(0), self.buffer.seek(0)
+
+
+class IOWrapper(IOBase):
+    def __init__(self, file):
+        self.buffer = FastIO(file)
+        self.flush = self.buffer.flush
+        self.writable = self.buffer.writable
+        self.write = lambda s: self.buffer.write(s.encode("ascii"))
+        self.read = lambda: self.buffer.read().decode("ascii")
+        self.readline = lambda: self.buffer.readline().decode("ascii")
+
+
+sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
+
+
+# endregion
+
+
+def main():
+    t = int(input())
+    for _ in range(t):
+        n = int(input())
+        a = list(ints())
+        b = list(ints())
+        print(solve(n, a, b))
+
+
+def solve(n ,a, b ):
+    x, y = 0, 0
+    b += [0]
+    for i in range(n):
+        if (x + a[i]) - (y + b[i+1]) > x - y:
+            x += a[i]
+            y += b[i+1]
+    return x - y
+if __name__ == "__main__":
+    main()
Index: Codeforces/Codeforces Round 995 (Div 3)/B.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Codeforces/Codeforces Round 995 (Div 3)/B.py b/Codeforces/Codeforces Round 995 (Div 3)/B.py
new file mode 100644
--- /dev/null	(date 1734879106239)
+++ b/Codeforces/Codeforces Round 995 (Div 3)/B.py	(date 1734879106239)
@@ -0,0 +1,149 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+from types import GeneratorType
+
+input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+
+# region fastio
+
+BUFSIZE = 8192
+
+
+class FastIO(IOBase):
+    newlines = 0
+
+    def __init__(self, file):
+        self._file = file
+        self._fd = file.fileno()
+        self.buffer = BytesIO()
+        self.writable = "x" in file.mode or "r" not in file.mode
+        self.write = self.buffer.write if self.writable else None
+
+    def read(self):
+        while True:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            if not b:
+                break
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines = 0
+        return self.buffer.read()
+
+    def readline(self):
+        while self.newlines == 0:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            self.newlines = b.count(b"\n") + (not b)
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines -= 1
+        return self.buffer.readline()
+
+    def flush(self):
+        if self.writable:
+            os.write(self._fd, self.buffer.getvalue())
+            self.buffer.truncate(0), self.buffer.seek(0)
+
+
+class IOWrapper(IOBase):
+    def __init__(self, file):
+        self.buffer = FastIO(file)
+        self.flush = self.buffer.flush
+        self.writable = self.buffer.writable
+        self.write = lambda s: self.buffer.write(s.encode("ascii"))
+        self.read = lambda: self.buffer.read().decode("ascii")
+        self.readline = lambda: self.buffer.readline().decode("ascii")
+
+
+sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
+
+
+# endregion
+
+
+def main():
+    t = int(input())
+    for _ in range(t):
+        a = list(ints())
+        n = a[0]
+        a = a[1:]
+        print(solve(n, a))
+
+
+def solve(n ,a ):
+    total = sum(a)
+    steps = n // total
+    rem_steps = n % total
+    ans = steps * 3
+    index = 0
+    #print(rem_steps)
+    while rem_steps > 0:
+        rem_steps -= a[(index % n)]
+        ans += 1
+        index += 1
+    return ans
+if __name__ == "__main__":
+    main()
Index: Codeforces/Codeforces Round 995 (Div 3)/C.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Codeforces/Codeforces Round 995 (Div 3)/C.py b/Codeforces/Codeforces Round 995 (Div 3)/C.py
new file mode 100644
--- /dev/null	(date 1734879650895)
+++ b/Codeforces/Codeforces Round 995 (Div 3)/C.py	(date 1734879650895)
@@ -0,0 +1,144 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+from types import GeneratorType
+
+input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+
+# region fastio
+
+BUFSIZE = 8192
+
+
+class FastIO(IOBase):
+    newlines = 0
+
+    def __init__(self, file):
+        self._file = file
+        self._fd = file.fileno()
+        self.buffer = BytesIO()
+        self.writable = "x" in file.mode or "r" not in file.mode
+        self.write = self.buffer.write if self.writable else None
+
+    def read(self):
+        while True:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            if not b:
+                break
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines = 0
+        return self.buffer.read()
+
+    def readline(self):
+        while self.newlines == 0:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            self.newlines = b.count(b"\n") + (not b)
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines -= 1
+        return self.buffer.readline()
+
+    def flush(self):
+        if self.writable:
+            os.write(self._fd, self.buffer.getvalue())
+            self.buffer.truncate(0), self.buffer.seek(0)
+
+
+class IOWrapper(IOBase):
+    def __init__(self, file):
+        self.buffer = FastIO(file)
+        self.flush = self.buffer.flush
+        self.writable = self.buffer.writable
+        self.write = lambda s: self.buffer.write(s.encode("ascii"))
+        self.read = lambda: self.buffer.read().decode("ascii")
+        self.readline = lambda: self.buffer.readline().decode("ascii")
+
+
+sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
+
+
+# endregion
+
+
+def main():
+    t = int(input())
+    for _ in range(t):
+        n,m,k = ints()
+        a = list(ints())
+        q = list(ints())
+        print(solve(n, m, k, a, q))
+
+
+def solve(n, m, k, a, q ):
+    cur = 1
+    for it in q:
+        if it == cur: cur += 1
+        elif it > cur: break
+    return "".join('1' if x == min(cur, n) else '0' for x in a) if k == n - 1 else "1" * m if k == n else "0" * m
+
+if __name__ == "__main__":
+    main()
Index: Codeforces/Codeforces Round 995 (Div 3)/D.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Codeforces/Codeforces Round 995 (Div 3)/D.py b/Codeforces/Codeforces Round 995 (Div 3)/D.py
new file mode 100644
--- /dev/null	(date 1734880693287)
+++ b/Codeforces/Codeforces Round 995 (Div 3)/D.py	(date 1734880693287)
@@ -0,0 +1,158 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+from types import GeneratorType
+
+input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+
+# region fastio
+
+BUFSIZE = 8192
+
+
+class FastIO(IOBase):
+    newlines = 0
+
+    def __init__(self, file):
+        self._file = file
+        self._fd = file.fileno()
+        self.buffer = BytesIO()
+        self.writable = "x" in file.mode or "r" not in file.mode
+        self.write = self.buffer.write if self.writable else None
+
+    def read(self):
+        while True:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            if not b:
+                break
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines = 0
+        return self.buffer.read()
+
+    def readline(self):
+        while self.newlines == 0:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            self.newlines = b.count(b"\n") + (not b)
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines -= 1
+        return self.buffer.readline()
+
+    def flush(self):
+        if self.writable:
+            os.write(self._fd, self.buffer.getvalue())
+            self.buffer.truncate(0), self.buffer.seek(0)
+
+
+class IOWrapper(IOBase):
+    def __init__(self, file):
+        self.buffer = FastIO(file)
+        self.flush = self.buffer.flush
+        self.writable = self.buffer.writable
+        self.write = lambda s: self.buffer.write(s.encode("ascii"))
+        self.read = lambda: self.buffer.read().decode("ascii")
+        self.readline = lambda: self.buffer.readline().decode("ascii")
+
+
+sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
+
+
+# endregion
+
+
+def main():
+    t = int(input())
+    res = []
+    for _ in range(t):
+        n, x, y = ints()
+        a = sorted(list(ints()))
+        res.append(str(solve(n, x, y ,a)))
+    print("\n".join(res))
+
+def can(a, hi, lo, target):
+    return a[lo] + a[hi] <= target
+
+def sliding(n, a, target):
+    ans = 0
+    lo = 0
+    hi = n - 1
+    while lo < hi:
+        if can(a, hi, lo, target):
+            ans += (hi - lo)
+            lo += 1
+        else:
+            hi -= 1
+    return ans
+
+def solve(n, x, y ,a ):
+    sum_ = sum(a)
+    lo = sum_ - y
+    hi = sum_ - x
+    #print(sum_, lo, hi)
+    return sliding(n, a, hi) - sliding(n, a, lo - 1)
+if __name__ == "__main__":
+    main()
Index: Codeforces/Codeforces Round 995 (Div 3)/E.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Codeforces/Codeforces Round 995 (Div 3)/E.py b/Codeforces/Codeforces Round 995 (Div 3)/E.py
new file mode 100644
--- /dev/null	(date 1734882975674)
+++ b/Codeforces/Codeforces Round 995 (Div 3)/E.py	(date 1734882975674)
@@ -0,0 +1,143 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+from types import GeneratorType
+
+input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+
+# region fastio
+
+BUFSIZE = 8192
+
+
+class FastIO(IOBase):
+    newlines = 0
+
+    def __init__(self, file):
+        self._file = file
+        self._fd = file.fileno()
+        self.buffer = BytesIO()
+        self.writable = "x" in file.mode or "r" not in file.mode
+        self.write = self.buffer.write if self.writable else None
+
+    def read(self):
+        while True:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            if not b:
+                break
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines = 0
+        return self.buffer.read()
+
+    def readline(self):
+        while self.newlines == 0:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            self.newlines = b.count(b"\n") + (not b)
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines -= 1
+        return self.buffer.readline()
+
+    def flush(self):
+        if self.writable:
+            os.write(self._fd, self.buffer.getvalue())
+            self.buffer.truncate(0), self.buffer.seek(0)
+
+
+class IOWrapper(IOBase):
+    def __init__(self, file):
+        self.buffer = FastIO(file)
+        self.flush = self.buffer.flush
+        self.writable = self.buffer.writable
+        self.write = lambda s: self.buffer.write(s.encode("ascii"))
+        self.read = lambda: self.buffer.read().decode("ascii")
+        self.readline = lambda: self.buffer.readline().decode("ascii")
+
+
+sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
+
+
+# endregion
+
+
+def main():
+    t = int(input())
+    res = []
+    for _ in range(t):
+        n, k = ints()
+        a, b = sorted(list(ints())), sorted(list(ints()))
+        union = sorted(set(a + b))
+        res.append(str(solve(n, k, a, b, union)))
+    print("\n".join(res))
+
+
+def solve(n, k, a, b, union):
+    return max((it * (n - left_b) for it in union
+               if (left_a := bisect_left(a, it)) - (left_b := bisect_left(b, it)) <= k), default=0)
+
+if __name__ == "__main__":
+    main()
Index: USACO GUIDE/GOLD/Combinatory/Yosupo - Montmort Number.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/USACO GUIDE/GOLD/Combinatory/Yosupo - Montmort Number.py b/USACO GUIDE/GOLD/Combinatory/Yosupo - Montmort Number.py
new file mode 100644
--- /dev/null	(date 1731370570094)
+++ b/USACO GUIDE/GOLD/Combinatory/Yosupo - Montmort Number.py	(date 1731370570094)
@@ -0,0 +1,65 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+
+input = lambda: sys.stdin.readline().strip()
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+def main():
+    global MOD
+    t, MOD = ints()
+    ans = []
+    for i in range(1, t+ 1):
+        ans.append(solve(i))
+    print(" ".join(map(str, ans)))
+
+@lru_cache(maxsize=None)
+def solve(n):
+    if n == 1: return 0
+    if n == 2: return 1
+    return (n- 1) % MOD * (solve(n-1) % MOD + solve(n-2) % MOD) % MOD
+
+
+if __name__ == "__main__":
+    main()
Index: Codeforces/Codeforces Round 995 (Div 3)/G.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Codeforces/Codeforces Round 995 (Div 3)/G.py b/Codeforces/Codeforces Round 995 (Div 3)/G.py
new file mode 100644
--- /dev/null	(date 1734886210262)
+++ b/Codeforces/Codeforces Round 995 (Div 3)/G.py	(date 1734886210262)
@@ -0,0 +1,173 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+from types import GeneratorType
+
+input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+
+# region fastio
+
+BUFSIZE = 8192
+
+
+class FastIO(IOBase):
+    newlines = 0
+
+    def __init__(self, file):
+        self._file = file
+        self._fd = file.fileno()
+        self.buffer = BytesIO()
+        self.writable = "x" in file.mode or "r" not in file.mode
+        self.write = self.buffer.write if self.writable else None
+
+    def read(self):
+        while True:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            if not b:
+                break
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines = 0
+        return self.buffer.read()
+
+    def readline(self):
+        while self.newlines == 0:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            self.newlines = b.count(b"\n") + (not b)
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines -= 1
+        return self.buffer.readline()
+
+    def flush(self):
+        if self.writable:
+            os.write(self._fd, self.buffer.getvalue())
+            self.buffer.truncate(0), self.buffer.seek(0)
+
+
+class IOWrapper(IOBase):
+    def __init__(self, file):
+        self.buffer = FastIO(file)
+        self.flush = self.buffer.flush
+        self.writable = self.buffer.writable
+        self.write = lambda s: self.buffer.write(s.encode("ascii"))
+        self.read = lambda: self.buffer.read().decode("ascii")
+        self.readline = lambda: self.buffer.readline().decode("ascii")
+
+
+sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
+
+
+# endregion
+
+
+def main():
+    n, q = ints()
+    a = [strs() for i in range(q)]
+    #print(a)
+    print(solve(n, q, a))
+
+
+
+def solve(n, q, a):
+    e = [[0] * (q + 1) for _ in range(n)]
+    s = [[0] * (q + 1) for _ in range(n)]
+    for j in range(1, q + 1):
+        i, g = int(a[j - 1][0]) - 1, a[j - 1][1]
+        for k in range(n):
+            e[k][j] = e[k][j - 1]
+            s[k][j] = s[k][j - 1]
+        (e if g == '+' else s)[i][j] += 1
+    #print(s, e)
+    matching = [[max(e[i][t] + 1 - s[j][t] for t in range(q + 1)) if i != j else 0 for j in range(n)] for i in range(n)]
+    size = 1 << n
+    dp_min = [[INF] * n for _ in range(size)]
+    dp_ans = [[INF] * n for _ in range(size)]
+    for last in range(n):
+        mask = 1 << last
+        dp_min[mask][last] = 1
+        dp_ans[mask][last] = 1 + e[last][q]
+    for mask in range(1, size):
+        for last in range(n):
+            if not (mask & (1 << last)):
+                continue
+            prev_mask = mask ^ (1 << last)
+            if prev_mask == 0:
+                continue
+            for prev in range(n):
+                if not (prev_mask & (1 << prev)):
+                    continue
+                next_min = dp_min[prev_mask][prev]
+                next_ans = dp_ans[prev_mask][prev]
+                new_min = next_min + matching[prev][last]
+                cur = max(next_ans, new_min + e[last][q])
+                if cur < dp_ans[mask][last] or (cur == dp_ans[mask][last] and new_min < dp_min[mask][last]):
+                    dp_min[mask][last] = new_min
+                    dp_ans[mask][last] = cur
+    return min(dp_ans[ (1 << n) - 1][last] for last in range(n))
+
+if __name__ == "__main__":
+    main()
Index: USACO GUIDE/GOLD/Combinatory/Timus - 2018. The Debut Album.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/USACO GUIDE/GOLD/Combinatory/Timus - 2018. The Debut Album.py b/USACO GUIDE/GOLD/Combinatory/Timus - 2018. The Debut Album.py
new file mode 100644
--- /dev/null	(date 1731465246908)
+++ b/USACO GUIDE/GOLD/Combinatory/Timus - 2018. The Debut Album.py	(date 1731465246908)
@@ -0,0 +1,108 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+
+input = lambda: sys.stdin.readline().strip()
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+
+def ints(): return map(int, input().split())
+
+
+def strs(): return input().split()
+
+
+def chars(): return list(input().strip())
+
+
+def mat(n): return [list(ints()) for _ in range(n)]
+
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+
+def add(x, y, mod=MOD): return (x + y) % mod
+
+
+def sub(x, y, mod=MOD): return (x - y) % mod
+
+
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+
+RANDOM = getrandbits(32)
+
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+n, a, b = 0, 0, 0
+
+
+def main():
+    global n, a, b
+    n, a, b = ints()
+    dp1 = [0] * (n + 1)
+    dp2 = [0] * (n + 1)
+    prefix_a = [0] * (n + 2)
+    prefix_b = [0] * (n + 2)
+    dp1[0] = dp2[0] = 0
+    prefix_a[0] = prefix_b[0] = 0
+    dp1[0] = dp2[0] = 1
+    prefix_a[1] = dp1[0]
+    prefix_b[1] = dp2[0]
+    for i in range(1, n + 1):
+        l = max(0, i - a)
+        r = i - 1
+        dp1[i] = (prefix_b[r + 1] % MOD - prefix_b[l] % MOD) % MOD
+        prefix_a[i + 1] = (prefix_a[i] % MOD + dp1[i] % MOD) % MOD
+        l = max(0, i - b)
+        r = i - 1
+        dp2[i] = (prefix_a[r + 1] % MOD - prefix_a[l] % MOD) % MOD
+        prefix_b[i + 1] = (prefix_b[i] % MOD + dp2[i] % MOD) % MOD
+    ans = (dp1[n] % MOD + dp2[n] % MOD) % MOD
+    print(ans % MOD)
+
+
+@lru_cache(maxsize=None)
+def solve(i, last, sec):
+    if i == n:
+        return 1
+    if last == -1:
+        return (solve(i + 1, 1, 1) % MOD + solve(i + 1, 2, 1) % MOD) % MOD
+    ans = solve(i + 1, 3 - last, 1) % MOD
+    if (last == 1 and sec < a) or (last == 2 and sec < b):
+        ans += solve(i + 1, last, sec + 1) % MOD
+    return ans % MOD
+
+
+if __name__ == "__main__":
+    main()
Index: Codeforces/Educational Codeforces Round 173/A.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Codeforces/Educational Codeforces Round 173/A.py b/Codeforces/Educational Codeforces Round 173/A.py
new file mode 100644
--- /dev/null	(date 1735051009932)
+++ b/Codeforces/Educational Codeforces Round 173/A.py	(date 1735051009932)
@@ -0,0 +1,137 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+from types import GeneratorType
+
+input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+
+# region fastio
+
+BUFSIZE = 8192
+
+
+class FastIO(IOBase):
+    newlines = 0
+
+    def __init__(self, file):
+        self._file = file
+        self._fd = file.fileno()
+        self.buffer = BytesIO()
+        self.writable = "x" in file.mode or "r" not in file.mode
+        self.write = self.buffer.write if self.writable else None
+
+    def read(self):
+        while True:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            if not b:
+                break
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines = 0
+        return self.buffer.read()
+
+    def readline(self):
+        while self.newlines == 0:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            self.newlines = b.count(b"\n") + (not b)
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines -= 1
+        return self.buffer.readline()
+
+    def flush(self):
+        if self.writable:
+            os.write(self._fd, self.buffer.getvalue())
+            self.buffer.truncate(0), self.buffer.seek(0)
+
+
+class IOWrapper(IOBase):
+    def __init__(self, file):
+        self.buffer = FastIO(file)
+        self.flush = self.buffer.flush
+        self.writable = self.buffer.writable
+        self.write = lambda s: self.buffer.write(s.encode("ascii"))
+        self.read = lambda: self.buffer.read().decode("ascii")
+        self.readline = lambda: self.buffer.readline().decode("ascii")
+
+
+sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
+
+
+# endregion
+
+
+def main():
+    t = int(input())
+    for _ in range(t):
+        n = int(input())
+        ans = 1
+        while n > 3:
+            ans *= 2
+            n //=  4
+        print(ans)
+if __name__ == "__main__":
+    main()
Index: Codeforces/Educational Codeforces Round 173/B.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Codeforces/Educational Codeforces Round 173/B.py b/Codeforces/Educational Codeforces Round 173/B.py
new file mode 100644
--- /dev/null	(date 1735052106864)
+++ b/Codeforces/Educational Codeforces Round 173/B.py	(date 1735052106864)
@@ -0,0 +1,144 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+from types import GeneratorType
+
+input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+
+# region fastio
+
+BUFSIZE = 8192
+
+
+class FastIO(IOBase):
+    newlines = 0
+
+    def __init__(self, file):
+        self._file = file
+        self._fd = file.fileno()
+        self.buffer = BytesIO()
+        self.writable = "x" in file.mode or "r" not in file.mode
+        self.write = self.buffer.write if self.writable else None
+
+    def read(self):
+        while True:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            if not b:
+                break
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines = 0
+        return self.buffer.read()
+
+    def readline(self):
+        while self.newlines == 0:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            self.newlines = b.count(b"\n") + (not b)
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines -= 1
+        return self.buffer.readline()
+
+    def flush(self):
+        if self.writable:
+            os.write(self._fd, self.buffer.getvalue())
+            self.buffer.truncate(0), self.buffer.seek(0)
+
+
+class IOWrapper(IOBase):
+    def __init__(self, file):
+        self.buffer = FastIO(file)
+        self.flush = self.buffer.flush
+        self.writable = self.buffer.writable
+        self.write = lambda s: self.buffer.write(s.encode("ascii"))
+        self.read = lambda: self.buffer.read().decode("ascii")
+        self.readline = lambda: self.buffer.readline().decode("ascii")
+
+
+sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
+
+
+# endregion
+
+
+def main():
+    t = int(input())
+    for _ in range(t):
+        n, d = ints()
+        print(solve(n, d))
+
+
+def solve(n, d):
+    ans = [1]
+    odds = {3, 6, 9}
+    if n >= 3 or (n == 2 and d in odds): ans.append(3)
+    if d == 5: ans.append(5)
+    if n >= 3 or (n == 2 and d == 7): ans.append(7)
+    if n >= 6 or (n == 2 and d == 9) or (3 <= n <= 5 and d in odds): ans.append(9)
+    return ' '.join(map(str, ans))
+
+if __name__ == "__main__":
+    main()
Index: Codeforces/Educational Codeforces Round 173/C.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Codeforces/Educational Codeforces Round 173/C.py b/Codeforces/Educational Codeforces Round 173/C.py
new file mode 100644
--- /dev/null	(date 1735055966188)
+++ b/Codeforces/Educational Codeforces Round 173/C.py	(date 1735055966188)
@@ -0,0 +1,191 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+from types import GeneratorType
+
+input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+
+# region fastio
+
+BUFSIZE = 8192
+
+
+class FastIO(IOBase):
+    newlines = 0
+
+    def __init__(self, file):
+        self._file = file
+        self._fd = file.fileno()
+        self.buffer = BytesIO()
+        self.writable = "x" in file.mode or "r" not in file.mode
+        self.write = self.buffer.write if self.writable else None
+
+    def read(self):
+        while True:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            if not b:
+                break
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines = 0
+        return self.buffer.read()
+
+    def readline(self):
+        while self.newlines == 0:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            self.newlines = b.count(b"\n") + (not b)
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines -= 1
+        return self.buffer.readline()
+
+    def flush(self):
+        if self.writable:
+            os.write(self._fd, self.buffer.getvalue())
+            self.buffer.truncate(0), self.buffer.seek(0)
+
+
+class IOWrapper(IOBase):
+    def __init__(self, file):
+        self.buffer = FastIO(file)
+        self.flush = self.buffer.flush
+        self.writable = self.buffer.writable
+        self.write = lambda s: self.buffer.write(s.encode("ascii"))
+        self.read = lambda: self.buffer.read().decode("ascii")
+        self.readline = lambda: self.buffer.readline().decode("ascii")
+
+
+sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
+
+
+# endregion
+
+
+def main():
+    t = int(input())
+    for _ in range(t):
+        n = int(input())
+        a = list(ints())
+        print(solve(n, a))
+
+def minmax_kadane(a):
+    prefix = min_pref = max_pref = 0
+    min_kadane, max_kadane = INF, -INF
+    for it in a:
+        prefix += it
+        max_kadane, min_kadane = max(max_kadane, prefix - min_pref), min(min_kadane, prefix - max_pref)
+        min_pref, max_pref = min(min_pref, prefix), max(max_pref, prefix)
+    return min(min_kadane, 0), max(max_kadane, 0)
+
+def suffix_(a):
+    if len(a) == 0: return 0, 0
+    prefix = [0] + list(accumulate(a))
+    total = prefix[-1]
+    min_pref, max_pref = INF, -INF
+    for i in range(len(a) + 1):
+        min_pref = min(min_pref,  prefix[i])
+        max_pref = max(max_pref, prefix[i])
+    return total - max_pref, total - min_pref
+
+def prefix_(a):
+    if not a: return 0, 0
+    prefix = min_pref = max_pref = 0
+    for x in a:
+        prefix += x
+        min_pref = min(min_pref, prefix)
+        max_pref = max(max_pref, prefix)
+    return min_pref, max_pref
+
+def solve(n, a):
+    res = []
+    pos =  next((i for i, v in enumerate(a) if v not in (-1, 1)), -1)
+    if pos == -1:
+        l, r = minmax_kadane(a)
+        res.append(str(r - l + 1))
+        res.append(" ".join(map(str, range(l, r + 1))) + " ")
+    else:
+        x = a[pos]
+        left, right = a[:pos], a[pos + 1:]
+        l_min, l_max = minmax_kadane(left)
+        r_min, r_max = minmax_kadane(right)
+        l_suffix, r_suffix = suffix_(left)
+        l_prefix, r_prefix = prefix_(right)
+        intervals = sorted([(l_min, l_max), (r_min, r_max), (l_suffix + x + l_prefix, r_suffix + x + r_prefix)])
+        merged = []
+        cur_start, cur_end = intervals[0]
+        for l, r in intervals[1:]:
+            if l <= cur_end + 1:
+                cur_end = max(cur_end, r)
+            else:
+                merged.append((cur_start, cur_end))
+                cur_start, cur_end = l, r
+        merged.append((cur_start, cur_end))
+        res.append(str(sum(e - s + 1 for s, e in merged)))
+        res.append(" ".join(str(it) for interval in merged for it in range(interval[0], interval[1]+1)))
+    return "\n".join(res)
+
+if __name__ == "__main__":
+    main()
Index: Codeforces/Educational Codeforces Round 173/E.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Codeforces/Educational Codeforces Round 173/E.py b/Codeforces/Educational Codeforces Round 173/E.py
new file mode 100644
--- /dev/null	(date 1735067359163)
+++ b/Codeforces/Educational Codeforces Round 173/E.py	(date 1735067359163)
@@ -0,0 +1,154 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+from types import GeneratorType
+
+input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+
+# region fastio
+
+BUFSIZE = 8192
+
+
+class FastIO(IOBase):
+    newlines = 0
+
+    def __init__(self, file):
+        self._file = file
+        self._fd = file.fileno()
+        self.buffer = BytesIO()
+        self.writable = "x" in file.mode or "r" not in file.mode
+        self.write = self.buffer.write if self.writable else None
+
+    def read(self):
+        while True:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            if not b:
+                break
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines = 0
+        return self.buffer.read()
+
+    def readline(self):
+        while self.newlines == 0:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            self.newlines = b.count(b"\n") + (not b)
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines -= 1
+        return self.buffer.readline()
+
+    def flush(self):
+        if self.writable:
+            os.write(self._fd, self.buffer.getvalue())
+            self.buffer.truncate(0), self.buffer.seek(0)
+
+
+class IOWrapper(IOBase):
+    def __init__(self, file):
+        self.buffer = FastIO(file)
+        self.flush = self.buffer.flush
+        self.writable = self.buffer.writable
+        self.write = lambda s: self.buffer.write(s.encode("ascii"))
+        self.read = lambda: self.buffer.read().decode("ascii")
+        self.readline = lambda: self.buffer.readline().decode("ascii")
+
+
+sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
+
+
+# endregion
+
+
+def main():
+    t = int(input())
+    for _ in range(t):
+        l,r,g = ints()
+        print(solve(l, r, g))
+
+
+def solve(l,r,g):
+    g_floor, g_ceil = r//g, (l+g-1)//g
+    if g_ceil > g_floor:
+        return f"{g} {g}" if g_ceil == 1 else "-1 -1"
+    elif g_ceil == g_floor:
+        return f"{g} {g}" if g_ceil == 1 else "-1 -1"
+    else:
+        l = list(range(g_ceil, min(g_floor, g_ceil + 25) + 1))
+        r = list(range(max(g_ceil, g_floor - 25), g_floor + 1))
+        ans = (-1, -1, -1)
+        for x in l:
+            for y in r:
+                if y >= x and gcd(x, y) == 1:
+                    diff = y - x
+                    if diff > ans[0] or (diff == ans[0] and x < ans[1]):
+                        ans = (diff, x, y)
+        return f"{g * ans[1]} {g * ans[2]}" if ans[0] >= 0 else (f"{g} {g}" if g_ceil <= 1 <= g_floor else "-1 -1")
+
+
+if __name__ == "__main__":
+    main()
Index: ICPC Preparation/Mathematics/Combinatorics/Binomial Coefficients/369 - Combinations.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ICPC Preparation/Mathematics/Combinatorics/Binomial Coefficients/369 - Combinations.py b/ICPC Preparation/Mathematics/Combinatorics/Binomial Coefficients/369 - Combinations.py
new file mode 100644
--- /dev/null	(date 1731599150667)
+++ b/ICPC Preparation/Mathematics/Combinatorics/Binomial Coefficients/369 - Combinations.py	(date 1731599150667)
@@ -0,0 +1,78 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+
+input = lambda: sys.stdin.readline().strip()
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+factors = []
+
+def factorization(n):
+    global factors
+    factors[0] = 0
+    factors[1] = 1
+    for i in range(2, n+1):
+        factors[i] = i * factors[i-1]
+
+def bin_coeff(n, k):
+    if n == k: return 1
+    return factors[n] // (factors[k] * factors[n-k])
+
+def main():
+    global factors
+    factors = [0] * 101
+    factorization(100)
+    while True:
+        s = input()
+        if not s:
+            break
+        a,b = map(int, s.split())
+        if not a and not b:
+            break
+        print(f"{a} things taken {b} at a time is {bin_coeff(a, b)} exactly.")
+
+
+
+if __name__ == "__main__":
+    main()
Index: ICPC Preparation/Graph/Finding Articulation PointsBridges/12783 - Weak Links.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ICPC Preparation/Graph/Finding Articulation PointsBridges/12783 - Weak Links.py b/ICPC Preparation/Graph/Finding Articulation PointsBridges/12783 - Weak Links.py
new file mode 100644
--- /dev/null	(date 1735085117436)
+++ b/ICPC Preparation/Graph/Finding Articulation PointsBridges/12783 - Weak Links.py	(date 1735085117436)
@@ -0,0 +1,186 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+from io import BytesIO, IOBase
+from types import GeneratorType
+from enum import Enum
+input = lambda: sys.stdin.readline().rstrip("\r\n")
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+def bootstrap(f, stack=[]):
+    def wrappedfunc(*args, **kwargs):
+        if stack:
+            return f(*args, **kwargs)
+        to = f(*args, **kwargs)
+        while True:
+            if type(to) is GeneratorType:
+                stack.append(to)
+                to = next(to)
+            else:
+                stack.pop()
+                if not stack:
+                    break
+                to = stack[-1].send(to)
+        return to
+
+    return wrappedfunc
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+
+# region fastio
+
+BUFSIZE = 8192
+
+
+class FastIO(IOBase):
+    newlines = 0
+
+    def __init__(self, file):
+        self._file = file
+        self._fd = file.fileno()
+        self.buffer = BytesIO()
+        self.writable = "x" in file.mode or "r" not in file.mode
+        self.write = self.buffer.write if self.writable else None
+
+    def read(self):
+        while True:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            if not b:
+                break
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines = 0
+        return self.buffer.read()
+
+    def readline(self):
+        while self.newlines == 0:
+            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
+            self.newlines = b.count(b"\n") + (not b)
+            ptr = self.buffer.tell()
+            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
+        self.newlines -= 1
+        return self.buffer.readline()
+
+    def flush(self):
+        if self.writable:
+            os.write(self._fd, self.buffer.getvalue())
+            self.buffer.truncate(0), self.buffer.seek(0)
+
+
+class IOWrapper(IOBase):
+    def __init__(self, file):
+        self.buffer = FastIO(file)
+        self.flush = self.buffer.flush
+        self.writable = self.buffer.writable
+        self.write = lambda s: self.buffer.write(s.encode("ascii"))
+        self.read = lambda: self.buffer.read().decode("ascii")
+        self.readline = lambda: self.buffer.readline().decode("ascii")
+
+
+sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
+
+
+# endregion
+
+
+def main():
+    while True:
+        n, m = ints()
+        if n == m == 0: break
+        AL = [[] for i in range(n)]
+        for i in range(m):
+            u, v = ints()
+            AL[u].append(v)
+            AL[v].append(u)
+
+        class flag(Enum):
+            UNVISITED = -1
+
+        dfs_num = []
+        dfs_low = []
+        dfs_parent = []
+        articulation_vertex = []
+        dfsNumberCounter = 0
+        dfsRoot = 0
+        rootChildren = 0
+        ans = []
+        def articulationPointAndBridge(u):
+            nonlocal AL
+            nonlocal dfs_num, dfs_parent, dfs_low, articulation_vertex
+            nonlocal dfsNumberCounter, dfsRoot, rootChildren
+
+            dfs_low[u] = dfs_num[u] = dfsNumberCounter
+            dfsNumberCounter += 1
+            for (v) in AL[u]:
+                if dfs_num[v] == flag.UNVISITED.value:
+                    dfs_parent[v] = u
+                    if u == dfsRoot:
+                        rootChildren += 1
+
+                    articulationPointAndBridge(v)
+
+                    if dfs_low[v] >= dfs_num[u]:
+                        articulation_vertex[u] = True
+                    if dfs_low[v] > dfs_num[u]:
+                        ans.append(u)
+                        ans.append(v)
+                    dfs_low[u] = min(dfs_low[u], dfs_low[v])
+                elif v != dfs_parent[u]:
+                    dfs_low[u] = min(dfs_low[u], dfs_num[v])
+        V = n
+        dfs_num = [flag.UNVISITED.value] * V
+        dfs_low = [0] * V
+        dfs_parent = [-1] * V
+        articulation_vertex = [False] * V
+        dfsNumberCounter = 0
+        for u in range(V):
+            if dfs_num[u] == flag.UNVISITED.value:
+                dfsRoot = u
+                rootChildren = 0
+                articulationPointAndBridge(u)
+        ans = [len(ans) // 2] + ans
+        print(*ans)
+
+if __name__ == "__main__":
+    main()
Index: ICPC Preparation/Mathematics/Combinatorics/Binomial Coefficients/10541 - Stripe.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ICPC Preparation/Mathematics/Combinatorics/Binomial Coefficients/10541 - Stripe.py b/ICPC Preparation/Mathematics/Combinatorics/Binomial Coefficients/10541 - Stripe.py
new file mode 100644
--- /dev/null	(date 1731629973232)
+++ b/ICPC Preparation/Mathematics/Combinatorics/Binomial Coefficients/10541 - Stripe.py	(date 1731629973232)
@@ -0,0 +1,97 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+
+input = lambda: sys.stdin.readline().strip()
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+
+def ints(): return map(int, input().split())
+
+
+def strs(): return input().split()
+
+
+def chars(): return list(input().strip())
+
+
+def mat(n): return [list(ints()) for _ in range(n)]
+
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+
+def add(x, y, mod=MOD): return (x + y) % mod
+
+
+def sub(x, y, mod=MOD): return (x - y) % mod
+
+
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+
+RANDOM = getrandbits(32)
+
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+factors = []
+
+
+def factorization(n):
+    global factors
+    factors[0] = 0
+    factors[1] = 1
+    for i in range(2, n + 1):
+        factors[i] = i * factors[i - 1]
+
+
+def bin_coeff(n, k):
+    if n == k or k == 0:return 1
+    return factors[n] // (factors[k] * factors[n-k])
+
+
+def main():
+    global factors
+    factors = [0] * 10001
+    factorization(10000)
+    t = int(input())
+    for _ in range(t):
+        a = list(ints())
+        total = sum(a[1:])
+        k = a[0] - total + 1
+        n = a[1] + 1
+        print(bin_coeff(n+k-1, k))
+
+
+if __name__ == "__main__":
+    main()
Index: ICPC Preparation/Mathematics/Combinatorics/Binomial Coefficients/11955 - Binomial Theorem.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ICPC Preparation/Mathematics/Combinatorics/Binomial Coefficients/11955 - Binomial Theorem.py b/ICPC Preparation/Mathematics/Combinatorics/Binomial Coefficients/11955 - Binomial Theorem.py
new file mode 100644
--- /dev/null	(date 1731633090413)
+++ b/ICPC Preparation/Mathematics/Combinatorics/Binomial Coefficients/11955 - Binomial Theorem.py	(date 1731633090413)
@@ -0,0 +1,114 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+
+input = lambda: sys.stdin.readline().strip()
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+
+def ints(): return map(int, input().split())
+
+
+def strs(): return input().split()
+
+
+def chars(): return list(input().strip())
+
+
+def mat(n): return [list(ints()) for _ in range(n)]
+
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+
+def add(x, y, mod=MOD): return (x + y) % mod
+
+
+def sub(x, y, mod=MOD): return (x - y) % mod
+
+
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+
+RANDOM = getrandbits(32)
+
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+factors = []
+
+
+def factorization(n):
+    global factors
+    factors[0] = 0
+    factors[1] = 1
+    for i in range(2, n + 1):
+        factors[i] = i * factors[i - 1]
+
+
+def bin_coeff(n):
+    c = [[0 for i in range(n)] for i in range(n)]
+    for n_ in range(1, n):
+        c[n_][0] = c[n_][n_] = 1
+        for k in range(1, n_):
+            c[n_][k] = c[n_ - 1][k - 1] + c[n_-1][k]
+    return c
+
+def main():
+    c = bin_coeff(51)
+    t = int(input())
+    for _ in range(t):
+        s = list(input().split("+"))
+        a = s[0][1:]
+        s = s[1].split('^')
+        b = s[0][:-1]
+        exp = int(s[1])
+        #print(a, b, exp)
+        s = ""
+        for k in range(exp+1):
+            if k == 0:
+                s += a + ("^" + str(exp - k) if exp - k > 1 else "")
+            elif k == exp:
+                s += b + ("^" + str(k) if k > 1 else "")
+            elif k != 0:
+                s += str(c[exp][k]) +"*" if c[exp][k] != 1 else ""
+                if k == 1:
+                    s += a + ("^" + str(exp - k) if exp - k > 1 else "") + "*"
+                    s += b
+                else:
+                    s += a + ("^" + str(exp - k) if exp - k > 1 else "") + "*"
+                    s+= b + "^" + str(k)
+            s+="+"
+        print(f"Case {_+1}: {s[:-1]}")
+
+if __name__ == "__main__":
+    main()
Index: ICPC Preparation/Mathematics/Combinatorics/Binomial Coefficients/12712 - Pattern Locker.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ICPC Preparation/Mathematics/Combinatorics/Binomial Coefficients/12712 - Pattern Locker.py b/ICPC Preparation/Mathematics/Combinatorics/Binomial Coefficients/12712 - Pattern Locker.py
new file mode 100644
--- /dev/null	(date 1731639679016)
+++ b/ICPC Preparation/Mathematics/Combinatorics/Binomial Coefficients/12712 - Pattern Locker.py	(date 1731639679016)
@@ -0,0 +1,110 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+
+input = lambda: sys.stdin.readline().strip()
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 10000000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+factors = []
+inv = []
+
+def factorization(n):
+    global factors, inv
+    factors = [1] * (n + 1)
+    inv = [1] * (n + 1)
+    for i in range(2, n + 1):
+        factors[i] = (i * factors[i - 1])
+        inv[i] = modInverse(factors[i], MOD)
+
+
+def extEuclid(a, b):
+    xx, yy = 0, 1
+    x, y = 1, 0
+    while b != 0:
+        q = a//b
+        a, b = b, a%b
+        x, xx = xx, x-q*xx
+        y, yy = yy, y-q*yy
+    return a, x, y
+
+def mod(a, m):
+  return ((a % m) + m) % m
+def modInverse(b, m):
+    d, x, y = extEuclid(b, m)
+    if d != 1:
+        return -1
+    return mod(x, m)
+
+def nPr(n, k):
+    if n < k:
+        return 0
+    if n == k:
+        return factors[n]
+    return (factors[n] * inv[n - k]) % MOD
+    return (factors[n] // factors[n - k])
+def main():
+    global factors
+    #max_ = 100 * 100 + 1
+    #factors = [0] * max_
+    #factorization(max_ - 1)
+    t = int(input())
+    res = []
+    for _ in range(t):
+        n, min_, max_ = ints()
+        ans = 1
+        n = n*n
+        total = 0
+        for i in range(1, min_):
+            ans *= (n-i + 1)
+            ans %= MOD
+        for i in range(min_, max_ + 1):
+            ans *= (n-i + 1)
+            ans %= MOD
+            total += ans % MOD
+        res.append(f"Case {_+1}: {total % MOD}")
+    print("\n".join(res))
+
+
+if __name__ == "__main__":
+    main()
Index: Codeforces/Codeforces Round 987 (Div 2)/A.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Codeforces/Codeforces Round 987 (Div 2)/A.py b/Codeforces/Codeforces Round 987 (Div 2)/A.py
new file mode 100644
--- /dev/null	(date 1731681264500)
+++ b/Codeforces/Codeforces Round 987 (Div 2)/A.py	(date 1731681264500)
@@ -0,0 +1,63 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+
+input = lambda: sys.stdin.readline().strip()
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+def main():
+    t = int(input())
+    for _ in range(t):
+        n = int(input())
+        a = list(ints())
+        print(solve(n, a))
+
+
+def solve(n ,a ):
+    return n-max([val for val in Counter(a).values()])
+
+
+
+if __name__ == "__main__":
+    main()
Index: Codeforces/Codeforces Round 987 (Div 2)/B.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Codeforces/Codeforces Round 987 (Div 2)/B.py b/Codeforces/Codeforces Round 987 (Div 2)/B.py
new file mode 100644
--- /dev/null	(date 1731674757721)
+++ b/Codeforces/Codeforces Round 987 (Div 2)/B.py	(date 1731674757721)
@@ -0,0 +1,68 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+
+input = lambda: sys.stdin.readline().strip()
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+def main():
+    t = int(input())
+    for _ in range(t):
+        n = int(input())
+        a = list(ints())
+        print(solve(n, a))
+
+
+def solve(n ,a ):
+    for i in range(n-1):
+        if a[i] - a[i+1] == 1:
+            a[i], a[i+1] = a[i+1], a[i]
+
+    sorted_v = sorted(a)
+    return "YES" if all(a[i] == sorted_v[i] for i in range(n)) else "NO"
+
+
+
+if __name__ == "__main__":
+    main()
Index: Codeforces/Codeforces Round 987 (Div 2)/C.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Codeforces/Codeforces Round 987 (Div 2)/C.py b/Codeforces/Codeforces Round 987 (Div 2)/C.py
new file mode 100644
--- /dev/null	(date 1731679800382)
+++ b/Codeforces/Codeforces Round 987 (Div 2)/C.py	(date 1731679800382)
@@ -0,0 +1,78 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+
+input = lambda: sys.stdin.readline().strip()
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+def main():
+    t = int(input())
+    for _ in range(t):
+        n = int(input())
+        print(*solve(n))
+
+
+def solve(n):
+    if n & 1 == 1:
+        if n < 27:
+            return [-1]
+        ans = [0] * (n + 1)
+        ans[1], ans[10], ans[26], ans[23], ans[27] = 1, 1, 1, 12, 12
+        count, cnt = 2, 0
+        for i in range(2, n + 1):
+            if ans[i] == 0:
+                if count == 12:
+                    count += 1
+                ans[i] = count
+                cnt = (cnt + 1) % 2
+                if cnt == 0:
+                    count += 1
+        return ans[1:n + 1]
+    else:
+        return [i // 2 + 1 for i in range(n)]
+
+# 1 2 2 3 3 4 4 5 5 1 6 6 7 7 8 8 9 9 10 10 11 11 12 13 13 1 12
+
+if __name__ == "__main__":
+    main()
Index: Codeforces/Codeforces Round 988 (Div 3)/A.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Codeforces/Codeforces Round 988 (Div 3)/A.py b/Codeforces/Codeforces Round 988 (Div 3)/A.py
new file mode 100644
--- /dev/null	(date 1731854341954)
+++ b/Codeforces/Codeforces Round 988 (Div 3)/A.py	(date 1731854341954)
@@ -0,0 +1,63 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+
+input = lambda: sys.stdin.readline().strip()
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+def main():
+    t = int(input())
+    for _ in range(t):
+        n = int(input())
+        a = list(ints())
+        print(solve(n, a))
+
+
+def solve(n ,a ):
+    frec = Counter(a)
+    return sum(floor(it / 2) for it in frec.values())
+
+
+if __name__ == "__main__":
+    main()
Index: Codeforces/Codeforces Round 988 (Div 3)/C.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Codeforces/Codeforces Round 988 (Div 3)/C.py b/Codeforces/Codeforces Round 988 (Div 3)/C.py
new file mode 100644
--- /dev/null	(date 1731857688837)
+++ b/Codeforces/Codeforces Round 988 (Div 3)/C.py	(date 1731857688837)
@@ -0,0 +1,90 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+
+input = lambda: sys.stdin.readline().strip()
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+
+def isPrime(num):
+    if num <= 1:
+        return False
+    if num <= 3:
+        return True
+    if num % 2 == 0 or num % 3 == 0:
+        return False
+    i = 5
+    while i * i <= num:
+        if num % i == 0 or num % (i + 2) == 0:
+            return False
+        i += 6
+    return True
+
+
+def main():
+    t = int(input())
+    for _ in range(t):
+        n = int(input())
+        print(*solve(n))
+
+
+def solve(n):
+    if n < 5:
+        return [-1]
+    ans = []
+    for i in range(1, n + 1, 2):
+        ans.append(i)
+    curr = n if n % 2 else n - 1
+    new_curr = -1
+    for i in range(2, n + 1, 2):
+        if not isPrime(curr + i):
+            ans.append(i)
+            new_curr = i
+            break
+    ans += [i for i in range(2, n + 1, 2) if i != new_curr]
+    return [-1] if new_curr == -1 else ans
+
+
+if __name__ == "__main__":
+    main()
\ No newline at end of file
Index: Meta Hacker Cup 2024/Round 2/in.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Meta Hacker Cup 2024/Round 2/in.txt b/Meta Hacker Cup 2024/Round 2/in.txt
new file mode 100644
--- /dev/null	(date 1738365574782)
+++ b/Meta Hacker Cup 2024/Round 2/in.txt	(date 1738365574782)
@@ -0,0 +1,3 @@
+version https://git-lfs.github.com/spec/v1
+oid sha256:f798ef1bb6bb8a2fdebd95a7ff781264cc41d426045779d19d0d12aa027292e8
+size 245495
Index: Codeforces/Codeforces Round 988 (Div 3)/F.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Codeforces/Codeforces Round 988 (Div 3)/F.py b/Codeforces/Codeforces Round 988 (Div 3)/F.py
new file mode 100644
--- /dev/null	(date 1731958225238)
+++ b/Codeforces/Codeforces Round 988 (Div 3)/F.py	(date 1731958225238)
@@ -0,0 +1,88 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+
+input = lambda: sys.stdin.readline().strip()
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def local_ans(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# count[wx] = count.get(wx, 0) + 1
+
+
+def can(mid, n, m, k, h, x):
+    local_ans = defaultdict(int)
+    for i in range(n):
+        r = m - (h[i] + mid- 1) // mid
+        lower_bound = x[i] - max(0, r)
+        local_ans[lower_bound] += 1
+        upper_bound = x[i] + max(0, r) + (1 if r >= 0 else 0)
+        local_ans[upper_bound] -= 1
+    kill = 0
+    for p in sorted(local_ans.keys()):
+        kill += local_ans[p]
+        if kill >= k:
+            return True
+
+    return False
+
+
+def main():
+    t = int(input())
+    res = []
+    for _ in range(t):
+        n, m, k = ints()
+        h = list(ints())
+        x = list(ints())
+        lo, hi, ans = 1, int(1e9), -1
+        while lo <= hi:
+            mid = (lo + hi) // 2
+            if can(mid, n, m, k, h, x):
+                ans = mid
+                hi = mid - 1
+            else:
+                lo = mid + 1
+        res.append(str(ans))
+    print("\n".join(res))
+
+
+
+if __name__ == "__main__":
+    main()
\ No newline at end of file
Index: USACO GUIDE/SILVER/Binary Seach/E. Minimizing Difference.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/USACO GUIDE/SILVER/Binary Seach/E. Minimizing Difference.py b/USACO GUIDE/SILVER/Binary Seach/E. Minimizing Difference.py
new file mode 100644
--- /dev/null	(date 1726277564758)
+++ b/USACO GUIDE/SILVER/Binary Seach/E. Minimizing Difference.py	(date 1726277564758)
@@ -0,0 +1,79 @@
+import os
+import sys
+from collections import *
+from heapq import *
+from math import gcd, floor, ceil, sqrt
+from copy import deepcopy
+from itertools import permutations, combinations, product
+from bisect import bisect_left, bisect_right
+from functools import lru_cache, reduce
+import operator
+from random import getrandbits
+from itertools import accumulate
+
+input = lambda: sys.stdin.readline().strip()
+flush = lambda: sys.stdout.flush()
+print = lambda *args, **kwargs: sys.stdout.write(' '.join(map(str, args)) + kwargs.get("end", "\n")) and flush()
+
+sys.setrecursionlimit(100000)
+
+
+def ints(): return map(int, input().split())
+def strs(): return input().split()
+def chars(): return list(input().strip())
+def mat(n): return [list(ints()) for _ in range(n)]
+
+INF = float('inf')
+MOD = 1000000007
+abcd = "abcdefghijklmnopqrstuvwxyz"
+
+def add(x, y, mod=MOD): return (x + y) % mod
+def sub(x, y, mod=MOD): return (x - y) % mod
+def mul(x, y, mod=MOD): return (x * y) % mod
+
+def invmod(a, mod=MOD): return powmod(a, mod - 2, mod)
+
+def lcm(a, b): return a * b // gcd(a, b)
+
+RANDOM = getrandbits(32)
+
+class Wrapper(int):
+    def __init__(self, x):
+        int.__init__(x)
+    def __hash__(self):
+        return super(Wrapper, self).__hash__() ^ RANDOM
+
+# wx = Wrapper(x)
+# cnt[wx] = cnt.get(wx, 0) + 1
+
+def main():
+    n, k = ints()
+    a = list(ints())
+    a.sort()
+    diff = [0] * (n - 1)
+    for i in range(n - 1):
+        diff[i] = a[i + 1] - a[i]
+    l, r = 0, n - 2
+    ans = a[-1] - a[0]
+    count = 1
+    while l < r:
+        x = min(k, (diff[l] + diff[r]) * count)
+        ans -= x // count
+        k -= x
+        l += 1
+        r -= 1
+        count += 1
+    if l == r:
+        x = min(k, (diff[l]) * count)
+        ans -= x // count
+    print(ans)
+
+
+
+def solve(n ,a ):
+    pass
+
+
+
+if __name__ == "__main__":
+    main()
diff --git a/Meta Hacker Cup 2024/Round 2/C/bunny_hopscotch_input/bunny_hopscotch_input.txt b/Meta Hacker Cup 2024/Round 2/C/bunny_hopscotch_input/bunny_hopscotch_input.txt
new file mode 100644
diff --git a/Meta Hacker Cup 2024/Round 2/B/B.py b/Meta Hacker Cup 2024/Round 2/B/B.py
new file mode 100644
diff --git a/Meta Hacker Cup 2024/Round 2/B/b_out.txt b/Meta Hacker Cup 2024/Round 2/B/b_out.txt
new file mode 100644
diff --git a/temp2.py b/temp2.py
new file mode 100644
diff --git a/ICPC Preparation/Mathematics/ Finding (Simple) Formula (or Pattern)/12918 - Lucky Thief.py b/ICPC Preparation/Mathematics/Ad Hoc Mathematics Problems/ Finding (Simple) Formula (or Pattern)/12918 - Lucky Thief.py
rename from ICPC Preparation/Mathematics/ Finding (Simple) Formula (or Pattern)/12918 - Lucky Thief.py
rename to ICPC Preparation/Mathematics/Ad Hoc Mathematics Problems/ Finding (Simple) Formula (or Pattern)/12918 - Lucky Thief.py
diff --git a/ICPC Preparation/Mathematics/ Finding (Simple) Formula (or Pattern)/10751 - Chessboard.py b/ICPC Preparation/Mathematics/Ad Hoc Mathematics Problems/ Finding (Simple) Formula (or Pattern)/10751 - Chessboard.py
rename from ICPC Preparation/Mathematics/ Finding (Simple) Formula (or Pattern)/10751 - Chessboard.py
rename to ICPC Preparation/Mathematics/Ad Hoc Mathematics Problems/ Finding (Simple) Formula (or Pattern)/10751 - Chessboard.py
diff --git a/ICPC Preparation/Mathematics/ Finding (Simple) Formula (or Pattern)/12004 - Bubble Sort.py b/ICPC Preparation/Mathematics/Ad Hoc Mathematics Problems/ Finding (Simple) Formula (or Pattern)/12004 - Bubble Sort.py
rename from ICPC Preparation/Mathematics/ Finding (Simple) Formula (or Pattern)/12004 - Bubble Sort.py
rename to ICPC Preparation/Mathematics/Ad Hoc Mathematics Problems/ Finding (Simple) Formula (or Pattern)/12004 - Bubble Sort.py
diff --git a/Meta Hacker Cup 2024/Round 2/C.py b/Meta Hacker Cup 2024/Round 2/C.py
new file mode 100644
diff --git a/Bootcamp/ CPCE3 - Concurso Equipos #17/g.py b/Bootcamp/ CPCE3 - Concurso Equipos #17/g.py
new file mode 100644
diff --git a/Bootcamp/2022-2023 ICPC Central Europe Regional Contest (CERC 22)/L.py b/Bootcamp/2022-2023 ICPC Central Europe Regional Contest (CERC 22)/L.py
new file mode 100644
diff --git a/Bootcamp/2022-2023 ICPC Central Europe Regional Contest (CERC 22)/D.py b/Bootcamp/2022-2023 ICPC Central Europe Regional Contest (CERC 22)/D.py
new file mode 100644
diff --git a/Bootcamp/2022-2023 ICPC Central Europe Regional Contest (CERC 22)/B.py b/Bootcamp/2022-2023 ICPC Central Europe Regional Contest (CERC 22)/B.py
new file mode 100644
